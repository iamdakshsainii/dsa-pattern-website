{
  "questionId": "PATTERN",
  "questionSlug": "median-in-a-row-wise-sorted-matrix",
  "title": "Median in a Row-wise Sorted Matrix",
  "difficulty": "Medium",
  "resources": {
    "geeksforgeeks": "https://www.geeksforgeeks.org/find-median-row-wise-sorted-matrix/",
    "videos": [
      {
        "title": "Median in Row-wise Sorted Matrix",
        "url": "https://www.youtube.com/watch?v=Q9wXgdxJq48",
        "channel": "takeUforward",
        "duration": "20:00",
        "language": "English"
      }
    ]
  },
  "problemStatement": "Given a row-wise sorted matrix of size m x n where m and n are always odd, find the median of the matrix.\n\nMedian is the middle element when all elements are sorted in ascending order. If there are odd number of elements (m*n), median is the ((m*n + 1)/2)th element.",
  "examples": [
    {
      "input": "matrix = [[1,3,5],[2,6,9],[3,6,9]]",
      "output": "5",
      "explanation": "Sorted array: [1,2,3,3,5,6,6,9,9]. Median = 5 (middle element)"
    },
    {
      "input": "matrix = [[1,5,7,9,11],[2,3,4,5,10],[9,10,12,14,16]]",
      "output": "9",
      "explanation": "Sorted: [1,2,3,4,5,5,7,9,9,10,10,11,12,14,16]. Median = 9 (8th element)"
    },
    {
      "input": "matrix = [[1],[2],[3]]",
      "output": "2"
    }
  ],
  "constraints": [
    "m, n are odd numbers",
    "1 <= m, n <= 1000",
    "1 <= matrix[i][j] <= 10^9",
    "Each row is sorted in non-decreasing order"
  ],
  "patternTriggers": "Row-wise sorted matrix + find median + odd dimensions = Binary search on value range with counting",
  "approaches": [
    {
      "name": "Flatten and Sort",
      "order": 1,
      "intuition": "Collect all elements, sort, find middle element",
      "approach": "Flatten matrix, sort, return middle element",
      "steps": [
        "Create array of all m*n elements",
        "Sort the array",
        "Return array[(m*n)/2] (0-indexed middle)"
      ],
      "complexity": {
        "time": "O(m*n log(m*n))",
        "space": "O(m*n)",
        "timeExplanation": "Sorting m*n elements",
        "spaceExplanation": "Store all elements"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int findMedian(vector<vector<int>>& matrix) {\n        vector<int> nums;\n        for (auto& row : matrix) {\n            for (int num : row) {\n                nums.push_back(num);\n            }\n        }\n        sort(nums.begin(), nums.end());\n        return nums[nums.size() / 2];\n    }\n};",
        "java": "class Solution {\n    public int findMedian(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[] nums = new int[m * n];\n        int idx = 0;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                nums[idx++] = matrix[i][j];\n            }\n        }\n        \n        Arrays.sort(nums);\n        return nums[nums.length / 2];\n    }\n}",
        "python": "class Solution:\n    def findMedian(self, matrix: List[List[int]]) -> int:\n        nums = []\n        for row in matrix:\n            nums.extend(row)\n        nums.sort()\n        return nums[len(nums) // 2]",
        "javascript": "var findMedian = function(matrix) {\n    const nums = [];\n    for (const row of matrix) {\n        nums.push(...row);\n    }\n    nums.sort((a, b) => a - b);\n    return nums[Math.floor(nums.length / 2)];\n};"
      }
    },
    {
      "name": "Min Heap with All Rows",
      "order": 2,
      "intuition": "Use min heap to merge sorted rows, extract (m*n+1)/2 elements",
      "approach": "Initialize heap with first element of each row, extract median count times",
      "steps": [
        "Create min heap with (value, row, col)",
        "Add matrix[i][0] for all rows",
        "Extract min (m*n+1)/2 times",
        "Return last extracted element"
      ],
      "complexity": {
        "time": "O(m*n log m)",
        "space": "O(m)",
        "timeExplanation": "Extract (m*n)/2 elements, each O(log m)",
        "spaceExplanation": "Heap stores at most m elements"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int findMedian(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        priority_queue<tuple<int,int,int>, \n                      vector<tuple<int,int,int>>, \n                      greater<tuple<int,int,int>>> pq;\n        \n        // Add first column\n        for (int i = 0; i < m; i++) {\n            pq.push({matrix[i][0], i, 0});\n        }\n        \n        int target = (m * n + 1) / 2;\n        int result = 0;\n        \n        for (int i = 0; i < target; i++) {\n            auto [val, row, col] = pq.top();\n            pq.pop();\n            result = val;\n            \n            if (col + 1 < n) {\n                pq.push({matrix[row][col+1], row, col+1});\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int findMedian(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\n            (a, b) -> Integer.compare(a[0], b[0])\n        );\n        \n        for (int i = 0; i < m; i++) {\n            pq.offer(new int[]{matrix[i][0], i, 0});\n        }\n        \n        int target = (m * n + 1) / 2;\n        int result = 0;\n        \n        for (int i = 0; i < target; i++) {\n            int[] curr = pq.poll();\n            result = curr[0];\n            int row = curr[1];\n            int col = curr[2];\n            \n            if (col + 1 < n) {\n                pq.offer(new int[]{matrix[row][col+1], row, col+1});\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def findMedian(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        heap = []\n        \n        for i in range(m):\n            heapq.heappush(heap, (matrix[i][0], i, 0))\n        \n        target = (m * n + 1) // 2\n        result = 0\n        \n        for _ in range(target):\n            result, row, col = heapq.heappop(heap)\n            \n            if col + 1 < n:\n                heapq.heappush(heap, (matrix[row][col+1], row, col+1))\n        \n        return result",
        "javascript": "var findMedian = function(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    const pq = new MinPriorityQueue({ priority: x => x[0] });\n    \n    for (let i = 0; i < m; i++) {\n        pq.enqueue([matrix[i][0], i, 0]);\n    }\n    \n    const target = Math.floor((m * n + 1) / 2);\n    let result = 0;\n    \n    for (let i = 0; i < target; i++) {\n        const [val, row, col] = pq.dequeue().element;\n        result = val;\n        \n        if (col + 1 < n) {\n            pq.enqueue([matrix[row][col+1], row, col+1]);\n        }\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Binary Search on Value Range (Optimal)",
      "order": 3,
      "intuition": "Binary search on value range. Median has exactly (m*n+1)/2 elements ≤ it. Count elements ≤ mid using binary search on each row.",
      "approach": "Binary search on values, count elements ≤ mid, find value with count >= (m*n+1)/2",
      "steps": [
        "Find min = minimum element, max = maximum element",
        "medianPosition = (m*n + 1) / 2",
        "Binary search on [min, max]:",
        "  mid = (min + max) / 2",
        "  count = countLessEqual(matrix, mid)",
        "  If count < medianPosition:",
        "    min = mid + 1 (need larger values)",
        "  Else:",
        "    max = mid - 1 (might find smaller)",
        "Return min"
      ],
      "complexity": {
        "time": "O(m log n * log(max-min))",
        "space": "O(1)",
        "timeExplanation": "Binary search on value range, count uses binary search on m rows O(m log n)",
        "spaceExplanation": "No extra space"
      },
      "code": {
        "cpp": "class Solution {\nprivate:\n    int countLessEqual(vector<vector<int>>& matrix, int target) {\n        int count = 0;\n        for (auto& row : matrix) {\n            // Binary search on each row\n            int pos = upper_bound(row.begin(), row.end(), target) - row.begin();\n            count += pos;\n        }\n        return count;\n    }\n    \npublic:\n    int findMedian(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        \n        int minVal = INT_MAX, maxVal = INT_MIN;\n        for (auto& row : matrix) {\n            minVal = min(minVal, row[0]);\n            maxVal = max(maxVal, row[n-1]);\n        }\n        \n        int desired = (m * n + 1) / 2;\n        \n        while (minVal < maxVal) {\n            int mid = minVal + (maxVal - minVal) / 2;\n            int count = countLessEqual(matrix, mid);\n            \n            if (count < desired) {\n                minVal = mid + 1;\n            } else {\n                maxVal = mid;\n            }\n        }\n        \n        return minVal;\n    }\n};",
        "java": "class Solution {\n    private int countLessEqual(int[][] matrix, int target) {\n        int count = 0;\n        for (int[] row : matrix) {\n            int left = 0, right = row.length;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (row[mid] <= target) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            count += left;\n        }\n        return count;\n    }\n    \n    public int findMedian(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        \n        int minVal = Integer.MAX_VALUE, maxVal = Integer.MIN_VALUE;\n        for (int i = 0; i < m; i++) {\n            minVal = Math.min(minVal, matrix[i][0]);\n            maxVal = Math.max(maxVal, matrix[i][n-1]);\n        }\n        \n        int desired = (m * n + 1) / 2;\n        \n        while (minVal < maxVal) {\n            int mid = minVal + (maxVal - minVal) / 2;\n            int count = countLessEqual(matrix, mid);\n            \n            if (count < desired) {\n                minVal = mid + 1;\n            } else {\n                maxVal = mid;\n            }\n        }\n        \n        return minVal;\n    }\n}",
        "python": "class Solution:\n    def countLessEqual(self, matrix: List[List[int]], target: int) -> int:\n        count = 0\n        for row in matrix:\n            # Binary search on each row\n            pos = bisect.bisect_right(row, target)\n            count += pos\n        return count\n    \n    def findMedian(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        \n        min_val = min(row[0] for row in matrix)\n        max_val = max(row[n-1] for row in matrix)\n        \n        desired = (m * n + 1) // 2\n        \n        while min_val < max_val:\n            mid = (min_val + max_val) // 2\n            count = self.countLessEqual(matrix, mid)\n            \n            if count < desired:\n                min_val = mid + 1\n            else:\n                max_val = mid\n        \n        return min_val",
        "javascript": "var findMedian = function(matrix) {\n    const countLessEqual = (target) => {\n        let count = 0;\n        for (const row of matrix) {\n            let left = 0, right = row.length;\n            while (left < right) {\n                const mid = Math.floor((left + right) / 2);\n                if (row[mid] <= target) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            count += left;\n        }\n        return count;\n    };\n    \n    const m = matrix.length, n = matrix[0].length;\n    \n    let minVal = Infinity, maxVal = -Infinity;\n    for (let i = 0; i < m; i++) {\n        minVal = Math.min(minVal, matrix[i][0]);\n        maxVal = Math.max(maxVal, matrix[i][n-1]);\n    }\n    \n    const desired = Math.floor((m * n + 1) / 2);\n    \n    while (minVal < maxVal) {\n        const mid = Math.floor((minVal + maxVal) / 2);\n        const count = countLessEqual(mid);\n        \n        if (count < desired) {\n            minVal = mid + 1;\n        } else {\n            maxVal = mid;\n        }\n    }\n    \n    return minVal;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Forgetting that m and n are always odd (guaranteed odd count)",
    "Calculating median position incorrectly (should be (m*n+1)/2 for 1-indexed)",
    "Not using binary search on each row in optimal solution",
    "Searching for count == desired instead of count >= desired",
    "Forgetting that answer must be actual matrix element"
  ],
  "hints": [
    "Key insight: Median is the element where exactly (m*n+1)/2 elements are ≤ it",
    "Binary search on VALUE range, not indices",
    "Use binary search (upper_bound) on each row to count elements ≤ mid efficiently",
    "Min value = smallest first element, Max value = largest last element",
    "Similar to Kth Smallest Element problem but k = (m*n+1)/2",
    "Final answer will always be an actual element in the matrix"
  ],
  "followUp": [
    "What if m*n is even (return average of two middle elements)?",
    "What if rows are not sorted (only columns sorted)?",
    "Can you find the kth smallest element using similar approach?",
    "What if we need to find median of entire 2D matrix range [r1,c1] to [r2,c2]?"
  ],
  "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Adobe"],
  "tags": ["binary-search", "matrix", "array"],
  "relatedProblems": [
    "Kth Smallest Element in a Sorted Matrix",
    "Find Median from Data Stream",
    "Search a 2D Matrix II",
    "Median of Two Sorted Arrays"
  ]
}
