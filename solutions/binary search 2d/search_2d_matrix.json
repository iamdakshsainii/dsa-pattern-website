{
  "questionId": "74",
  "questionSlug": "search-a-2d-matrix",
  "title": "Search a 2D Matrix",
  "difficulty": "Medium",
  "leetcodeLink": "https://leetcode.com/problems/search-a-2d-matrix/",
  "resources": {
    "leetcode": "https://leetcode.com/problems/search-a-2d-matrix/",
    "videos": [
      {
        "title": "Search a 2D Matrix - Binary Search",
        "url": "https://www.youtube.com/watch?v=Ber2pi2C0j0",
        "channel": "NeetCode",
        "duration": "8:45",
        "language": "English"
      }
    ]
  },
  "problemStatement": "Write an efficient algorithm that searches for a value target in an m x n integer matrix. This matrix has the following properties:\n- Integers in each row are sorted from left to right.\n- The first integer of each row is greater than the last integer of the previous row.\n\nReturn true if target is in matrix or false otherwise.",
  "examples": [
    {
      "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
      "output": "true",
      "explanation": "3 is found in the matrix at position (0,1)"
    },
    {
      "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
      "output": "false",
      "explanation": "13 is not present in the matrix"
    }
  ],
  "constraints": [
    "m == matrix.length",
    "n == matrix[i].length",
    "1 <= m, n <= 100",
    "-10^4 <= matrix[i][j], target <= 10^4"
  ],
  "patternTriggers": "Sorted 2D matrix (rows sorted + first of next > last of prev) + search = Treat as 1D sorted array with binary search",
  "approaches": [
    {
      "name": "Binary Search on Each Row",
      "order": 1,
      "intuition": "Since each row is sorted, apply binary search on each row sequentially",
      "approach": "Iterate through rows, apply binary search on each",
      "steps": [
        "For each row in matrix:",
        "  If target >= row[0] and target <= row[n-1]:",
        "    Apply binary search on this row",
        "    If found, return true",
        "Return false"
      ],
      "complexity": {
        "time": "O(m log n)",
        "space": "O(1)",
        "timeExplanation": "m rows, binary search O(log n) per row",
        "spaceExplanation": "No extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        \n        for (int i = 0; i < m; i++) {\n            if (target >= matrix[i][0] && target <= matrix[i][n-1]) {\n                // Binary search in this row\n                int left = 0, right = n - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (matrix[i][mid] == target) return true;\n                    else if (matrix[i][mid] < target) left = mid + 1;\n                    else right = mid - 1;\n                }\n            }\n        }\n        return false;\n    }\n};",
        "java": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        for (int i = 0; i < m; i++) {\n            if (target >= matrix[i][0] && target <= matrix[i][n-1]) {\n                int left = 0, right = n - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (matrix[i][mid] == target) return true;\n                    else if (matrix[i][mid] < target) left = mid + 1;\n                    else right = mid - 1;\n                }\n            }\n        }\n        return false;\n    }\n}",
        "python": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        \n        for i in range(m):\n            if matrix[i][0] <= target <= matrix[i][n-1]:\n                left, right = 0, n - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if matrix[i][mid] == target:\n                        return True\n                    elif matrix[i][mid] < target:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n        return False",
        "javascript": "var searchMatrix = function(matrix, target) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    \n    for (let i = 0; i < m; i++) {\n        if (target >= matrix[i][0] && target <= matrix[i][n-1]) {\n            let left = 0, right = n - 1;\n            while (left <= right) {\n                const mid = Math.floor((left + right) / 2);\n                if (matrix[i][mid] === target) return true;\n                else if (matrix[i][mid] < target) left = mid + 1;\n                else right = mid - 1;\n            }\n        }\n    }\n    return false;\n};"
      }
    },
    {
      "name": "Binary Search to Find Row, Then Search in Row",
      "order": 2,
      "intuition": "First find which row might contain target using binary search, then search in that row",
      "approach": "Two binary searches: find row, then search in row",
      "steps": [
        "Binary search on first column to find potential row",
        "Compare with first element of each row",
        "Once row found, binary search in that row",
        "Return result"
      ],
      "complexity": {
        "time": "O(log m + log n)",
        "space": "O(1)",
        "timeExplanation": "Binary search on rows O(log m), then on columns O(log n)",
        "spaceExplanation": "No extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        \n        // Find row using binary search\n        int top = 0, bottom = m - 1;\n        while (top <= bottom) {\n            int midRow = top + (bottom - top) / 2;\n            if (target >= matrix[midRow][0] && target <= matrix[midRow][n-1]) {\n                // Found potential row, search in it\n                int left = 0, right = n - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (matrix[midRow][mid] == target) return true;\n                    else if (matrix[midRow][mid] < target) left = mid + 1;\n                    else right = mid - 1;\n                }\n                return false;\n            }\n            else if (target < matrix[midRow][0]) bottom = midRow - 1;\n            else top = midRow + 1;\n        }\n        return false;\n    }\n};",
        "java": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        int top = 0, bottom = m - 1;\n        while (top <= bottom) {\n            int midRow = top + (bottom - top) / 2;\n            if (target >= matrix[midRow][0] && target <= matrix[midRow][n-1]) {\n                int left = 0, right = n - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (matrix[midRow][mid] == target) return true;\n                    else if (matrix[midRow][mid] < target) left = mid + 1;\n                    else right = mid - 1;\n                }\n                return false;\n            }\n            else if (target < matrix[midRow][0]) bottom = midRow - 1;\n            else top = midRow + 1;\n        }\n        return false;\n    }\n}",
        "python": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        \n        top, bottom = 0, m - 1\n        while top <= bottom:\n            mid_row = (top + bottom) // 2\n            if matrix[mid_row][0] <= target <= matrix[mid_row][n-1]:\n                left, right = 0, n - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if matrix[mid_row][mid] == target:\n                        return True\n                    elif matrix[mid_row][mid] < target:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                return False\n            elif target < matrix[mid_row][0]:\n                bottom = mid_row - 1\n            else:\n                top = mid_row + 1\n        return False",
        "javascript": "var searchMatrix = function(matrix, target) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    \n    let top = 0, bottom = m - 1;\n    while (top <= bottom) {\n        const midRow = Math.floor((top + bottom) / 2);\n        if (target >= matrix[midRow][0] && target <= matrix[midRow][n-1]) {\n            let left = 0, right = n - 1;\n            while (left <= right) {\n                const mid = Math.floor((left + right) / 2);\n                if (matrix[midRow][mid] === target) return true;\n                else if (matrix[midRow][mid] < target) left = mid + 1;\n                else right = mid - 1;\n            }\n            return false;\n        }\n        else if (target < matrix[midRow][0]) bottom = midRow - 1;\n        else top = midRow + 1;\n    }\n    return false;\n};"
      }
    },
    {
      "name": "Treat as 1D Sorted Array - Binary Search (Optimal)",
      "order": 3,
      "intuition": "Since matrix is fully sorted (first of next row > last of prev row), we can treat it as a single sorted array",
      "approach": "Map 2D indices to 1D, apply standard binary search",
      "steps": [
        "Treat m×n matrix as array of length m*n",
        "For index i in 1D: row = i/n, col = i%n",
        "Apply binary search on 0 to m*n-1",
        "Convert mid to (row, col) and compare",
        "Return result"
      ],
      "complexity": {
        "time": "O(log(m*n))",
        "space": "O(1)",
        "timeExplanation": "Single binary search on m*n elements",
        "spaceExplanation": "No extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        \n        int left = 0, right = m * n - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int row = mid / n;\n            int col = mid % n;\n            int midValue = matrix[row][col];\n            \n            if (midValue == target) return true;\n            else if (midValue < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        \n        return false;\n    }\n};",
        "java": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        int left = 0, right = m * n - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int row = mid / n;\n            int col = mid % n;\n            int midValue = matrix[row][col];\n            \n            if (midValue == target) return true;\n            else if (midValue < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        \n        return false;\n    }\n}",
        "python": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        \n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            row = mid // n\n            col = mid % n\n            mid_value = matrix[row][col]\n            \n            if mid_value == target:\n                return True\n            elif mid_value < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False",
        "javascript": "var searchMatrix = function(matrix, target) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    \n    let left = 0, right = m * n - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        const row = Math.floor(mid / n);\n        const col = mid % n;\n        const midValue = matrix[row][col];\n        \n        if (midValue === target) return true;\n        else if (midValue < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    \n    return false;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling edge cases (empty matrix, single element)",
    "Integer overflow when calculating mid (use left + (right-left)/2)",
    "Incorrect row/col calculation from 1D index",
    "Not considering that first of next row > last of previous row"
  ],
  "hints": [
    "Matrix property: completely sorted like 1D array",
    "Convert 2D to 1D: index i → row = i/n, col = i%n",
    "Use standard binary search template",
    "This is essentially searching in sorted array with extra step"
  ],
  "followUp": [
    "What if the matrix is not fully sorted (only rows sorted)?",
    "Can you do better than O(log(m*n))?",
    "What if you need to find position instead of just existence?"
  ],
  "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
  "tags": ["binary-search", "matrix", "array"],
  "relatedProblems": [
    "Search a 2D Matrix II",
    "Find Peak Element II",
    "Kth Smallest Element in a Sorted Matrix"
  ]
}
