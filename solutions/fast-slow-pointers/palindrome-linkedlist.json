{
  "questionId": "234",
  "questionSlug": "palindrome-linked-list",
  "title": "Palindrome Linked List",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/palindrome-linked-list/",
    "videos": [
      {
        "title": "Palindrome Linked List - O(1) Space",
        "url": "https://www.youtube.com/watch?v=yOzXms1J6Nk",
        "channel": "NeetCode",
        "duration": "8:45",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Check palindrome in linked list = Find middle with fast & slow, reverse second half, compare both halves.",
  "approaches": [
    {
      "name": "Array Conversion",
      "order": 1,
      "intuition": "Convert linked list to array, then use two pointers to check if array is palindrome.",
      "approach": "Store all values in array, use two pointers from start and end to compare.",
      "steps": [
        "Traverse list and store all values in array",
        "Use two pointers: left = 0, right = array.length - 1",
        "While left < right:",
        "  If array[left] != array[right]: return false",
        "  left++, right--",
        "Return true"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass to create array, then O(n) comparison",
        "spaceExplanation": "Array stores all n values"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        vector<int> values;\n        \n        // Store all values in array\n        ListNode* curr = head;\n        while (curr) {\n            values.push_back(curr->val);\n            curr = curr->next;\n        }\n        \n        // Two pointer comparison\n        int left = 0, right = values.size() - 1;\n        while (left < right) {\n            if (values[left] != values[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n};",
        "java": "class Solution {\n    public boolean isPalindrome(ListNode head) {\n        List<Integer> values = new ArrayList<>();\n        \n        // Store all values in array\n        ListNode curr = head;\n        while (curr != null) {\n            values.add(curr.val);\n            curr = curr.next;\n        }\n        \n        // Two pointer comparison\n        int left = 0, right = values.size() - 1;\n        while (left < right) {\n            if (!values.get(left).equals(values.get(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "python": "class Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        values = []\n        \n        # Store all values in array\n        curr = head\n        while curr:\n            values.append(curr.val)\n            curr = curr.next\n        \n        # Two pointer comparison\n        left, right = 0, len(values) - 1\n        while left < right:\n            if values[left] != values[right]:\n                return False\n            left += 1\n            right -= 1\n        \n        return True",
        "javascript": "var isPalindrome = function(head) {\n    const values = [];\n    \n    // Store all values in array\n    let curr = head;\n    while (curr) {\n        values.push(curr.val);\n        curr = curr.next;\n    }\n    \n    // Two pointer comparison\n    let left = 0, right = values.length - 1;\n    while (left < right) {\n        if (values[left] !== values[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n};"
      }
    },
    {
      "name": "Recursive (Using Call Stack)",
      "order": 2,
      "intuition": "Use recursion to reach the end, then compare values as we return from recursion (mimics reversing).",
      "approach": "Recursively reach end, compare with front pointer as we backtrack.",
      "steps": [
        "Use global/class variable frontPointer = head",
        "Recursively traverse to end of list",
        "On return, compare current node value with frontPointer",
        "Move frontPointer forward",
        "Return true if all comparisons match"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Visit each node once",
        "spaceExplanation": "Recursion stack depth is n"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    ListNode* frontPointer;\n    \n    bool isPalindrome(ListNode* head) {\n        frontPointer = head;\n        return recursiveCheck(head);\n    }\n    \nprivate:\n    bool recursiveCheck(ListNode* curr) {\n        if (curr == nullptr) {\n            return true;\n        }\n        \n        // Recurse to end\n        if (!recursiveCheck(curr->next)) {\n            return false;\n        }\n        \n        // Compare on way back\n        if (curr->val != frontPointer->val) {\n            return false;\n        }\n        \n        frontPointer = frontPointer->next;\n        return true;\n    }\n};",
        "java": "class Solution {\n    private ListNode frontPointer;\n    \n    public boolean isPalindrome(ListNode head) {\n        frontPointer = head;\n        return recursiveCheck(head);\n    }\n    \n    private boolean recursiveCheck(ListNode curr) {\n        if (curr == null) {\n            return true;\n        }\n        \n        // Recurse to end\n        if (!recursiveCheck(curr.next)) {\n            return false;\n        }\n        \n        // Compare on way back\n        if (curr.val != frontPointer.val) {\n            return false;\n        }\n        \n        frontPointer = frontPointer.next;\n        return true;\n    }\n}",
        "python": "class Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        self.front_pointer = head\n        \n        def recursive_check(curr):\n            if not curr:\n                return True\n            \n            # Recurse to end\n            if not recursive_check(curr.next):\n                return False\n            \n            # Compare on way back\n            if curr.val != self.front_pointer.val:\n                return False\n            \n            self.front_pointer = self.front_pointer.next\n            return True\n        \n        return recursive_check(head)",
        "javascript": "var isPalindrome = function(head) {\n    let frontPointer = head;\n    \n    function recursiveCheck(curr) {\n        if (!curr) {\n            return true;\n        }\n        \n        // Recurse to end\n        if (!recursiveCheck(curr.next)) {\n            return false;\n        }\n        \n        // Compare on way back\n        if (curr.val !== frontPointer.val) {\n            return false;\n        }\n        \n        frontPointer = frontPointer.next;\n        return true;\n    }\n    \n    return recursiveCheck(head);\n};"
      }
    },
    {
      "name": "Fast & Slow + Reverse Second Half - Optimal",
      "order": 3,
      "intuition": "Find middle using fast & slow pointers, reverse second half, compare first and second halves.",
      "approach": "Use fast & slow to find middle, reverse second half, compare both halves node by node.",
      "steps": [
        "Find middle of list using fast & slow pointers",
        "Reverse second half starting from middle",
        "Compare first half and reversed second half",
        "Optional: restore list by reversing second half again",
        "Return comparison result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Three passes: find middle, reverse, compare",
        "spaceExplanation": "Only constant extra space for pointers"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        if (!head || !head->next) return true;\n        \n        // Find middle\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast->next && fast->next->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        // Reverse second half\n        ListNode* secondHalf = reverse(slow->next);\n        \n        // Compare both halves\n        ListNode* p1 = head;\n        ListNode* p2 = secondHalf;\n        bool isPalin = true;\n        \n        while (p2) {\n            if (p1->val != p2->val) {\n                isPalin = false;\n                break;\n            }\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n        \n        // Optional: restore list\n        slow->next = reverse(secondHalf);\n        \n        return isPalin;\n    }\n    \nprivate:\n    ListNode* reverse(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        \n        while (curr) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        \n        return prev;\n    }\n};",
        "java": "class Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) return true;\n        \n        // Find middle\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        // Reverse second half\n        ListNode secondHalf = reverse(slow.next);\n        \n        // Compare both halves\n        ListNode p1 = head;\n        ListNode p2 = secondHalf;\n        boolean isPalin = true;\n        \n        while (p2 != null) {\n            if (p1.val != p2.val) {\n                isPalin = false;\n                break;\n            }\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        \n        // Optional: restore list\n        slow.next = reverse(secondHalf);\n        \n        return isPalin;\n    }\n    \n    private ListNode reverse(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        \n        while (curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        \n        return prev;\n    }\n}",
        "python": "class Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        if not head or not head.next:\n            return True\n        \n        # Find middle\n        slow = fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse second half\n        second_half = self.reverse(slow.next)\n        \n        # Compare both halves\n        p1, p2 = head, second_half\n        is_palin = True\n        \n        while p2:\n            if p1.val != p2.val:\n                is_palin = False\n                break\n            p1 = p1.next\n            p2 = p2.next\n        \n        # Optional: restore list\n        slow.next = self.reverse(second_half)\n        \n        return is_palin\n    \n    def reverse(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        \n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        return prev",
        "javascript": "var isPalindrome = function(head) {\n    if (!head || !head.next) return true;\n    \n    // Find middle\n    let slow = head;\n    let fast = head;\n    while (fast.next && fast.next.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    // Reverse second half\n    let secondHalf = reverse(slow.next);\n    \n    // Compare both halves\n    let p1 = head;\n    let p2 = secondHalf;\n    let isPalin = true;\n    \n    while (p2) {\n        if (p1.val !== p2.val) {\n            isPalin = false;\n            break;\n        }\n        p1 = p1.next;\n        p2 = p2.next;\n    }\n    \n    // Optional: restore list\n    slow.next = reverse(secondHalf);\n    \n    return isPalin;\n};\n\nfunction reverse(head) {\n    let prev = null;\n    let curr = head;\n    \n    while (curr) {\n        const next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n    }\n    \n    return prev;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not handling odd vs even length lists correctly when finding middle",
    "Forgetting to restore the list after reversing second half",
    "Comparing entire list instead of just first half with reversed second half",
    "Off-by-one errors in middle finding logic"
  ],
  "hints": [
    "You can find the middle using fast & slow pointers",
    "Reverse the second half and compare with first half",
    "For odd length, middle element doesn't need comparison",
    "Remember to restore the list if modification is not allowed"
  ],
  "followUp": [
    "Can you solve it in O(1) space? (Yes, reverse second half)",
    "What if you need to restore the original list structure?",
    "How to handle very large lists efficiently?"
  ],
  "companies": ["Facebook", "Amazon", "Microsoft", "Google", "Apple"],
  "tags": ["linked-list", "fast-slow-pointers", "two-pointers"],
  "relatedProblems": [
    "Reverse Linked List",
    "Valid Palindrome",
    "Middle of the Linked List"
  ]
}
