{
  "questionId": "141",
  "questionSlug": "linked-list-cycle",
  "title": "Linked List Cycle",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/linked-list-cycle/",
    "videos": [
      {
        "title": "Linked List Cycle - Floyd's Algorithm",
        "url": "https://www.youtube.com/watch?v=gBTe7lFR3vc",
        "channel": "NeetCode",
        "duration": "7:20",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Detect cycle in linked list = Floyd's Cycle Detection (Tortoise & Hare). Slow moves 1 step, fast moves 2 steps. If they meet, cycle exists.",
  "approaches": [
    {
      "name": "Hash Set",
      "order": 1,
      "intuition": "Store visited nodes in hash set. If we encounter a node already in set, there's a cycle.",
      "approach": "Traverse list, add each node to set. If node already exists in set, return true.",
      "steps": [
        "Create empty hash set",
        "Traverse list with current pointer",
        "For each node:",
        "  If node in set: return true (cycle found)",
        "  Add node to set",
        "  Move to next node",
        "Return false (no cycle)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Visit each node once",
        "spaceExplanation": "Hash set stores all nodes"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        unordered_set<ListNode*> visited;\n        ListNode* current = head;\n        \n        while (current) {\n            if (visited.count(current)) {\n                return true;\n            }\n            visited.insert(current);\n            current = current->next;\n        }\n        \n        return false;\n    }\n};",
        "java": "public class Solution {\n    public boolean hasCycle(ListNode head) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode current = head;\n        \n        while (current != null) {\n            if (visited.contains(current)) {\n                return true;\n            }\n            visited.add(current);\n            current = current.next;\n        }\n        \n        return false;\n    }\n}",
        "python": "class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        visited = set()\n        current = head\n        \n        while current:\n            if current in visited:\n                return True\n            visited.add(current)\n            current = current.next\n        \n        return False",
        "javascript": "var hasCycle = function(head) {\n    const visited = new Set();\n    let current = head;\n    \n    while (current) {\n        if (visited.has(current)) {\n            return true;\n        }\n        visited.add(current);\n        current = current.next;\n    }\n    \n    return false;\n};"
      }
    },
    {
      "name": "Floyd's Cycle Detection (Fast & Slow Pointers) - Optimal",
      "order": 2,
      "intuition": "Use two pointers at different speeds. If there's a cycle, fast pointer will eventually catch up to slow pointer.",
      "approach": "Slow moves 1 step, fast moves 2 steps. If they meet, cycle exists. If fast reaches null, no cycle.",
      "steps": [
        "Initialize slow = head, fast = head",
        "While fast and fast.next exist:",
        "  Move slow one step: slow = slow.next",
        "  Move fast two steps: fast = fast.next.next",
        "  If slow == fast:",
        "    Return true (cycle detected)",
        "Return false (fast reached end, no cycle)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Fast pointer visits at most 2n nodes",
        "spaceExplanation": "Only two pointer variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if (!head || !head->next) return false;\n        \n        ListNode* slow = head;\n        ListNode* fast = head;\n        \n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            \n            if (slow == fast) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n};",
        "java": "public class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}",
        "python": "class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head or not head.next:\n            return False\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                return True\n        \n        return False",
        "javascript": "var hasCycle = function(head) {\n    if (!head || !head.next) return false;\n    \n    let slow = head;\n    let fast = head;\n    \n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        \n        if (slow === fast) {\n            return true;\n        }\n    }\n    \n    return false;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not checking fast.next before accessing fast.next.next (causes null pointer)",
    "Checking equality before moving pointers in first iteration",
    "Using value comparison instead of reference comparison",
    "Not handling empty list or single node edge cases"
  ],
  "hints": [
    "Think of it as a race: if there's a cycle, faster runner will lap slower runner",
    "Fast pointer moves 2x speed of slow pointer",
    "If fast reaches null/end, no cycle exists",
    "If pointers meet, cycle must exist"
  ],
  "followUp": [
    "Find the node where cycle begins? (Linked List Cycle II)",
    "Find length of the cycle?",
    "Can you do it without modifying the list?"
  ],
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Apple"],
  "tags": ["linked-list", "fast-slow-pointers", "two-pointers"],
  "relatedProblems": [
    "Linked List Cycle II",
    "Happy Number",
    "Find the Duplicate Number"
  ]
}
