{
  "questionId": "56",
  "questionSlug": "merge-intervals",
  "title": "Merge Intervals",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/merge-intervals/",
    "videos": [
      {
        "title": "Merge Intervals - Sorting",
        "url": "https://www.youtube.com/watch?v=44H3cEC2fFM",
        "channel": "NeetCode",
        "duration": "9:15",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Merge overlapping intervals = Sort by start time, compare current interval's end with next interval's start.",
  "approaches": [
    {
      "name": "Brute Force - Compare All Pairs",
      "order": 1,
      "intuition": "Repeatedly find overlapping intervals and merge them until no more overlaps exist.",
      "approach": "Keep merging pairs of overlapping intervals until stable.",
      "steps": [
        "Keep looking for any two overlapping intervals",
        "When found, merge them",
        "Repeat until no overlaps remain",
        "Return merged intervals"
      ],
      "complexity": {
        "time": "O(nÂ³)",
        "space": "O(n)",
        "timeExplanation": "Multiple passes, each checking all pairs",
        "spaceExplanation": "Store result"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        if (intervals.empty()) return {};\n        \n        vector<vector<int>> result = intervals;\n        bool merged = true;\n        \n        while (merged) {\n            merged = false;\n            vector<vector<int>> temp;\n            vector<bool> used(result.size(), false);\n            \n            for (int i = 0; i < result.size(); i++) {\n                if (used[i]) continue;\n                \n                bool foundOverlap = false;\n                for (int j = i + 1; j < result.size(); j++) {\n                    if (used[j]) continue;\n                    \n                    // Check overlap\n                    if (result[i][1] >= result[j][0] && result[i][0] <= result[j][1]) {\n                        temp.push_back({\n                            min(result[i][0], result[j][0]),\n                            max(result[i][1], result[j][1])\n                        });\n                        used[i] = used[j] = true;\n                        foundOverlap = true;\n                        merged = true;\n                        break;\n                    }\n                }\n                \n                if (!foundOverlap && !used[i]) {\n                    temp.push_back(result[i]);\n                    used[i] = true;\n                }\n            }\n            \n            result = temp;\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        if (intervals.length == 0) return new int[0][];\n        \n        List<int[]> result = new ArrayList<>(Arrays.asList(intervals));\n        boolean merged = true;\n        \n        while (merged) {\n            merged = false;\n            List<int[]> temp = new ArrayList<>();\n            boolean[] used = new boolean[result.size()];\n            \n            for (int i = 0; i < result.size(); i++) {\n                if (used[i]) continue;\n                \n                boolean foundOverlap = false;\n                for (int j = i + 1; j < result.size(); j++) {\n                    if (used[j]) continue;\n                    \n                    // Check overlap\n                    if (result.get(i)[1] >= result.get(j)[0] && \n                        result.get(i)[0] <= result.get(j)[1]) {\n                        temp.add(new int[]{\n                            Math.min(result.get(i)[0], result.get(j)[0]),\n                            Math.max(result.get(i)[1], result.get(j)[1])\n                        });\n                        used[i] = used[j] = true;\n                        foundOverlap = true;\n                        merged = true;\n                        break;\n                    }\n                }\n                \n                if (!foundOverlap && !used[i]) {\n                    temp.add(result.get(i));\n                    used[i] = true;\n                }\n            }\n            \n            result = temp;\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}",
        "python": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals:\n            return []\n        \n        result = intervals[:]\n        merged = True\n        \n        while merged:\n            merged = False\n            temp = []\n            used = [False] * len(result)\n            \n            for i in range(len(result)):\n                if used[i]:\n                    continue\n                \n                found_overlap = False\n                for j in range(i + 1, len(result)):\n                    if used[j]:\n                        continue\n                    \n                    # Check overlap\n                    if result[i][1] >= result[j][0] and result[i][0] <= result[j][1]:\n                        temp.append([\n                            min(result[i][0], result[j][0]),\n                            max(result[i][1], result[j][1])\n                        ])\n                        used[i] = used[j] = True\n                        found_overlap = True\n                        merged = True\n                        break\n                \n                if not found_overlap and not used[i]:\n                    temp.append(result[i])\n                    used[i] = True\n            \n            result = temp\n        \n        return result",
        "javascript": "var merge = function(intervals) {\n    if (intervals.length === 0) return [];\n    \n    let result = intervals.slice();\n    let merged = true;\n    \n    while (merged) {\n        merged = false;\n        const temp = [];\n        const used = new Array(result.length).fill(false);\n        \n        for (let i = 0; i < result.length; i++) {\n            if (used[i]) continue;\n            \n            let foundOverlap = false;\n            for (let j = i + 1; j < result.length; j++) {\n                if (used[j]) continue;\n                \n                // Check overlap\n                if (result[i][1] >= result[j][0] && result[i][0] <= result[j][1]) {\n                    temp.push([\n                        Math.min(result[i][0], result[j][0]),\n                        Math.max(result[i][1], result[j][1])\n                    ]);\n                    used[i] = used[j] = true;\n                    foundOverlap = true;\n                    merged = true;\n                    break;\n                }\n            }\n            \n            if (!foundOverlap && !used[i]) {\n                temp.push(result[i]);\n                used[i] = true;\n            }\n        }\n        \n        result = temp;\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Sort and Merge - Optimal",
      "order": 2,
      "intuition": "Sort intervals by start time. Then linearly merge overlapping intervals by comparing current end with next start.",
      "approach": "Sort intervals, iterate and merge when overlap detected.",
      "steps": [
        "Sort intervals by start time",
        "Initialize result with first interval",
        "For each interval:",
        "  If overlaps with last in result:",
        "    Merge by updating last interval's end",
        "  Else:",
        "    Add to result",
        "Return result"
      ],
      "complexity": {
        "time": "O(n log n)",
        "space": "O(n)",
        "timeExplanation": "O(n log n) for sorting, O(n) for merging",
        "spaceExplanation": "O(n) for result (or O(log n) for sorting if in-place)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        if (intervals.empty()) return {};\n        \n        // Sort by start time\n        sort(intervals.begin(), intervals.end());\n        \n        vector<vector<int>> result;\n        result.push_back(intervals[0]);\n        \n        for (int i = 1; i < intervals.size(); i++) {\n            // Check if current overlaps with last merged interval\n            if (intervals[i][0] <= result.back()[1]) {\n                // Merge: update end to maximum\n                result.back()[1] = max(result.back()[1], intervals[i][1]);\n            } else {\n                // No overlap: add as new interval\n                result.push_back(intervals[i]);\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        if (intervals.length == 0) return new int[0][];\n        \n        // Sort by start time\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        List<int[]> result = new ArrayList<>();\n        result.add(intervals[0]);\n        \n        for (int i = 1; i < intervals.length; i++) {\n            int[] last = result.get(result.size() - 1);\n            \n            // Check if current overlaps with last merged interval\n            if (intervals[i][0] <= last[1]) {\n                // Merge: update end to maximum\n                last[1] = Math.max(last[1], intervals[i][1]);\n            } else {\n                // No overlap: add as new interval\n                result.add(intervals[i]);\n            }\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}",
        "python": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals:\n            return []\n        \n        # Sort by start time\n        intervals.sort(key=lambda x: x[0])\n        \n        result = [intervals[0]]\n        \n        for i in range(1, len(intervals)):\n            # Check if current overlaps with last merged interval\n            if intervals[i][0] <= result[-1][1]:\n                # Merge: update end to maximum\n                result[-1][1] = max(result[-1][1], intervals[i][1])\n            else:\n                # No overlap: add as new interval\n                result.append(intervals[i])\n        \n        return result",
        "javascript": "var merge = function(intervals) {\n    if (intervals.length === 0) return [];\n    \n    // Sort by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const result = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const last = result[result.length - 1];\n        \n        // Check if current overlaps with last merged interval\n        if (intervals[i][0] <= last[1]) {\n            // Merge: update end to maximum\n            last[1] = Math.max(last[1], intervals[i][1]);\n        } else {\n            // No overlap: add as new interval\n            result.push(intervals[i]);\n        }\n    }\n    \n    return result;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Forgetting to sort intervals first",
    "Using < instead of <= for overlap check",
    "Not updating end to maximum of both intervals",
    "Modifying intervals array in-place incorrectly"
  ],
  "hints": [
    "Sorting is key - sort by start time first",
    "Two intervals [a,b] and [c,d] overlap if a <= d and c <= b",
    "After sorting, only need to check adjacent intervals",
    "Merged interval: [min(start), max(end)]"
  ],
  "followUp": [
    "What if intervals are given in streaming fashion?",
    "Can you do it without extra space (in-place)?",
    "How to handle intervals on a circular timeline?"
  ],
  "companies": ["Facebook", "Amazon", "Microsoft", "Google", "Bloomberg"],
  "tags": ["intervals", "sorting", "array"],
  "relatedProblems": [
    "Insert Interval",
    "Meeting Rooms",
    "Meeting Rooms II",
    "Interval List Intersections"
  ]
}
