{
  "questionId": "986",
  "questionSlug": "interval-list-intersections",
  "title": "Interval List Intersections",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/interval-list-intersections/",
    "videos": [
      {
        "title": "Interval List Intersections - Two Pointers",
        "url": "https://www.youtube.com/watch?v=Qh8ZjL1RpLI",
        "channel": "NeetCode",
        "duration": "8:50",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Find intersections of two sorted interval lists = Two pointers, check overlap with max(start) and min(end), advance pointer with smaller end.",
  "approaches": [
    {
      "name": "Brute Force - Check All Pairs",
      "order": 1,
      "intuition": "Check every interval in first list against every interval in second list for overlaps.",
      "approach": "Nested loops to find all intersections.",
      "steps": [
        "For each interval in firstList:",
        "  For each interval in secondList:",
        "    Check if they overlap",
        "    If yes, compute intersection and add to result",
        "Return result"
      ],
      "complexity": {
        "time": "O(n * m)",
        "space": "O(1)",
        "timeExplanation": "Check all pairs of intervals",
        "spaceExplanation": "Not counting output space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, \n                                              vector<vector<int>>& secondList) {\n        vector<vector<int>> result;\n        \n        for (auto& first : firstList) {\n            for (auto& second : secondList) {\n                // Check overlap\n                int start = max(first[0], second[0]);\n                int end = min(first[1], second[1]);\n                \n                if (start <= end) {\n                    result.push_back({start, end});\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n        List<int[]> result = new ArrayList<>();\n        \n        for (int[] first : firstList) {\n            for (int[] second : secondList) {\n                // Check overlap\n                int start = Math.max(first[0], second[0]);\n                int end = Math.min(first[1], second[1]);\n                \n                if (start <= end) {\n                    result.add(new int[]{start, end});\n                }\n            }\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}",
        "python": "class Solution:\n    def intervalIntersection(self, firstList: List[List[int]], \n                            secondList: List[List[int]]) -> List[List[int]]:\n        result = []\n        \n        for first in firstList:\n            for second in secondList:\n                # Check overlap\n                start = max(first[0], second[0])\n                end = min(first[1], second[1])\n                \n                if start <= end:\n                    result.append([start, end])\n        \n        return result",
        "javascript": "var intervalIntersection = function(firstList, secondList) {\n    const result = [];\n    \n    for (const first of firstList) {\n        for (const second of secondList) {\n            // Check overlap\n            const start = Math.max(first[0], second[0]);\n            const end = Math.min(first[1], second[1]);\n            \n            if (start <= end) {\n                result.push([start, end]);\n            }\n        }\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Two Pointers - Optimal",
      "order": 2,
      "intuition": "Use two pointers, one for each list. Check overlap at current positions. Advance pointer of interval that ends first.",
      "approach": "Merge-like process using two pointers.",
      "steps": [
        "Initialize i = 0, j = 0",
        "While both pointers in bounds:",
        "  Calculate intersection:",
        "    start = max(firstList[i][0], secondList[j][0])",
        "    end = min(firstList[i][1], secondList[j][1])",
        "  If start <= end: add [start, end] to result",
        "  Advance pointer of interval that ends first:",
        "    If firstList[i][1] < secondList[j][1]: i++",
        "    Else: j++",
        "Return result"
      ],
      "complexity": {
        "time": "O(n + m)",
        "space": "O(1)",
        "timeExplanation": "Single pass through both lists",
        "spaceExplanation": "Not counting output space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, \n                                              vector<vector<int>>& secondList) {\n        vector<vector<int>> result;\n        int i = 0, j = 0;\n        \n        while (i < firstList.size() && j < secondList.size()) {\n            // Find intersection\n            int start = max(firstList[i][0], secondList[j][0]);\n            int end = min(firstList[i][1], secondList[j][1]);\n            \n            // If overlaps, add to result\n            if (start <= end) {\n                result.push_back({start, end});\n            }\n            \n            // Advance pointer of interval that ends first\n            if (firstList[i][1] < secondList[j][1]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0, j = 0;\n        \n        while (i < firstList.length && j < secondList.length) {\n            // Find intersection\n            int start = Math.max(firstList[i][0], secondList[j][0]);\n            int end = Math.min(firstList[i][1], secondList[j][1]);\n            \n            // If overlaps, add to result\n            if (start <= end) {\n                result.add(new int[]{start, end});\n            }\n            \n            // Advance pointer of interval that ends first\n            if (firstList[i][1] < secondList[j][1]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}",
        "python": "class Solution:\n    def intervalIntersection(self, firstList: List[List[int]], \n                            secondList: List[List[int]]) -> List[List[int]]:\n        result = []\n        i = j = 0\n        \n        while i < len(firstList) and j < len(secondList):\n            # Find intersection\n            start = max(firstList[i][0], secondList[j][0])\n            end = min(firstList[i][1], secondList[j][1])\n            \n            # If overlaps, add to result\n            if start <= end:\n                result.append([start, end])\n            \n            # Advance pointer of interval that ends first\n            if firstList[i][1] < secondList[j][1]:\n                i += 1\n            else:\n                j += 1\n        \n        return result",
        "javascript": "var intervalIntersection = function(firstList, secondList) {\n    const result = [];\n    let i = 0, j = 0;\n    \n    while (i < firstList.length && j < secondList.length) {\n        // Find intersection\n        const start = Math.max(firstList[i][0], secondList[j][0]);\n        const end = Math.min(firstList[i][1], secondList[j][1]);\n        \n        // If overlaps, add to result\n        if (start <= end) {\n            result.push([start, end]);\n        }\n        \n        // Advance pointer of interval that ends first\n        if (firstList[i][1] < secondList[j][1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    \n    return result;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Using < instead of <= for overlap check",
    "Advancing both pointers instead of just one",
    "Not handling the case where intervals have same end time",
    "Wrong calculation of intersection (should be max(starts), min(ends))"
  ],
  "hints": [
    "Both lists are already sorted - use two pointers!",
    "Intersection exists if max(start) <= min(end)",
    "Always advance the pointer whose interval ends first",
    "Similar to merging two sorted arrays"
  ],
  "followUp": [
    "What if lists were not sorted?",
    "How to handle if one list is much larger than the other?",
    "Can you solve with divide and conquer?"
  ],
  "companies": ["Facebook", "Amazon", "Microsoft", "Google"],
  "tags": ["intervals", "two-pointers", "array"],
  "relatedProblems": [
    "Merge Intervals",
    "Merge Sorted Array",
    "Employee Free Time"
  ]
}
