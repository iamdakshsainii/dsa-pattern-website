{
  "questionId": "57",
  "questionSlug": "insert-interval",
  "title": "Insert Interval",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/insert-interval/",
    "videos": [
      {
        "title": "Insert Interval - Linear Scan",
        "url": "https://www.youtube.com/watch?v=A8NUOmlwOlM",
        "channel": "NeetCode",
        "duration": "10:30",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Insert and merge interval in sorted list = Add intervals before, merge overlapping, add intervals after.",
  "approaches": [
    {
      "name": "Insert and Sort - Brute Force",
      "order": 1,
      "intuition": "Insert new interval, then sort and merge all intervals like standard merge intervals problem.",
      "approach": "Add new interval to list, sort, then merge overlaps.",
      "steps": [
        "Add newInterval to intervals list",
        "Sort all intervals by start time",
        "Merge overlapping intervals",
        "Return merged result"
      ],
      "complexity": {
        "time": "O(n log n)",
        "space": "O(n)",
        "timeExplanation": "Sorting dominates",
        "spaceExplanation": "Store result"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        // Add new interval\n        intervals.push_back(newInterval);\n        \n        // Sort by start time\n        sort(intervals.begin(), intervals.end());\n        \n        // Merge overlapping intervals\n        vector<vector<int>> result;\n        result.push_back(intervals[0]);\n        \n        for (int i = 1; i < intervals.size(); i++) {\n            if (intervals[i][0] <= result.back()[1]) {\n                result.back()[1] = max(result.back()[1], intervals[i][1]);\n            } else {\n                result.push_back(intervals[i]);\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        // Add new interval\n        List<int[]> list = new ArrayList<>(Arrays.asList(intervals));\n        list.add(newInterval);\n        \n        // Sort by start time\n        Collections.sort(list, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        // Merge overlapping intervals\n        List<int[]> result = new ArrayList<>();\n        result.add(list.get(0));\n        \n        for (int i = 1; i < list.size(); i++) {\n            int[] last = result.get(result.size() - 1);\n            if (list.get(i)[0] <= last[1]) {\n                last[1] = Math.max(last[1], list.get(i)[1]);\n            } else {\n                result.add(list.get(i));\n            }\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}",
        "python": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        # Add new interval\n        intervals.append(newInterval)\n        \n        # Sort by start time\n        intervals.sort()\n        \n        # Merge overlapping intervals\n        result = [intervals[0]]\n        \n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= result[-1][1]:\n                result[-1][1] = max(result[-1][1], intervals[i][1])\n            else:\n                result.append(intervals[i])\n        \n        return result",
        "javascript": "var insert = function(intervals, newInterval) {\n    // Add new interval\n    intervals.push(newInterval);\n    \n    // Sort by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    // Merge overlapping intervals\n    const result = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const last = result[result.length - 1];\n        if (intervals[i][0] <= last[1]) {\n            last[1] = Math.max(last[1], intervals[i][1]);\n        } else {\n            result.push(intervals[i]);\n        }\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Linear Scan - Three Parts - Optimal",
      "order": 2,
      "intuition": "Since intervals are already sorted, we can: 1) Add all intervals before newInterval, 2) Merge overlapping intervals, 3) Add remaining intervals.",
      "approach": "Three-phase linear scan without sorting.",
      "steps": [
        "Phase 1: Add all intervals that end before newInterval starts",
        "Phase 2: Merge all intervals that overlap with newInterval",
        "  Update newInterval to cover all overlaps",
        "  Add merged interval to result",
        "Phase 3: Add all remaining intervals after newInterval",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass through intervals",
        "spaceExplanation": "Store result"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>> result;\n        int i = 0;\n        int n = intervals.size();\n        \n        // Phase 1: Add all intervals before newInterval\n        while (i < n && intervals[i][1] < newInterval[0]) {\n            result.push_back(intervals[i]);\n            i++;\n        }\n        \n        // Phase 2: Merge all overlapping intervals\n        while (i < n && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        result.push_back(newInterval);\n        \n        // Phase 3: Add remaining intervals\n        while (i < n) {\n            result.push_back(intervals[i]);\n            i++;\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0;\n        int n = intervals.length;\n        \n        // Phase 1: Add all intervals before newInterval\n        while (i < n && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        // Phase 2: Merge all overlapping intervals\n        while (i < n && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        result.add(newInterval);\n        \n        // Phase 3: Add remaining intervals\n        while (i < n) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}",
        "python": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        # Phase 1: Add all intervals before newInterval\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        # Phase 2: Merge all overlapping intervals\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n        \n        # Phase 3: Add remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result",
        "javascript": "var insert = function(intervals, newInterval) {\n    const result = [];\n    let i = 0;\n    const n = intervals.length;\n    \n    // Phase 1: Add all intervals before newInterval\n    while (i < n && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    // Phase 2: Merge all overlapping intervals\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.push(newInterval);\n    \n    // Phase 3: Add remaining intervals\n    while (i < n) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    return result;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling edge cases: empty intervals, newInterval before/after all",
    "Wrong overlap condition: using < instead of <=",
    "Not updating both start and end when merging",
    "Forgetting to add the merged newInterval to result"
  ],
  "hints": [
    "Intervals are already sorted - don't need to sort again!",
    "Three clear phases: before, merge, after",
    "Overlap condition: interval.end >= newInterval.start AND interval.start <= newInterval.end",
    "Keep updating newInterval as you merge overlaps"
  ],
  "followUp": [
    "What if intervals were not sorted?",
    "Can you do it in-place?",
    "How to handle multiple new intervals to insert?"
  ],
  "companies": ["Facebook", "Google", "Amazon", "Microsoft", "LinkedIn"],
  "tags": ["intervals", "array"],
  "relatedProblems": [
    "Merge Intervals",
    "Range Module",
    "Add Bold Tag in String"
  ]
}
