{
  "questionId": "2402",
  "questionSlug": "maximum-cpu-load",
  "title": "Maximum CPU Load",
  "difficulty": "Hard",
  "resources": {
    "leetcode": "https://www.lintcode.com/problem/maximum-cpu-load/",
    "videos": [
      {
        "title": "Maximum CPU Load - Intervals Pattern",
        "url": "https://www.youtube.com/watch?v=VW1YHA535rU",
        "channel": "Algorithms Made Easy",
        "duration": "11:30",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Find maximum overlapping intervals with weights = Sort by start, use heap to track active jobs, update max load.",
  "approaches": [
    {
      "name": "Brute Force - Check All Time Points",
      "order": 1,
      "intuition": "For every possible time point, calculate the total load from all overlapping jobs.",
      "approach": "Check load at every start and end time of all jobs.",
      "steps": [
        "Collect all unique time points (starts and ends)",
        "For each time point:",
        "  Calculate sum of loads from all overlapping jobs",
        "  Update maximum load",
        "Return maximum"
      ],
      "complexity": {
        "time": "O(nÂ² * m)",
        "space": "O(m)",
        "timeExplanation": "n jobs, m unique time points, checking all jobs for each point",
        "spaceExplanation": "Store all time points"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int maxCPULoad(vector<vector<int>>& jobs) {\n        if (jobs.empty()) return 0;\n        \n        // Collect all time points\n        set<int> timePoints;\n        for (auto& job : jobs) {\n            timePoints.insert(job[0]);\n            timePoints.insert(job[1]);\n        }\n        \n        int maxLoad = 0;\n        \n        // Check load at each time point\n        for (int time : timePoints) {\n            int currentLoad = 0;\n            for (auto& job : jobs) {\n                // Job is active if time is in [start, end)\n                if (job[0] <= time && time < job[1]) {\n                    currentLoad += job[2]; // Add CPU load\n                }\n            }\n            maxLoad = max(maxLoad, currentLoad);\n        }\n        \n        return maxLoad;\n    }\n};",
        "java": "class Solution {\n    public int maxCPULoad(int[][] jobs) {\n        if (jobs.length == 0) return 0;\n        \n        // Collect all time points\n        Set<Integer> timePoints = new TreeSet<>();\n        for (int[] job : jobs) {\n            timePoints.add(job[0]);\n            timePoints.add(job[1]);\n        }\n        \n        int maxLoad = 0;\n        \n        // Check load at each time point\n        for (int time : timePoints) {\n            int currentLoad = 0;\n            for (int[] job : jobs) {\n                // Job is active if time is in [start, end)\n                if (job[0] <= time && time < job[1]) {\n                    currentLoad += job[2]; // Add CPU load\n                }\n            }\n            maxLoad = Math.max(maxLoad, currentLoad);\n        }\n        \n        return maxLoad;\n    }\n}",
        "python": "class Solution:\n    def maxCPULoad(self, jobs: List[List[int]]) -> int:\n        if not jobs:\n            return 0\n        \n        # Collect all time points\n        time_points = set()\n        for start, end, load in jobs:\n            time_points.add(start)\n            time_points.add(end)\n        \n        max_load = 0\n        \n        # Check load at each time point\n        for time in sorted(time_points):\n            current_load = 0\n            for start, end, load in jobs:\n                # Job is active if time is in [start, end)\n                if start <= time < end:\n                    current_load += load\n            max_load = max(max_load, current_load)\n        \n        return max_load",
        "javascript": "var maxCPULoad = function(jobs) {\n    if (jobs.length === 0) return 0;\n    \n    // Collect all time points\n    const timePoints = new Set();\n    for (const [start, end, load] of jobs) {\n        timePoints.add(start);\n        timePoints.add(end);\n    }\n    \n    let maxLoad = 0;\n    \n    // Check load at each time point\n    for (const time of Array.from(timePoints).sort((a, b) => a - b)) {\n        let currentLoad = 0;\n        for (const [start, end, load] of jobs) {\n            // Job is active if time is in [start, end)\n            if (start <= time && time < end) {\n                currentLoad += load;\n            }\n        }\n        maxLoad = Math.max(maxLoad, currentLoad);\n    }\n    \n    return maxLoad;\n};"
      }
    },
    {
      "name": "Min Heap (Priority Queue) - Optimal",
      "order": 2,
      "intuition": "Sort jobs by start time. Use min heap to track active jobs by end time. When adding new job, remove finished jobs and update current load.",
      "approach": "Process jobs chronologically, maintain active jobs in heap, track maximum concurrent load.",
      "steps": [
        "Sort jobs by start time",
        "Use min heap to track active jobs (by end time)",
        "For each job:",
        "  Remove finished jobs from heap (end <= current start)",
        "  Add current job's load to heap",
        "  Update maxLoad with current total load",
        "Return maxLoad"
      ],
      "complexity": {
        "time": "O(n log n)",
        "space": "O(n)",
        "timeExplanation": "O(n log n) for sorting, O(log n) for each heap operation",
        "spaceExplanation": "Heap can store all jobs in worst case"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int maxCPULoad(vector<vector<int>>& jobs) {\n        if (jobs.empty()) return 0;\n        \n        // Sort by start time\n        sort(jobs.begin(), jobs.end());\n        \n        // Min heap: {end_time, load}\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n        \n        int maxLoad = 0;\n        int currentLoad = 0;\n        \n        for (auto& job : jobs) {\n            int start = job[0], end = job[1], load = job[2];\n            \n            // Remove finished jobs\n            while (!minHeap.empty() && minHeap.top().first <= start) {\n                currentLoad -= minHeap.top().second;\n                minHeap.pop();\n            }\n            \n            // Add current job\n            minHeap.push({end, load});\n            currentLoad += load;\n            \n            maxLoad = max(maxLoad, currentLoad);\n        }\n        \n        return maxLoad;\n    }\n};",
        "java": "class Solution {\n    public int maxCPULoad(int[][] jobs) {\n        if (jobs.length == 0) return 0;\n        \n        // Sort by start time\n        Arrays.sort(jobs, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        // Min heap: stores {end_time, load}\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(\n            (a, b) -> Integer.compare(a[0], b[0])\n        );\n        \n        int maxLoad = 0;\n        int currentLoad = 0;\n        \n        for (int[] job : jobs) {\n            int start = job[0], end = job[1], load = job[2];\n            \n            // Remove finished jobs\n            while (!minHeap.isEmpty() && minHeap.peek()[0] <= start) {\n                currentLoad -= minHeap.poll()[1];\n            }\n            \n            // Add current job\n            minHeap.offer(new int[]{end, load});\n            currentLoad += load;\n            \n            maxLoad = Math.max(maxLoad, currentLoad);\n        }\n        \n        return maxLoad;\n    }\n}",
        "python": "import heapq\n\nclass Solution:\n    def maxCPULoad(self, jobs: List[List[int]]) -> int:\n        if not jobs:\n            return 0\n        \n        # Sort by start time\n        jobs.sort()\n        \n        # Min heap: (end_time, load)\n        min_heap = []\n        max_load = 0\n        current_load = 0\n        \n        for start, end, load in jobs:\n            # Remove finished jobs\n            while min_heap and min_heap[0][0] <= start:\n                _, job_load = heapq.heappop(min_heap)\n                current_load -= job_load\n            \n            # Add current job\n            heapq.heappush(min_heap, (end, load))\n            current_load += load\n            \n            max_load = max(max_load, current_load)\n        \n        return max_load",
        "javascript": "var maxCPULoad = function(jobs) {\n    if (jobs.length === 0) return 0;\n    \n    // Sort by start time\n    jobs.sort((a, b) => a[0] - b[0]);\n    \n    // Min heap: [end_time, load]\n    const minHeap = new MinPriorityQueue({ priority: x => x[0] });\n    \n    let maxLoad = 0;\n    let currentLoad = 0;\n    \n    for (const [start, end, load] of jobs) {\n        // Remove finished jobs\n        while (!minHeap.isEmpty() && minHeap.front().element[0] <= start) {\n            const finishedJob = minHeap.dequeue().element;\n            currentLoad -= finishedJob[1];\n        }\n        \n        // Add current job\n        minHeap.enqueue([end, load]);\n        currentLoad += load;\n        \n        maxLoad = Math.max(maxLoad, currentLoad);\n    }\n    \n    return maxLoad;\n};"
      }
    },
    {
      "name": "Event Sweep Line - Alternative Optimal",
      "order": 3,
      "intuition": "Create events for job start (+load) and end (-load). Sort events by time and process to find maximum load.",
      "approach": "Convert to events, sort by time, sweep through tracking cumulative load.",
      "steps": [
        "Create events: (start_time, +load) and (end_time, -load)",
        "Sort events by time (end before start if same time)",
        "Sweep through events:",
        "  Update current load",
        "  Track maximum load",
        "Return maximum"
      ],
      "complexity": {
        "time": "O(n log n)",
        "space": "O(n)",
        "timeExplanation": "Sorting 2n events",
        "spaceExplanation": "Store 2n events"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int maxCPULoad(vector<vector<int>>& jobs) {\n        if (jobs.empty()) return 0;\n        \n        // Create events: {time, load_change}\n        vector<pair<int, int>> events;\n        for (auto& job : jobs) {\n            events.push_back({job[0], job[2]});   // Start: +load\n            events.push_back({job[1], -job[2]});  // End: -load\n        }\n        \n        // Sort by time, end events before start if same time\n        sort(events.begin(), events.end(), [](auto& a, auto& b) {\n            if (a.first == b.first) {\n                return a.second < b.second; // End (-load) before start (+load)\n            }\n            return a.first < b.first;\n        });\n        \n        int maxLoad = 0;\n        int currentLoad = 0;\n        \n        for (auto& [time, loadChange] : events) {\n            currentLoad += loadChange;\n            maxLoad = max(maxLoad, currentLoad);\n        }\n        \n        return maxLoad;\n    }\n};",
        "java": "class Solution {\n    public int maxCPULoad(int[][] jobs) {\n        if (jobs.length == 0) return 0;\n        \n        // Create events: {time, load_change}\n        List<int[]> events = new ArrayList<>();\n        for (int[] job : jobs) {\n            events.add(new int[]{job[0], job[2]});   // Start: +load\n            events.add(new int[]{job[1], -job[2]});  // End: -load\n        }\n        \n        // Sort by time, end events before start if same time\n        Collections.sort(events, (a, b) -> {\n            if (a[0] == b[0]) {\n                return Integer.compare(a[1], b[1]); // End before start\n            }\n            return Integer.compare(a[0], b[0]);\n        });\n        \n        int maxLoad = 0;\n        int currentLoad = 0;\n        \n        for (int[] event : events) {\n            currentLoad += event[1];\n            maxLoad = Math.max(maxLoad, currentLoad);\n        }\n        \n        return maxLoad;\n    }\n}",
        "python": "class Solution:\n    def maxCPULoad(self, jobs: List[List[int]]) -> int:\n        if not jobs:\n            return 0\n        \n        # Create events: (time, load_change)\n        events = []\n        for start, end, load in jobs:\n            events.append((start, load))   # Start: +load\n            events.append((end, -load))    # End: -load\n        \n        # Sort by time, end events before start if same time\n        events.sort(key=lambda x: (x[0], x[1]))\n        \n        max_load = 0\n        current_load = 0\n        \n        for time, load_change in events:\n            current_load += load_change\n            max_load = max(max_load, current_load)\n        \n        return max_load",
        "javascript": "var maxCPULoad = function(jobs) {\n    if (jobs.length === 0) return 0;\n    \n    // Create events: [time, load_change]\n    const events = [];\n    for (const [start, end, load] of jobs) {\n        events.push([start, load]);   // Start: +load\n        events.push([end, -load]);    // End: -load\n    }\n    \n    // Sort by time, end events before start if same time\n    events.sort((a, b) => {\n        if (a[0] === b[0]) {\n            return a[1] - b[1]; // End before start\n        }\n        return a[0] - b[0];\n    });\n    \n    let maxLoad = 0;\n    let currentLoad = 0;\n    \n    for (const [time, loadChange] of events) {\n        currentLoad += loadChange;\n        maxLoad = Math.max(maxLoad, currentLoad);\n    }\n    \n    return maxLoad;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling jobs that end exactly when another starts",
    "Forgetting to remove finished jobs from heap before adding new ones",
    "In sweep line, processing events in wrong order when times are equal",
    "Treating intervals as closed on both ends instead of [start, end)"
  ],
  "hints": [
    "This is similar to 'Meeting Rooms II' but with weighted intervals",
    "Think of it as finding maximum overlapping weighted intervals",
    "Min heap can efficiently track and remove finished jobs",
    "Sweep line approach: create +load and -load events"
  ],
  "followUp": [
    "What if jobs have priorities in addition to load?",
    "How to handle jobs with dependencies?",
    "Can you return the time interval with maximum load?"
  ],
  "companies": ["Google", "Amazon", "Microsoft", "Facebook"],
  "tags": ["intervals", "heap", "sweep-line", "sorting"],
  "relatedProblems": [
    "Meeting Rooms II",
    "Car Pooling",
    "My Calendar III",
    "Employee Free Time"
  ]
}
