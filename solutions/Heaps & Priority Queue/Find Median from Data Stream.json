{
  "questionId": "LC-295",
  "questionSlug": "find-median-from-data-stream",
  "title": "Find Median from Data Stream",
  "difficulty": "Hard",
  "resources": {
    "leetcode": "https://leetcode.com/problems/find-median-from-data-stream/",
    "videos": [
      {
        "title": "Find Median from Data Stream - Two Heaps",
        "url": "https://www.youtube.com/watch?v=itmhHWaHupI",
        "channel": "NeetCode",
        "duration": "13:25",
        "language": "English"
      },
      {
        "title": "Median in Stream using Heaps",
        "url": "https://www.youtube.com/watch?v=1LkOrc-Le-Y",
        "channel": "take U forward",
        "duration": "18:40",
        "language": "English"
      },
      {
        "title": "Running Median - Two Heap Solution",
        "url": "https://www.youtube.com/watch?v=dshWERdcAdg",
        "channel": "Back To Back SWE",
        "duration": "14:15",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Find Median - Official Solution",
        "url": "https://leetcode.com/problems/find-median-from-data-stream/solution/",
        "source": "LeetCode"
      },
      {
        "title": "Running Median - Two Heaps Approach",
        "url": "https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Median in Stream Detailed",
        "url": "https://takeuforward.org/data-structure/find-median-from-data-stream/",
        "source": "takeuforward"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/find-median-from-data-stream/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Running median in stream? Use Two Heaps (max heap for left half, min heap for right half)!",
  "approaches": [
    {
      "name": "Sorting Every Time - Brute Force",
      "order": 1,
      "intuition": "Store all numbers, sort every time we need median.",
      "approach": "Maintain list of all numbers, sort to find median.",
      "steps": [
        "Store incoming numbers in array",
        "addNum: append to array - O(1)",
        "findMedian:",
        "  Sort array - O(n log n)",
        "  If odd length: return middle",
        "  If even length: return avg of two middles",
        "Very inefficient for frequent queries!"
      ],
      "complexity": {
        "time": "addNum: O(1), findMedian: O(n log n)",
        "space": "O(n)",
        "timeExplanation": "Sort entire array every time median is requested",
        "spaceExplanation": "Store all n numbers"
      },
      "code": {
        "cpp": "class MedianFinder {\nprivate:\n    vector<int> nums;\n    \npublic:\n    void addNum(int num) {\n        nums.push_back(num);\n    }\n    \n    double findMedian() {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        \n        if (n % 2 == 1) {\n            return nums[n / 2];\n        } else {\n            return (nums[n / 2 - 1] + nums[n / 2]) / 2.0;\n        }\n    }\n};\n\n// Example:\n// addNum(1), addNum(2), addNum(3)\n// findMedian: sort [1,2,3] → return 2",
        "java": "class MedianFinder {\n    private List<Integer> nums;\n    \n    public MedianFinder() {\n        nums = new ArrayList<>();\n    }\n    \n    public void addNum(int num) {\n        nums.add(num);\n    }\n    \n    public double findMedian() {\n        Collections.sort(nums);\n        int n = nums.size();\n        \n        if (n % 2 == 1) {\n            return nums.get(n / 2);\n        } else {\n            return (nums.get(n / 2 - 1) + nums.get(n / 2)) / 2.0;\n        }\n    }\n}",
        "python": "class MedianFinder:\n    def __init__(self):\n        self.nums = []\n    \n    def addNum(self, num: int) -> None:\n        self.nums.append(num)\n    \n    def findMedian(self) -> float:\n        self.nums.sort()\n        n = len(self.nums)\n        \n        if n % 2 == 1:\n            return self.nums[n // 2]\n        else:\n            return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2",
        "javascript": "var MedianFinder = function() {\n    this.nums = [];\n};\n\nMedianFinder.prototype.addNum = function(num) {\n    this.nums.push(num);\n};\n\nMedianFinder.prototype.findMedian = function() {\n    this.nums.sort((a, b) => a - b);\n    const n = this.nums.length;\n    \n    if (n % 2 === 1) {\n        return this.nums[Math.floor(n / 2)];\n    } else {\n        return (this.nums[n / 2 - 1] + this.nums[n / 2]) / 2;\n    }\n};"
      }
    },
    {
      "name": "Insertion Sort - Better",
      "order": 2,
      "intuition": "Keep array sorted at all times. Insert new number in correct position using binary search.",
      "approach": "Maintain sorted array, insert new elements in O(n) time.",
      "steps": [
        "Keep array always sorted",
        "addNum:",
        "  Binary search to find insert position - O(log n)",
        "  Insert at position - O(n) due to shifting",
        "findMedian:",
        "  Array already sorted!",
        "  Return middle element(s) - O(1)",
        "Better than sorting every time"
      ],
      "complexity": {
        "time": "addNum: O(n), findMedian: O(1)",
        "space": "O(n)",
        "timeExplanation": "Binary search O(log n) + insertion O(n) = O(n)",
        "spaceExplanation": "Store all n numbers in sorted array"
      },
      "code": {
        "cpp": "class MedianFinder {\nprivate:\n    vector<int> nums;\n    \npublic:\n    void addNum(int num) {\n        // Binary search for insert position\n        auto it = lower_bound(nums.begin(), nums.end(), num);\n        nums.insert(it, num);\n    }\n    \n    double findMedian() {\n        int n = nums.size();\n        \n        if (n % 2 == 1) {\n            return nums[n / 2];\n        } else {\n            return (nums[n / 2 - 1] + nums[n / 2]) / 2.0;\n        }\n    }\n};\n\n// Example:\n// addNum(1): [1]\n// addNum(3): [1,3]\n// addNum(2): binary search finds pos 1, insert → [1,2,3]\n// findMedian: [1,2,3] → 2",
        "java": "class MedianFinder {\n    private List<Integer> nums;\n    \n    public MedianFinder() {\n        nums = new ArrayList<>();\n    }\n    \n    public void addNum(int num) {\n        int pos = Collections.binarySearch(nums, num);\n        if (pos < 0) pos = -(pos + 1);\n        nums.add(pos, num);\n    }\n    \n    public double findMedian() {\n        int n = nums.size();\n        \n        if (n % 2 == 1) {\n            return nums.get(n / 2);\n        } else {\n            return (nums.get(n / 2 - 1) + nums.get(n / 2)) / 2.0;\n        }\n    }\n}",
        "python": "import bisect\n\nclass MedianFinder:\n    def __init__(self):\n        self.nums = []\n    \n    def addNum(self, num: int) -> None:\n        # Binary search insert\n        bisect.insort(self.nums, num)\n    \n    def findMedian(self) -> float:\n        n = len(self.nums)\n        \n        if n % 2 == 1:\n            return self.nums[n // 2]\n        else:\n            return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2",
        "javascript": "var MedianFinder = function() {\n    this.nums = [];\n};\n\nMedianFinder.prototype.addNum = function(num) {\n    let left = 0, right = this.nums.length;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (this.nums[mid] < num) left = mid + 1;\n        else right = mid;\n    }\n    this.nums.splice(left, 0, num);\n};\n\nMedianFinder.prototype.findMedian = function() {\n    const n = this.nums.length;\n    \n    if (n % 2 === 1) {\n        return this.nums[Math.floor(n / 2)];\n    } else {\n        return (this.nums[n / 2 - 1] + this.nums[n / 2]) / 2;\n    }\n};"
      }
    },
    {
      "name": "Two Heaps - Optimal",
      "order": 3,
      "intuition": "Split numbers into two halves: smaller half in max heap, larger half in min heap. Top of heaps give median!",
      "approach": "Maintain two heaps balanced in size. Max heap stores left half, min heap stores right half.",
      "steps": [
        "Max heap (left): stores smaller half of numbers",
        "Min heap (right): stores larger half of numbers",
        "Invariant: |left| == |right| or |left| == |right| + 1",
        "addNum:",
        "  Add to max heap first",
        "  Move max of left to min heap (balance)",
        "  If right becomes larger: move min back to left",
        "  Keeps sizes balanced!",
        "findMedian:",
        "  If odd total: return top of max heap",
        "  If even total: avg of both tops",
        "Both operations O(log n)!"
      ],
      "complexity": {
        "time": "addNum: O(log n), findMedian: O(1)",
        "space": "O(n)",
        "timeExplanation": "Heap operations (push/pop) are O(log n)",
        "spaceExplanation": "Two heaps store all n numbers"
      },
      "code": {
        "cpp": "class MedianFinder {\nprivate:\n    priority_queue<int> maxHeap; // Left half (smaller numbers)\n    priority_queue<int, vector<int>, greater<int>> minHeap; // Right half (larger numbers)\n    \npublic:\n    void addNum(int num) {\n        // Add to max heap first\n        maxHeap.push(num);\n        \n        // Balance: move max of left to right\n        minHeap.push(maxHeap.top());\n        maxHeap.pop();\n        \n        // If right becomes larger, move min back to left\n        if (minHeap.size() > maxHeap.size()) {\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n        }\n    }\n    \n    double findMedian() {\n        if (maxHeap.size() > minHeap.size()) {\n            return maxHeap.top();\n        } else {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        }\n    }\n};\n\n// Example: addNum sequence: 1, 2, 3\n// addNum(1): left=[1], right=[]\n// addNum(2): left=[1], right=[2]\n// addNum(3): left=[2,1], right=[3]\n// findMedian: left.size > right.size → return 2",
        "java": "class MedianFinder {\n    private PriorityQueue<Integer> maxHeap; // Left half\n    private PriorityQueue<Integer> minHeap; // Right half\n    \n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        minHeap = new PriorityQueue<>();\n    }\n    \n    public void addNum(int num) {\n        maxHeap.offer(num);\n        minHeap.offer(maxHeap.poll());\n        \n        if (minHeap.size() > maxHeap.size()) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n    \n    public double findMedian() {\n        if (maxHeap.size() > minHeap.size()) {\n            return maxHeap.peek();\n        } else {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n    }\n}",
        "python": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.left = []   # Max heap (negate values)\n        self.right = []  # Min heap\n    \n    def addNum(self, num: int) -> None:\n        # Add to max heap (left)\n        heapq.heappush(self.left, -num)\n        \n        # Balance: move max of left to right\n        heapq.heappush(self.right, -heapq.heappop(self.left))\n        \n        # If right larger, move back\n        if len(self.right) > len(self.left):\n            heapq.heappush(self.left, -heapq.heappop(self.right))\n    \n    def findMedian(self) -> float:\n        if len(self.left) > len(self.right):\n            return -self.left[0]\n        else:\n            return (-self.left[0] + self.right[0]) / 2",
        "javascript": "var MedianFinder = function() {\n    this.maxHeap = new MaxPriorityQueue(); // Left\n    this.minHeap = new MinPriorityQueue(); // Right\n};\n\nMedianFinder.prototype.addNum = function(num) {\n    this.maxHeap.enqueue(num);\n    this.minHeap.enqueue(this.maxHeap.dequeue().element);\n    \n    if (this.minHeap.size() > this.maxHeap.size()) {\n        this.maxHeap.enqueue(this.minHeap.dequeue().element);\n    }\n};\n\nMedianFinder.prototype.findMedian = function() {\n    if (this.maxHeap.size() > this.minHeap.size()) {\n        return this.maxHeap.front().element;\n    } else {\n        return (this.maxHeap.front().element + this.minHeap.front().element) / 2;\n    }\n};"
      }
    }
  ],
  "commonMistakes": [
    "Using two min heaps or two max heaps (won't work!)",
    "Not balancing heap sizes correctly",
    "Forgetting to negate values for max heap in Python",
    "Checking wrong heap for median when sizes equal",
    "Not handling even vs odd total count correctly",
    "Adding to wrong heap first (should always add to max heap)"
  ],
  "hints": [
    "Median splits numbers into two equal halves",
    "Max heap for left half, min heap for right half",
    "Keep heaps balanced: sizes differ by at most 1",
    "Top of max heap = largest in left half",
    "Top of min heap = smallest in right half",
    "Always add to max heap first, then balance"
  ],
  "followUp": [
    "What if all numbers from [0, 100]? (Use counting array instead)",
    "What if 99% of queries are findMedian? (Two heaps still optimal)",
    "Can we handle remove operations? (Use TreeMap/multiset)",
    "What about median of last k elements? (Sliding window + two heaps)",
    "Distributed stream? (Approximate with sampling)"
  ],
  "companies": ["Google", "Amazon", "Microsoft", "Facebook", "Apple", "Bloomberg", "Uber"],
  "tags": ["heap", "priority-queue", "two-heaps", "design", "data-stream"],
  "relatedProblems": [
    "Sliding Window Median",
    "Find Median from Data Stream II",
    "IPO",
    "Find K Pairs with Smallest Sums"
  ]
}
