{
  "questionId": "LC-767",
  "questionSlug": "reorganize-string",
  "title": "Reorganize String",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/reorganize-string/",
    "videos": [
      {
        "title": "Reorganize String - Max Heap Solution",
        "url": "https://www.youtube.com/watch?v=2g_b1aYTHeg",
        "channel": "NeetCode",
        "duration": "11:30",
        "language": "English"
      },
      {
        "title": "Reorganize String Explained",
        "url": "https://www.youtube.com/watch?v=zaM_GLLvysw",
        "channel": "Nick White",
        "duration": "9:45",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Reorganize String - Official Solution",
        "url": "https://leetcode.com/problems/reorganize-string/solution/",
        "source": "LeetCode"
      },
      {
        "title": "Reorganize String - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/rearrange-characters-string-no-two-adjacent/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/reorganize-string/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Rearrange to avoid adjacent duplicates? Use max heap - always pick most frequent available!",
  "approaches": [
    {
      "name": "Max Heap - Greedy",
      "order": 1,
      "intuition": "Greedily place most frequent char, then second most frequent. Keep alternating to avoid adjacency!",
      "approach": "Use max heap to always pick most frequent available character.",
      "steps": [
        "Count character frequencies",
        "Check if possible: if maxFreq > (n+1)/2, impossible!",
        "Add all (freq, char) to max heap",
        "Build result by alternating:",
        "  Extract most frequent char",
        "  Add to result",
        "  Extract second most frequent",
        "  Add to result",
        "  Decrease frequencies, add back if > 0",
        "  Repeat until heap empty",
        "If one char remains at end, add it"
      ],
      "complexity": {
        "time": "O(n log k)",
        "space": "O(k)",
        "timeExplanation": "n operations, each heap operation O(log k) for k unique chars",
        "spaceExplanation": "Heap stores k unique characters"
      },
      "code": {
        "cpp": "string reorganizeString(string s) {\n    // Count frequencies\n    unordered_map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n    \n    // Check if possible\n    int maxFreq = 0;\n    for (auto& p : freq) {\n        maxFreq = max(maxFreq, p.second);\n    }\n    if (maxFreq > (s.length() + 1) / 2) {\n        return \"\"; // Impossible\n    }\n    \n    // Max heap: (frequency, char)\n    priority_queue<pair<int, char>> maxHeap;\n    for (auto& p : freq) {\n        maxHeap.push({p.second, p.first});\n    }\n    \n    string result;\n    \n    while (maxHeap.size() >= 2) {\n        // Extract two most frequent\n        auto first = maxHeap.top(); maxHeap.pop();\n        auto second = maxHeap.top(); maxHeap.pop();\n        \n        // Add to result\n        result += first.second;\n        result += second.second;\n        \n        // Decrease frequencies and add back\n        if (--first.first > 0) maxHeap.push(first);\n        if (--second.first > 0) maxHeap.push(second);\n    }\n    \n    // If one char remains\n    if (!maxHeap.empty()) {\n        result += maxHeap.top().second;\n    }\n    \n    return result;\n}\n\n// Example: s = \"aab\"\n// freq = {a:2, b:1}\n// maxFreq = 2, len = 3, (3+1)/2 = 2 ✓ possible\n// Heap: [(2,'a'), (1,'b')]\n// Extract a,b → result = \"ab\", heap = [(1,'a')]\n// Add remaining 'a' → result = \"aba\"",
        "java": "public String reorganizeString(String s) {\n    Map<Character, Integer> freq = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        freq.put(c, freq.getOrDefault(c, 0) + 1);\n    }\n    \n    int maxFreq = Collections.max(freq.values());\n    if (maxFreq > (s.length() + 1) / 2) {\n        return \"\";\n    }\n    \n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>(\n        (a, b) -> b[0] - a[0]\n    );\n    \n    for (Map.Entry<Character, Integer> entry : freq.entrySet()) {\n        maxHeap.offer(new int[]{entry.getValue(), entry.getKey()});\n    }\n    \n    StringBuilder result = new StringBuilder();\n    \n    while (maxHeap.size() >= 2) {\n        int[] first = maxHeap.poll();\n        int[] second = maxHeap.poll();\n        \n        result.append((char)first[1]);\n        result.append((char)second[1]);\n        \n        if (--first[0] > 0) maxHeap.offer(first);\n        if (--second[0] > 0) maxHeap.offer(second);\n    }\n    \n    if (!maxHeap.isEmpty()) {\n        result.append((char)maxHeap.poll()[1]);\n    }\n    \n    return result.toString();\n}",
        "python": "import heapq\nfrom collections import Counter\n\ndef reorganizeString(s: str) -> str:\n    # Count frequencies\n    freq = Counter(s)\n    \n    # Check if possible\n    max_freq = max(freq.values())\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Max heap (negate for max heap)\n    max_heap = [(-count, char) for char, count in freq.items()]\n    heapq.heapify(max_heap)\n    \n    result = []\n    \n    while len(max_heap) >= 2:\n        # Extract two most frequent\n        count1, char1 = heapq.heappop(max_heap)\n        count2, char2 = heapq.heappop(max_heap)\n        \n        # Add to result\n        result.append(char1)\n        result.append(char2)\n        \n        # Decrease and add back if needed\n        if count1 + 1 < 0:  # Still has chars (was negative)\n            heapq.heappush(max_heap, (count1 + 1, char1))\n        if count2 + 1 < 0:\n            heapq.heappush(max_heap, (count2 + 1, char2))\n    \n    # If one char remains\n    if max_heap:\n        result.append(max_heap[0][1])\n    \n    return ''.join(result)",
        "javascript": "var reorganizeString = function(s) {\n    const freq = new Map();\n    for (const c of s) {\n        freq.set(c, (freq.get(c) || 0) + 1);\n    }\n    \n    const maxFreq = Math.max(...freq.values());\n    if (maxFreq > Math.ceil(s.length / 2)) {\n        return \"\";\n    }\n    \n    const maxHeap = new MaxPriorityQueue({\n        priority: (x) => x[0]\n    });\n    \n    for (const [char, count] of freq.entries()) {\n        maxHeap.enqueue([count, char]);\n    }\n    \n    let result = '';\n    \n    while (maxHeap.size() >= 2) {\n        const [count1, char1] = maxHeap.dequeue().element;\n        const [count2, char2] = maxHeap.dequeue().element;\n        \n        result += char1 + char2;\n        \n        if (count1 - 1 > 0) maxHeap.enqueue([count1 - 1, char1]);\n        if (count2 - 1 > 0) maxHeap.enqueue([count2 - 1, char2]);\n    }\n    \n    if (maxHeap.size() > 0) {\n        result += maxHeap.dequeue().element[1];\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Even-Odd Placement",
      "order": 2,
      "intuition": "Place most frequent char at even indices first, then others. Avoids adjacency naturally!",
      "approach": "Sort by frequency, place at even indices first, then odd indices.",
      "steps": [
        "Count character frequencies",
        "Check if possible: maxFreq > (n+1)/2",
        "Sort characters by frequency descending",
        "Initialize result array",
        "Start at index 0 (even indices)",
        "For each character (most frequent first):",
        "  Place all occurrences at current index",
        "  Move to next even index",
        "  If reached end, wrap to index 1 (odd indices)",
        "Convert array to string",
        "Even-odd placement ensures no adjacency!"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Count frequencies O(n), place chars O(n), only 26 letters",
        "spaceExplanation": "Result array O(n), frequency map O(1) for 26 letters"
      },
      "code": {
        "cpp": "string reorganizeString(string s) {\n    int n = s.length();\n    \n    // Count frequencies\n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n    \n    // Check if possible\n    int maxFreq = *max_element(freq.begin(), freq.end());\n    if (maxFreq > (n + 1) / 2) {\n        return \"\";\n    }\n    \n    // Sort indices by frequency\n    vector<int> indices(26);\n    iota(indices.begin(), indices.end(), 0);\n    sort(indices.begin(), indices.end(), [&](int a, int b) {\n        return freq[a] > freq[b];\n    });\n    \n    // Place characters\n    string result(n, ' ');\n    int idx = 0;\n    \n    for (int i : indices) {\n        char c = 'a' + i;\n        \n        for (int count = freq[i]; count > 0; count--) {\n            result[idx] = c;\n            idx += 2;\n            \n            // Wrap to odd indices if reached end\n            if (idx >= n) {\n                idx = 1;\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example: s = \"aaab\"\n// freq: a=3, b=1\n// Place a at 0,2,4 → but n=4, so 0,2, wrap to 1\n// Place b at 3\n// Result: \"abaa\" WRONG! Need to check possibility first\n\n// Correct: s = \"aab\"\n// freq: a=2, b=1\n// Place a at 0,2 → result = \"a_a\"\n// Place b at 1 → result = \"aba\"",
        "java": "public String reorganizeString(String s) {\n    int n = s.length();\n    int[] freq = new int[26];\n    \n    for (char c : s.toCharArray()) {\n        freq[c - 'a']++;\n    }\n    \n    int maxFreq = 0;\n    for (int f : freq) {\n        maxFreq = Math.max(maxFreq, f);\n    }\n    \n    if (maxFreq > (n + 1) / 2) {\n        return \"\";\n    }\n    \n    Integer[] indices = new Integer[26];\n    for (int i = 0; i < 26; i++) {\n        indices[i] = i;\n    }\n    \n    Arrays.sort(indices, (a, b) -> freq[b] - freq[a]);\n    \n    char[] result = new char[n];\n    int idx = 0;\n    \n    for (int i : indices) {\n        char c = (char)('a' + i);\n        \n        for (int count = freq[i]; count > 0; count--) {\n            result[idx] = c;\n            idx += 2;\n            \n            if (idx >= n) {\n                idx = 1;\n            }\n        }\n    }\n    \n    return new String(result);\n}",
        "python": "def reorganizeString(s: str) -> str:\n    from collections import Counter\n    \n    n = len(s)\n    freq = Counter(s)\n    \n    # Check if possible\n    max_freq = max(freq.values())\n    if max_freq > (n + 1) // 2:\n        return \"\"\n    \n    # Sort by frequency\n    sorted_chars = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    \n    # Place characters\n    result = [''] * n\n    idx = 0\n    \n    for char, count in sorted_chars:\n        for _ in range(count):\n            result[idx] = char\n            idx += 2\n            \n            # Wrap to odd indices\n            if idx >= n:\n                idx = 1\n    \n    return ''.join(result)",
        "javascript": "var reorganizeString = function(s) {\n    const n = s.length;\n    const freq = new Array(26).fill(0);\n    \n    for (const c of s) {\n        freq[c.charCodeAt(0) - 97]++;\n    }\n    \n    const maxFreq = Math.max(...freq);\n    if (maxFreq > Math.ceil(n / 2)) {\n        return \"\";\n    }\n    \n    const indices = Array.from({length: 26}, (_, i) => i);\n    indices.sort((a, b) => freq[b] - freq[a]);\n    \n    const result = new Array(n);\n    let idx = 0;\n    \n    for (const i of indices) {\n        const c = String.fromCharCode(97 + i);\n        \n        for (let count = freq[i]; count > 0; count--) {\n            result[idx] = c;\n            idx += 2;\n            \n            if (idx >= n) {\n                idx = 1;\n            }\n        }\n    }\n    \n    return result.join('');\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not checking if reorganization is possible (maxFreq > (n+1)/2)",
    "Using min heap instead of max heap (less efficient)",
    "Forgetting to handle last remaining character",
    "Not alternating two characters at a time in heap approach",
    "Off-by-one in possibility check: should be (n+1)/2, not n/2",
    "Even-odd approach: not wrapping to odd indices correctly"
  ],
  "hints": [
    "If maxFreq > (n+1)/2, impossible to reorganize",
    "Always pick most frequent char to place next",
    "Alternate between two most frequent chars",
    "Even-odd placement naturally avoids adjacency",
    "Last char (if any) is safe to add - it's least frequent"
  ],
  "followUp": [
    "What if k distance apart instead of 1? (Similar heap approach with cooling)",
    "Return all possible reorganizations? (Backtracking needed)",
    "What if some chars can be adjacent? (Add constraints to heap)",
    "Minimize lexicographical order? (Use min heap when frequencies equal)",
    "What if string is very long? (Both approaches work, heap is more general)"
  ],
  "companies": ["Amazon", "Google", "Facebook", "Microsoft", "Bloomberg"],
  "tags": ["heap", "priority-queue", "greedy", "string", "sorting", "counting"],
  "relatedProblems": [
    "Task Scheduler",
    "Rearrange String k Distance Apart",
    "Sort Characters By Frequency",
    "Longest Happy String"
  ]
}
