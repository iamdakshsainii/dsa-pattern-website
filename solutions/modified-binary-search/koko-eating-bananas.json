{
  "questionId": "694d4a3a98494915f3bc8ef2",
  "questionSlug": "koko-eating-bananas",
  "title": "Koko Eating Bananas",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/koko-eating-bananas/",
    "videos": [
      {
        "title": "Koko Eating Bananas - Binary Search",
        "url": "https://www.youtube.com/watch?v=U2SozAs9RzA",
        "channel": "NeetCode",
        "duration": "9:50",
        "language": "English"
      },
      {
        "title": "Binary Search on Speed - Koko Problem",
        "url": "https://www.youtube.com/watch?v=qyfekrNni90",
        "channel": "take U forward",
        "duration": "20:15",
        "language": "English"
      },
      {
        "title": "Koko Eating Bananas Explained",
        "url": "https://www.youtube.com/watch?v=PSJdBKFbUdI",
        "channel": "Kevin Naughton Jr.",
        "duration": "13:40",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Koko Eating Bananas Solution",
        "url": "https://leetcode.com/problems/koko-eating-bananas/solutions/",
        "source": "LeetCode"
      },
      {
        "title": "Binary Search on Answer Pattern",
        "url": "https://www.geeksforgeeks.org/binary-search-on-answer/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Minimization with Binary Search",
        "url": "https://algo.monster/problems/binary_search_on_answer",
        "source": "AlgoMonster"
      }
    ],
    "practice": [
      {
        "title": "Capacity To Ship Packages",
        "url": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/",
        "platform": "LeetCode"
      },
      {
        "title": "Minimum Number of Days to Make M Bouquets",
        "url": "https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/",
        "platform": "LeetCode"
      },
      {
        "title": "Split Array Largest Sum",
        "url": "https://leetcode.com/problems/split-array-largest-sum/",
        "platform": "LeetCode"
      },
      {
        "title": "Minimum Speed to Arrive on Time",
        "url": "https://leetcode.com/problems/minimum-speed-to-arrive-on-time/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Koko Eating Bananas when minimizing rate/speed with time constraint. Key indicators: minimize speed/rate, time limit, feasibility check, binary search on answer, ceiling division for time calculation.",
  "approaches": [
    {
      "name": "Binary Search on Speed (Optimal)",
      "order": 1,
      "intuition": "Search space is eating speed from 1 to max pile. Use binary search on speed. For each speed k, calculate hours needed: sum of ceiling(pile[i]/k). If hours <= h, speed k works, try slower (search left). Else try faster.",
      "approach": "Binary search on speed range [1, max(piles)]. For each mid speed, calculate total hours using ceiling division. If feasible, minimize speed by searching left. Else search right for faster speed.",
      "steps": [
        "Find maxPile = max(piles)",
        "Binary search on speed [1, maxPile]:",
        "  - Initialize left = 1, right = maxPile",
        "  - While left <= right:",
        "    * mid = left + (right - left) / 2",
        "    * Calculate hours needed at speed mid:",
        "      - For each pile: hours += ceiling(pile / mid)",
        "      - Use: ceiling(a/b) = (a + b - 1) / b",
        "    * If hours <= h:",
        "      - Update result = mid",
        "      - Try slower: right = mid - 1",
        "    * Else: left = mid + 1 (need faster)",
        "Return result"
      ],
      "complexity": {
        "time": "O(n * log(max))",
        "space": "O(1)",
        "timeExplanation": "Binary search on speed: log(maxPile) iterations. Each iteration processes n piles. Total: O(n * log(max)).",
        "spaceExplanation": "Only variables for calculation. Constant space: O(1)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int left = 1;\n        int right = *max_element(piles.begin(), piles.end());\n        int result = right;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (canFinish(piles, mid, h)) {\n                result = mid;\n                right = mid - 1;  // Try slower speed\n            } else {\n                left = mid + 1;  // Need faster speed\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool canFinish(vector<int>& piles, int speed, int h) {\n        long long hours = 0;\n        \n        for (int pile : piles) {\n            // Ceiling division: (pile + speed - 1) / speed\n            hours += (pile + speed - 1) / speed;\n            if (hours > h) return false;  // Early termination\n        }\n        \n        return hours <= h;\n    }\n};",
        "java": "class Solution {\n    public int minEatingSpeed(int[] piles, int h) {\n        int left = 1;\n        int right = 0;\n        for (int pile : piles) {\n            right = Math.max(right, pile);\n        }\n        \n        int result = right;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (canFinish(piles, mid, h)) {\n                result = mid;\n                right = mid - 1;  // Try slower speed\n            } else {\n                left = mid + 1;  // Need faster speed\n            }\n        }\n        \n        return result;\n    }\n    \n    private boolean canFinish(int[] piles, int speed, int h) {\n        long hours = 0;\n        \n        for (int pile : piles) {\n            // Ceiling division: (pile + speed - 1) / speed\n            hours += (pile + speed - 1) / speed;\n            if (hours > h) return false;  // Early termination\n        }\n        \n        return hours <= h;\n    }\n}",
        "python": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        left = 1\n        right = max(piles)\n        result = right\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if self.canFinish(piles, mid, h):\n                result = mid\n                right = mid - 1  # Try slower speed\n            else:\n                left = mid + 1  # Need faster speed\n        \n        return result\n    \n    def canFinish(self, piles: List[int], speed: int, h: int) -> bool:\n        import math\n        hours = 0\n        \n        for pile in piles:\n            hours += math.ceil(pile / speed)\n            if hours > h:\n                return False  # Early termination\n        \n        return hours <= h",
        "javascript": "function minEatingSpeed(piles, h) {\n    let left = 1;\n    let right = Math.max(...piles);\n    let result = right;\n    \n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (canFinish(piles, mid, h)) {\n            result = mid;\n            right = mid - 1;  // Try slower speed\n        } else {\n            left = mid + 1;  // Need faster speed\n        }\n    }\n    \n    return result;\n}\n\nfunction canFinish(piles, speed, h) {\n    let hours = 0;\n    \n    for (const pile of piles) {\n        hours += Math.ceil(pile / speed);\n        if (hours > h) return false;  // Early termination\n    }\n    \n    return hours <= h;\n}"
      }
    },
    {
      "name": "Linear Search on Speed (Brute Force)",
      "order": 2,
      "intuition": "Try every speed from 1 to max pile. First speed that works within h hours is minimum. Simple but inefficient for large ranges.",
      "approach": "Iterate speeds from 1 upward. For each speed, calculate hours needed. Return first speed where hours <= h.",
      "steps": [
        "Find maxPile = max(piles)",
        "For speed = 1 to maxPile:",
        "  - Calculate hours needed at this speed",
        "  - If hours <= h: return speed",
        "Return maxPile (always works)"
      ],
      "complexity": {
        "time": "O(n * max)",
        "space": "O(1)",
        "timeExplanation": "Try up to max speeds. For each speed check n piles. Total: O(n * max).",
        "spaceExplanation": "Only loop variables used. Constant space: O(1)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int maxPile = *max_element(piles.begin(), piles.end());\n        \n        for (int speed = 1; speed <= maxPile; speed++) {\n            long long hours = 0;\n            \n            for (int pile : piles) {\n                hours += (pile + speed - 1) / speed;\n            }\n            \n            if (hours <= h) {\n                return speed;\n            }\n        }\n        \n        return maxPile;\n    }\n};",
        "java": "class Solution {\n    public int minEatingSpeed(int[] piles, int h) {\n        int maxPile = 0;\n        for (int pile : piles) {\n            maxPile = Math.max(maxPile, pile);\n        }\n        \n        for (int speed = 1; speed <= maxPile; speed++) {\n            long hours = 0;\n            \n            for (int pile : piles) {\n                hours += (pile + speed - 1) / speed;\n            }\n            \n            if (hours <= h) {\n                return speed;\n            }\n        }\n        \n        return maxPile;\n    }\n}",
        "python": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        import math\n        max_pile = max(piles)\n        \n        for speed in range(1, max_pile + 1):\n            hours = sum(math.ceil(pile / speed) for pile in piles)\n            \n            if hours <= h:\n                return speed\n        \n        return max_pile",
        "javascript": "function minEatingSpeed(piles, h) {\n    const maxPile = Math.max(...piles);\n    \n    for (let speed = 1; speed <= maxPile; speed++) {\n        let hours = 0;\n        \n        for (const pile of piles) {\n            hours += Math.ceil(pile / speed);\n        }\n        \n        if (hours <= h) {\n            return speed;\n        }\n    }\n    \n    return maxPile;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Using regular division instead of ceiling division",
    "Starting binary search from 0 (should be 1)",
    "Integer overflow when calculating hours",
    "Not handling edge case where h = piles.length",
    "Wrong search direction (should minimize when feasible)",
    "Not using early termination in canFinish",
    "Forgetting that Koko eats one pile per hour maximum",
    "Incorrect ceiling division formula"
  ],
  "hints": [
    "Binary search on eating speed, not on piles",
    "Search space is [1, max(piles)]",
    "Use ceiling division: hours += (pile + speed - 1) / speed",
    "Or in Python: math.ceil(pile / speed)",
    "If speed k works, try slower speed (search left)",
    "Early termination: if hours > h, return false immediately",
    "Time complexity: O(n * log(max))",
    "Minimum speed is 1, maximum is max(piles)"
  ],
  "followUp": [
    "What if Koko can eat multiple piles per hour?",
    "How to maximize leftover bananas instead?",
    "What if piles arrive dynamically?",
    "Can you handle fractional eating speeds?",
    "What about minimizing wasted capacity?",
    "How to optimize for very large pile values?",
    "What if different piles have different priorities?",
    "Can you solve with constraints on speed changes?"
  ],
  "companies": [
    "Google",
    "Facebook",
    "Amazon",
    "Microsoft",
    "Apple",
    "ByteDance",
    "Bloomberg",
    "Oracle"
  ],
  "tags": [
    "Binary Search",
    "Array",
    "Binary Search on Answer",
    "Math"
  ],
  "relatedProblems": [
    "Capacity To Ship Packages",
    "Minimum Number of Days to Make M Bouquets",
    "Split Array Largest Sum",
    "Minimum Speed to Arrive on Time",
    "Magnetic Force Between Two Balls",
    "Minimize Maximum of Array",
    "Minimum Time to Complete Trips",
    "Maximum Candies Allocated to K Children"
  ]
}