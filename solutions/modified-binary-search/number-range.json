{
  "questionId": "694d4a3a98494915f3bc8ee9",
  "questionSlug": "number-range",
  "title": "Number Range",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
    "videos": [
      {
        "title": "Find First and Last Position - Binary Search",
        "url": "https://www.youtube.com/watch?v=4sQL7R5ySUU",
        "channel": "NeetCode",
        "duration": "10:25",
        "language": "English"
      },
      {
        "title": "First and Last Occurrence Binary Search",
        "url": "https://www.youtube.com/watch?v=zr_AoTxzn0Y",
        "channel": "take U forward",
        "duration": "19:40",
        "language": "English"
      },
      {
        "title": "Find Range of Target in Sorted Array",
        "url": "https://www.youtube.com/watch?v=bU-q1OJ0KWw",
        "channel": "Kevin Naughton Jr.",
        "duration": "12:50",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Find First and Last Position Solution",
        "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/",
        "source": "LeetCode"
      },
      {
        "title": "Binary Search Boundaries",
        "url": "https://www.geeksforgeeks.org/find-first-and-last-positions-of-an-element-in-a-sorted-array/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Finding Boundaries with Binary Search",
        "url": "https://algo.monster/problems/binary_search_boundary",
        "source": "AlgoMonster"
      }
    ],
    "practice": [
      {
        "title": "First Bad Version",
        "url": "https://leetcode.com/problems/first-bad-version/",
        "platform": "LeetCode"
      },
      {
        "title": "Find K Closest Elements",
        "url": "https://leetcode.com/problems/find-k-closest-elements/",
        "platform": "LeetCode"
      },
      {
        "title": "Count of Smaller Numbers After Self",
        "url": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/",
        "platform": "LeetCode"
      },
      {
        "title": "Search for a Range",
        "url": "https://www.geeksforgeeks.org/find-first-and-last-positions-of-an-element-in-a-sorted-array/",
        "platform": "GeeksforGeeks"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Number Range when finding first and last occurrence of target. Key indicators: sorted array with duplicates, find range, start and end position, count occurrences, binary search boundaries.",
  "approaches": [
    {
      "name": "Two Binary Searches (Optimal)",
      "order": 1,
      "intuition": "Use binary search twice: once for leftmost position, once for rightmost. For leftmost, when target found, continue searching left. For rightmost, continue searching right. Both run in O(log n).",
      "approach": "Implement findFirst and findLast separately. findFirst searches left after finding target. findLast searches right. Combine results into range.",
      "steps": [
        "Create findFirst function:",
        "  - Binary search tracking leftmost occurrence",
        "  - When arr[mid] == target: result = mid, search left",
        "  - When arr[mid] < target: search right",
        "  - When arr[mid] > target: search left",
        "Create findLast function:",
        "  - Binary search tracking rightmost occurrence",
        "  - When arr[mid] == target: result = mid, search right",
        "  - When arr[mid] < target: search right",
        "  - When arr[mid] > target: search left",
        "Return [findFirst(arr, target), findLast(arr, target)]",
        "If target not found, return [-1, -1]"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Two binary searches, each O(log n). Total: O(log n) + O(log n) = O(log n).",
        "spaceExplanation": "Only variables for pointers. Constant space: O(1)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        return {findFirst(nums, target), findLast(nums, target)};\n    }\n    \nprivate:\n    int findFirst(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        int result = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                result = mid;\n                right = mid - 1;  // Continue searching left\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    }\n    \n    int findLast(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        int result = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                result = mid;\n                left = mid + 1;  // Continue searching right\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        return new int[] {findFirst(nums, target), findLast(nums, target)};\n    }\n    \n    private int findFirst(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        int result = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                result = mid;\n                right = mid - 1;  // Continue searching left\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    }\n    \n    private int findLast(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        int result = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                result = mid;\n                left = mid + 1;  // Continue searching right\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        def findFirst(nums, target):\n            left, right = 0, len(nums) - 1\n            result = -1\n            \n            while left <= right:\n                mid = left + (right - left) // 2\n                \n                if nums[mid] == target:\n                    result = mid\n                    right = mid - 1  # Continue searching left\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            \n            return result\n        \n        def findLast(nums, target):\n            left, right = 0, len(nums) - 1\n            result = -1\n            \n            while left <= right:\n                mid = left + (right - left) // 2\n                \n                if nums[mid] == target:\n                    result = mid\n                    left = mid + 1  # Continue searching right\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            \n            return result\n        \n        return [findFirst(nums, target), findLast(nums, target)]",
        "javascript": "function searchRange(nums, target) {\n    const findFirst = (nums, target) => {\n        let left = 0, right = nums.length - 1;\n        let result = -1;\n        \n        while (left <= right) {\n            const mid = left + Math.floor((right - left) / 2);\n            \n            if (nums[mid] === target) {\n                result = mid;\n                right = mid - 1;  // Continue searching left\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    };\n    \n    const findLast = (nums, target) => {\n        let left = 0, right = nums.length - 1;\n        let result = -1;\n        \n        while (left <= right) {\n            const mid = left + Math.floor((right - left) / 2);\n            \n            if (nums[mid] === target) {\n                result = mid;\n                left = mid + 1;  // Continue searching right\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    };\n    \n    return [findFirst(nums, target), findLast(nums, target)];\n}"
      }
    },
    {
      "name": "Find Then Expand (Alternative)",
      "order": 2,
      "intuition": "First find any occurrence using standard binary search. Then expand left and right from found position to find boundaries. Worst case O(n) if all elements are target.",
      "approach": "Binary search to find target. Then expand linearly left and right to find first and last positions.",
      "steps": [
        "Use binary search to find any occurrence of target",
        "If target not found: return [-1, -1]",
        "From found index, expand left:",
        "  - While left >= 0 and nums[left] == target: left--",
        "From found index, expand right:",
        "  - While right < n and nums[right] == target: right++",
        "Return [left + 1, right - 1]"
      ],
      "complexity": {
        "time": "O(log n + k)",
        "space": "O(1)",
        "timeExplanation": "Binary search: O(log n). Expansion: O(k) where k is count of target. Worst case O(n).",
        "spaceExplanation": "Only variables used. Constant space: O(1)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        if (nums.empty()) return {-1, -1};\n        \n        // Find any occurrence\n        int index = binarySearch(nums, target);\n        if (index == -1) return {-1, -1};\n        \n        // Expand left\n        int left = index;\n        while (left > 0 && nums[left - 1] == target) {\n            left--;\n        }\n        \n        // Expand right\n        int right = index;\n        while (right < nums.size() - 1 && nums[right + 1] == target) {\n            right++;\n        }\n        \n        return {left, right};\n    }\n    \nprivate:\n    int binarySearch(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) return mid;\n            else if (nums[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        if (nums.length == 0) return new int[] {-1, -1};\n        \n        // Find any occurrence\n        int index = binarySearch(nums, target);\n        if (index == -1) return new int[] {-1, -1};\n        \n        // Expand left\n        int left = index;\n        while (left > 0 && nums[left - 1] == target) {\n            left--;\n        }\n        \n        // Expand right\n        int right = index;\n        while (right < nums.length - 1 && nums[right + 1] == target) {\n            right++;\n        }\n        \n        return new int[] {left, right};\n    }\n    \n    private int binarySearch(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) return mid;\n            else if (nums[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        if not nums:\n            return [-1, -1]\n        \n        # Find any occurrence\n        index = self.binarySearch(nums, target)\n        if index == -1:\n            return [-1, -1]\n        \n        # Expand left\n        left = index\n        while left > 0 and nums[left - 1] == target:\n            left -= 1\n        \n        # Expand right\n        right = index\n        while right < len(nums) - 1 and nums[right + 1] == target:\n            right += 1\n        \n        return [left, right]\n    \n    def binarySearch(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1",
        "javascript": "function searchRange(nums, target) {\n    if (nums.length === 0) return [-1, -1];\n    \n    // Find any occurrence\n    const index = binarySearch(nums, target);\n    if (index === -1) return [-1, -1];\n    \n    // Expand left\n    let left = index;\n    while (left > 0 && nums[left - 1] === target) {\n        left--;\n    }\n    \n    // Expand right\n    let right = index;\n    while (right < nums.length - 1 && nums[right + 1] === target) {\n        right++;\n    }\n    \n    return [left, right];\n}\n\nfunction binarySearch(nums, target) {\n    let left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (nums[mid] === target) return mid;\n        else if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    \n    return -1;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Stopping after first occurrence (not finding boundaries)",
    "Using single binary search for both boundaries",
    "Not continuing search after finding target",
    "Incorrect direction when searching for first/last",
    "Not handling empty array case",
    "Returning wrong indices when target not found",
    "Off-by-one errors in boundary calculation",
    "Not updating result when target found"
  ],
  "hints": [
    "Need two separate binary searches for optimal solution",
    "For first position: continue searching left after finding",
    "For last position: continue searching right after finding",
    "Both searches run in O(log n) time",
    "Track best result found so far in each search",
    "Return [-1, -1] if target doesn't exist",
    "Count of occurrences = last - first + 1",
    "Can reuse same binary search logic with small modifications"
  ],
  "followUp": [
    "What if array is unsorted?",
    "How to count occurrences without finding range?",
    "What about finding range in rotated array?",
    "Can you optimize for single occurrence case?",
    "How to handle very large arrays (distributed)?",
    "What if duplicates are very frequent?",
    "How to find k-th occurrence?",
    "What about 2D sorted matrix?"
  ],
  "companies": [
    "Facebook",
    "Amazon",
    "Google",
    "Microsoft",
    "Apple",
    "LinkedIn",
    "Bloomberg",
    "Oracle"
  ],
  "tags": [
    "Binary Search",
    "Array",
    "Sorted Array",
    "Duplicates"
  ],
  "relatedProblems": [
    "First Bad Version",
    "Find K Closest Elements",
    "Count of Smaller Numbers After Self",
    "Ceiling Number",
    "Next Letter",
    "Minimum Difference Element",
    "Search in Rotated Sorted Array",
    "Find Peak Element"
  ]
}