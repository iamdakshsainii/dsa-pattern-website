{
  "questionId": "694d4a3a98494915f3bc8ee6",
  "questionSlug": "order-agnostic-binary-search",
  "resources": {
    "leetcode": "https://www.geeksforgeeks.org/order-agnostic-binary-search/",
    "videos": [
      {
        "title": "Order Agnostic Binary Search",
        "url": "https://www.youtube.com/watch?v=W9QJ8HaRvJQ",
        "channel": "Aditya Verma",
        "duration": "10:30",
        "language": "English"
      },
      {
        "title": "Binary Search on Unknown Order Array",
        "url": "https://www.youtube.com/watch?v=5ypBMehn7k8",
        "channel": "TECH DOSE",
        "duration": "12:45",
        "language": "English"
      },
      {
        "title": "Ascending or Descending Binary Search",
        "url": "https://www.youtube.com/watch?v=nz1BSwf-YH0",
        "channel": "Code with Alisha",
        "duration": "14:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Order Agnostic Binary Search",
        "url": "https://www.geeksforgeeks.org/order-agnostic-binary-search/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Binary Search Variations",
        "url": "https://algo.monster/problems/binary_search_intro",
        "source": "AlgoMonster"
      },
      {
        "title": "Flexible Binary Search",
        "url": "https://www.educative.io/answers/what-is-order-agnostic-binary-search",
        "source": "Educative"
      }
    ],
    "practice": [
      {
        "title": "Binary Search",
        "url": "https://leetcode.com/problems/binary-search/",
        "platform": "LeetCode"
      },
      {
        "title": "Search Insert Position",
        "url": "https://leetcode.com/problems/search-insert-position/",
        "platform": "LeetCode"
      },
      {
        "title": "Find Smallest Letter Greater Than Target",
        "url": "https://leetcode.com/problems/find-smallest-letter-greater-than-target/",
        "platform": "LeetCode"
      },
      {
        "title": "First Bad Version",
        "url": "https://leetcode.com/problems/first-bad-version/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Order Agnostic Binary Search when array is sorted but order unknown. Key indicators: sorted array (ascending or descending), don't know order, search target, flexible binary search, single pass solution.",
  "approaches": [
    {
      "name": "Detect Order Then Binary Search (Optimal)",
      "order": 1,
      "intuition": "First determine if array is ascending or descending by comparing first and last elements. Then apply standard binary search with appropriate comparisons based on order. Single O(log n) search after O(1) order detection.",
      "approach": "Check arr[0] vs arr[n-1] to determine order. Use binary search with conditionals adjusted for detected order. One unified logic handles both cases.",
      "steps": [
        "Determine order: isAscending = arr[0] < arr[n-1]",
        "Initialize left = 0, right = n-1",
        "While left <= right:",
        "  - mid = left + (right - left) / 2",
        "  - If arr[mid] == target: return mid",
        "  - If isAscending:",
        "    * If arr[mid] < target: left = mid + 1",
        "    * Else: right = mid - 1",
        "  - Else (descending):",
        "    * If arr[mid] > target: left = mid + 1",
        "    * Else: right = mid - 1",
        "Return -1 (not found)"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Order detection: O(1). Binary search divides space in half: log n iterations. Total: O(log n).",
        "spaceExplanation": "Only variables for pointers and order flag. Constant space: O(1)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& arr, int target) {\n        int n = arr.size();\n        if (n == 0) return -1;\n        \n        // Determine order\n        bool isAscending = arr[0] < arr[n - 1];\n        \n        int left = 0, right = n - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            }\n            \n            if (isAscending) {\n                // Ascending order\n                if (arr[mid] < target) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            } else {\n                // Descending order\n                if (arr[mid] > target) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int search(int[] arr, int target) {\n        int n = arr.length;\n        if (n == 0) return -1;\n        \n        // Determine order\n        boolean isAscending = arr[0] < arr[n - 1];\n        \n        int left = 0, right = n - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            }\n            \n            if (isAscending) {\n                // Ascending order\n                if (arr[mid] < target) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            } else {\n                // Descending order\n                if (arr[mid] > target) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def search(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        if n == 0:\n            return -1\n        \n        # Determine order\n        is_ascending = arr[0] < arr[-1]\n        \n        left, right = 0, n - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if arr[mid] == target:\n                return mid\n            \n            if is_ascending:\n                # Ascending order\n                if arr[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                # Descending order\n                if arr[mid] > target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1",
        "javascript": "function search(arr, target) {\n    const n = arr.length;\n    if (n === 0) return -1;\n    \n    // Determine order\n    const isAscending = arr[0] < arr[n - 1];\n    \n    let left = 0, right = n - 1;\n    \n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (arr[mid] === target) {\n            return mid;\n        }\n        \n        if (isAscending) {\n            // Ascending order\n            if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        } else {\n            // Descending order\n            if (arr[mid] > target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n}"
      }
    },
    {
      "name": "Unified Comparison (Alternative)",
      "order": 2,
      "intuition": "Instead of branching on order, use comparison that works for both. Check if target is in left or right half based on relative comparisons. More elegant but slightly harder to understand.",
      "approach": "Use comparisons that naturally handle both orders. Compare arr[mid] with both target and boundaries to decide direction.",
      "steps": [
        "Initialize left = 0, right = n-1",
        "While left <= right:",
        "  - mid = left + (right - left) / 2",
        "  - If arr[mid] == target: return mid",
        "  - Check if target is in left half:",
        "    * (arr[left] <= target < arr[mid]) OR",
        "    * (arr[left] >= target > arr[mid])",
        "  - If yes: right = mid - 1",
        "  - Else: left = mid + 1",
        "Return -1"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Binary search with unified logic. log n iterations. O(log n).",
        "spaceExplanation": "Only pointer variables. Constant space: O(1)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& arr, int target) {\n        int left = 0, right = arr.size() - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            }\n            \n            // Check if target is in left half\n            bool targetInLeft = (arr[left] <= arr[mid]) ?\n                (target >= arr[left] && target < arr[mid]) :\n                (target >= arr[left] || target < arr[mid]);\n            \n            if (targetInLeft) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int search(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            }\n            \n            // Check if target is in left half\n            boolean targetInLeft = (arr[left] <= arr[mid]) ?\n                (target >= arr[left] && target < arr[mid]) :\n                (target >= arr[left] || target < arr[mid]);\n            \n            if (targetInLeft) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def search(self, arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if arr[mid] == target:\n                return mid\n            \n            # Check if target is in left half\n            if arr[left] <= arr[mid]:\n                target_in_left = arr[left] <= target < arr[mid]\n            else:\n                target_in_left = target >= arr[left] or target < arr[mid]\n            \n            if target_in_left:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return -1",
        "javascript": "function search(arr, target) {\n    let left = 0, right = arr.length - 1;\n    \n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (arr[mid] === target) {\n            return mid;\n        }\n        \n        // Check if target is in left half\n        const targetInLeft = (arr[left] <= arr[mid]) ?\n            (target >= arr[left] && target < arr[mid]) :\n            (target >= arr[left] || target < arr[mid]);\n        \n        if (targetInLeft) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return -1;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not handling single-element array",
    "Assuming order without checking",
    "Wrong comparison operators for descending order",
    "Not handling equal elements at boundaries",
    "Infinite loop due to wrong pointer updates",
    "Forgetting to check arr[mid] == target first",
    "Using wrong boundary (left < right vs left <= right)",
    "Not considering all elements might be same"
  ],
  "hints": [
    "Compare first and last elements to detect order",
    "arr[0] < arr[n-1] means ascending",
    "arr[0] > arr[n-1] means descending",
    "Apply standard binary search with adjusted logic",
    "Time complexity stays O(log n)",
    "Order detection is O(1)",
    "Can handle both orders in single function",
    "Edge case: array with one element"
  ],
  "followUp": [
    "What if array has duplicates?",
    "How to handle rotated arrays?",
    "What if order changes multiple times?",
    "Can you detect order in O(log n)?",
    "What about partially sorted arrays?",
    "How to handle very large arrays?",
    "What if array is mostly sorted with few outliers?",
    "Can you extend to 2D arrays?"
  ],
  "companies": [
    "Amazon",
    "Microsoft",
    "Google",
    "Facebook",
    "Apple",
    "Bloomberg",
    "Oracle",
    "Adobe"
  ],
  "tags": [
    "Binary Search",
    "Array",
    "Sorted Array",
    "Two Pointers"
  ],
  "relatedProblems": [
    "Binary Search",
    "Search Insert Position",
    "Find Smallest Letter Greater Than Target",
    "First Bad Version",
    "Search in Rotated Sorted Array",
    "Find Peak Element",
    "Ceiling Number",
    "Next Letter"
  ]
}
