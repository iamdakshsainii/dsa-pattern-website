{
  "questionId": "694d4a3a98494915f3bc8e79",
  "questionSlug": "pair-with-target-sum",
  "resources": {
    "leetcode": "https://leetcode.com/problems/two-sum/",
    "videos": [
      {
        "title": "Two Sum - LeetCode Solution Explained",
        "url": "https://www.youtube.com/watch?v=KLlXCFG5TnA",
        "channel": "NeetCode",
        "duration": "8:23",
        "language": "English"
      },
      {
        "title": "Two Sum - Multiple Approaches",
        "url": "https://www.youtube.com/watch?v=UXDSeD9mN-k",
        "channel": "take U forward",
        "duration": "12:45",
        "language": "English"
      },
      {
        "title": "Two Pointers Technique on Sorted Array",
        "url": "https://www.youtube.com/watch?v=cQ1Oz4ckceM",
        "channel": "Aditya Verma",
        "duration": "15:30",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Two Sum Solution",
        "url": "https://leetcode.com/problems/two-sum/solutions/",
        "source": "LeetCode"
      },
      {
        "title": "Two Pointers Approach Explained",
        "url": "https://www.geeksforgeeks.org/two-pointers-technique/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Two Sum Patterns",
        "url": "https://algo.monster/problems/two_sum",
        "source": "AlgoMonster"
      }
    ],
    "practice": [
      {
        "title": "Two Sum II - Input Array Is Sorted",
        "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
        "platform": "LeetCode"
      },
      {
        "title": "3Sum",
        "url": "https://leetcode.com/problems/3sum/",
        "platform": "LeetCode"
      },
      {
        "title": "Two Sum Less Than K",
        "url": "https://leetcode.com/problems/two-sum-less-than-k/",
        "platform": "LeetCode"
      },
      {
        "title": "4Sum",
        "url": "https://leetcode.com/problems/4sum/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Pair with Target Sum when: finding two numbers that sum to target, sorted array allows two pointers, unsorted needs HashMap. Keywords: 'two sum', 'pair of numbers', 'target sum', 'find indices'.",
  "approaches": [
    {
      "name": "Brute Force",
      "order": 1,
      "intuition": "Try all possible pairs in the array to find which two numbers sum to the target. Check every combination with nested loops. Works for both sorted and unsorted arrays but inefficient.",
      "approach": "Use two nested loops to check every possible pair of numbers in the array.",
      "steps": [
        "Loop through each element with index i from 0 to n-2",
        "For each i, loop through remaining elements with index j from i+1 to n-1",
        "Check if nums[i] + nums[j] equals target",
        "Return [i, j] when match found",
        "Return empty if no pair found"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(1)",
        "timeExplanation": "Two nested loops: outer loop runs n times, inner loop runs up to n times. Total: O(n²).",
        "spaceExplanation": "No extra space needed, only loop variables: O(1)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        \n        return {};\n    }\n};",
        "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        \n        return new int[]{};\n    }\n}",
        "python": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        \n        return []",
        "javascript": "function twoSum(nums, target) {\n    const n = nums.length;\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    \n    return [];\n}"
      }
    },
    {
      "name": "Two Pointers (For Sorted Array - Optimal)",
      "order": 2,
      "intuition": "For sorted array, use two pointers from both ends. If sum too small, move left pointer right (increases sum). If sum too large, move right pointer left (decreases sum). O(n) time, O(1) space.",
      "approach": "Initialize pointers at start and end. Compare sum with target. Adjust pointers based on comparison until pair found.",
      "steps": [
        "Initialize left = 0, right = n - 1",
        "While left < right:",
        "  - Calculate currentSum = nums[left] + nums[right]",
        "  - If currentSum == target:",
        "    - Return [left, right] or [left + 1, right + 1] for 1-indexed",
        "  - Else if currentSum < target:",
        "    - Increment left (need larger sum)",
        "  - Else:",
        "    - Decrement right (need smaller sum)",
        "Return empty or [-1, -1] if no pair found"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass with two pointers moving toward each other. Each element visited at most once: O(n).",
        "spaceExplanation": "Only two pointer variables used. Constant space: O(1)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int left = 0, right = numbers.size() - 1;\n        \n        while (left < right) {\n            int sum = numbers[left] + numbers[right];\n            \n            if (sum == target) {\n                return {left + 1, right + 1}; // 1-indexed\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return {-1, -1};\n    }\n};",
        "java": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int left = 0, right = numbers.length - 1;\n        \n        while (left < right) {\n            int sum = numbers[left] + numbers[right];\n            \n            if (sum == target) {\n                return new int[]{left + 1, right + 1}; // 1-indexed\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return new int[]{-1, -1};\n    }\n}",
        "python": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        left, right = 0, len(numbers) - 1\n        \n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            \n            if current_sum == target:\n                return [left + 1, right + 1]  # 1-indexed\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return [-1, -1]",
        "javascript": "function twoSum(numbers, target) {\n    let left = 0, right = numbers.length - 1;\n    \n    while (left < right) {\n        const sum = numbers[left] + numbers[right];\n        \n        if (sum === target) {\n            return [left + 1, right + 1]; // 1-indexed\n        } else if (sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return [-1, -1];\n}"
      }
    },
    {
      "name": "Hash Map (For Unsorted Array - Optimal)",
      "order": 3,
      "intuition": "For unsorted array, use HashMap to store complements. For each number, check if its complement (target - number) exists in map. O(n) time, O(n) space.",
      "approach": "Single pass: check if complement exists, then store current number with index.",
      "steps": [
        "Create empty HashMap",
        "For i from 0 to n-1:",
        "  - Calculate complement = target - nums[i]",
        "  - If complement in map:",
        "    - Return [map[complement], i]",
        "  - Store nums[i] with index i in map",
        "Return empty if no pair found"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass through array with O(1) HashMap operations: O(n).",
        "spaceExplanation": "HashMap stores at most n elements: O(n)."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            \n            if (map.find(complement) != map.end()) {\n                return {map[complement], i};\n            }\n            \n            map[nums[i]] = i;\n        }\n        \n        return {};\n    }\n};",
        "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            \n            if (map.containsKey(complement)) {\n                return new int[]{map.get(complement), i};\n            }\n            \n            map.put(nums[i], i);\n        }\n        \n        return new int[]{};\n    }\n}",
        "python": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        \n        for i, num in enumerate(nums):\n            complement = target - num\n            \n            if complement in seen:\n                return [seen[complement], i]\n            \n            seen[num] = i\n        \n        return []",
        "javascript": "function twoSum(nums, target) {\n    const map = new Map();\n    \n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        \n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        \n        map.set(nums[i], i);\n    }\n    \n    return [];\n}"
      }
    }
  ],
  "commonMistakes": [
    "Using same element twice (not moving pointers correctly)",
    "Forgetting to check if array is sorted before using two pointers",
    "Not handling empty array or single element edge cases",
    "In HashMap approach, storing number before checking complement",
    "Integer overflow when calculating sum",
    "Wrong pointer update logic (moving both pointers)",
    "Not returning correct index format (0-indexed vs 1-indexed)",
    "Accessing map without checking if key exists"
  ],
  "hints": [
    "For sorted array, two pointers is optimal: O(n) time, O(1) space",
    "For unsorted array, HashMap is optimal: O(n) time, O(n) space",
    "Two pointers: left moves right for larger sum, right moves left for smaller sum",
    "HashMap: check complement first, then store current number",
    "Each number can be used only once",
    "Exactly one solution exists (guaranteed by problem)",
    "Consider edge cases: array length < 2, negative numbers",
    "Two Sum II expects 1-indexed output, Two Sum expects 0-indexed"
  ],
  "followUp": [
    "What if array is not sorted? (Use HashMap)",
    "How to find all pairs that sum to target? (Two pointers, store all)",
    "Can you solve with O(1) space for sorted array? (Yes, two pointers)",
    "What if there are duplicate numbers?",
    "How to extend to 3Sum or 4Sum?",
    "What if you need to find pairs with difference equal to k?",
    "Can you solve if array is circularly sorted?",
    "What if target is the maximum sum possible?"
  ],
  "companies": [
    "Google",
    "Amazon",
    "Microsoft",
    "Facebook",
    "Apple",
    "Adobe",
    "Bloomberg",
    "Uber",
    "LinkedIn",
    "Oracle"
  ],
  "tags": [
    "Array",
    "Two Pointers",
    "Hash Table",
    "Sorting"
  ],
  "relatedProblems": [
    "Two Sum II - Input Array Is Sorted",
    "3Sum",
    "4Sum",
    "Two Sum Less Than K",
    "3Sum Closest",
    "Two Sum IV - Input is a BST",
    "Subarray Sum Equals K",
    "Two Sum III - Data structure design"
  ]
}
