{
  "questionId": "15",
  "questionSlug": "3sum",
  "title": "3Sum",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/3sum/",
    "videos": [
      {
        "title": "3Sum - Leetcode 15",
        "url": "https://www.youtube.com/watch?v=jzZsG8n2R9A",
        "channel": "NeetCode",
        "duration": "12:54",
        "language": "English"
      },
      {
        "title": "L13. 3 Sum | Find Triplets that add up to a target value",
        "url": "https://www.youtube.com/watch?v=DhFh8Kw7ymk",
        "channel": "take U forward",
        "duration": "19:35",
        "language": "English"
      },
      {
        "title": "3Sum Solution",
        "url": "https://www.youtube.com/watch?v=qJSPYnS35SE",
        "channel": "Kevin Naughton Jr.",
        "duration": "9:15",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "3Sum - LeetCode Solution",
        "url": "https://leetcode.com/problems/3sum/solution/",
        "source": "LeetCode Official"
      },
      {
        "title": "3 Sum | Find triplets that add up to a target",
        "url": "https://takeuforward.org/data-structure/3-sum-find-triplets-that-add-up-to-a-zero/",
        "source": "takeuforward"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/3sum/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Three elements + target sum = Sort + Fix one + Two Pointers. Convert to 2Sum by fixing first element.",
  "approaches": [
    {
      "name": "Brute Force (Three Nested Loops)",
      "order": 1,
      "intuition": "Check all possible triplets using three nested loops, use Set to avoid duplicates.",
      "approach": "Try every combination of three elements, check if sum equals zero, store unique triplets in Set.",
      "steps": [
        "Use Set to store unique triplets",
        "Iterate i from 0 to n-3:",
        "  Iterate j from i+1 to n-2:",
        "    Iterate k from j+1 to n-1:",
        "      If nums[i] + nums[j] + nums[k] == 0:",
        "        Sort triplet and add to Set",
        "Convert Set to List and return"
      ],
      "complexity": {
        "time": "O(n³ log n)",
        "space": "O(n)",
        "timeExplanation": "Three nested loops + Set operations",
        "spaceExplanation": "Set to store unique triplets"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        set<vector<int>> uniqueTriplets;\n        int n = nums.size();\n        \n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if (nums[i] + nums[j] + nums[k] == 0) {\n                        vector<int> triplet = {nums[i], nums[j], nums[k]};\n                        sort(triplet.begin(), triplet.end());\n                        uniqueTriplets.insert(triplet);\n                    }\n                }\n            }\n        }\n        \n        return vector<vector<int>>(uniqueTriplets.begin(), uniqueTriplets.end());\n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> uniqueTriplets = new HashSet<>();\n        int n = nums.length;\n        \n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if (nums[i] + nums[j] + nums[k] == 0) {\n                        List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);\n                        Collections.sort(triplet);\n                        uniqueTriplets.add(triplet);\n                    }\n                }\n            }\n        }\n        \n        return new ArrayList<>(uniqueTriplets);\n    }\n}",
        "python": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        unique_triplets = set()\n        n = len(nums)\n        \n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if nums[i] + nums[j] + nums[k] == 0:\n                        triplet = tuple(sorted([nums[i], nums[j], nums[k]]))\n                        unique_triplets.add(triplet)\n        \n        return [list(t) for t in unique_triplets]",
        "javascript": "var threeSum = function(nums) {\n    const uniqueTriplets = new Set();\n    const n = nums.length;\n    \n    for (let i = 0; i < n - 2; i++) {\n        for (let j = i + 1; j < n - 1; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (nums[i] + nums[j] + nums[k] === 0) {\n                    const triplet = [nums[i], nums[j], nums[k]].sort((a, b) => a - b);\n                    uniqueTriplets.add(triplet.join(','));\n                }\n            }\n        }\n    }\n    \n    return Array.from(uniqueTriplets).map(s => s.split(',').map(Number));\n};"
      }
    },
    {
      "name": "Better (HashSet for Two Sum)",
      "order": 2,
      "intuition": "Fix first element, use HashSet to solve Two Sum for remaining elements. Still need to handle duplicates.",
      "approach": "For each element, use HashSet to find pairs that sum to -nums[i]. Use Set to avoid duplicate triplets.",
      "steps": [
        "Use Set to store unique triplets",
        "Iterate i from 0 to n-2:",
        "  Create HashSet for current iteration",
        "  Iterate j from i+1 to n-1:",
        "    target = -(nums[i] + nums[j])",
        "    If target in HashSet:",
        "      Sort and add triplet to result Set",
        "    Add nums[j] to HashSet",
        "Return result"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(n)",
        "timeExplanation": "Nested loops with HashSet operations",
        "spaceExplanation": "HashSet for each iteration + result Set"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        set<vector<int>> result;\n        int n = nums.size();\n        \n        for (int i = 0; i < n - 2; i++) {\n            unordered_set<int> seen;\n            \n            for (int j = i + 1; j < n; j++) {\n                int target = -(nums[i] + nums[j]);\n                \n                if (seen.find(target) != seen.end()) {\n                    vector<int> triplet = {nums[i], nums[j], target};\n                    sort(triplet.begin(), triplet.end());\n                    result.insert(triplet);\n                }\n                \n                seen.insert(nums[j]);\n            }\n        }\n        \n        return vector<vector<int>>(result.begin(), result.end());\n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> result = new HashSet<>();\n        int n = nums.length;\n        \n        for (int i = 0; i < n - 2; i++) {\n            Set<Integer> seen = new HashSet<>();\n            \n            for (int j = i + 1; j < n; j++) {\n                int target = -(nums[i] + nums[j]);\n                \n                if (seen.contains(target)) {\n                    List<Integer> triplet = Arrays.asList(nums[i], nums[j], target);\n                    Collections.sort(triplet);\n                    result.add(triplet);\n                }\n                \n                seen.add(nums[j]);\n            }\n        }\n        \n        return new ArrayList<>(result);\n    }\n}",
        "python": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        result = set()\n        n = len(nums)\n        \n        for i in range(n - 2):\n            seen = set()\n            \n            for j in range(i + 1, n):\n                target = -(nums[i] + nums[j])\n                \n                if target in seen:\n                    triplet = tuple(sorted([nums[i], nums[j], target]))\n                    result.add(triplet)\n                \n                seen.add(nums[j])\n        \n        return [list(t) for t in result]",
        "javascript": "var threeSum = function(nums) {\n    const result = new Set();\n    const n = nums.length;\n    \n    for (let i = 0; i < n - 2; i++) {\n        const seen = new Set();\n        \n        for (let j = i + 1; j < n; j++) {\n            const target = -(nums[i] + nums[j]);\n            \n            if (seen.has(target)) {\n                const triplet = [nums[i], nums[j], target].sort((a, b) => a - b);\n                result.add(triplet.join(','));\n            }\n            \n            seen.add(nums[j]);\n        }\n    }\n    \n    return Array.from(result).map(s => s.split(',').map(Number));\n};"
      }
    },
    {
      "name": "Sort + Two Pointers - Optimal",
      "order": 3,
      "intuition": "Sort array. Fix first element, use two pointers for remaining pair. Skip duplicates to avoid duplicate triplets.",
      "approach": "Sort first. For each element, solve 2Sum on remaining array. Handle duplicates carefully.",
      "steps": [
        "Sort array",
        "Iterate i from 0 to n-3:",
        "  Skip if nums[i] same as nums[i-1] (avoid duplicates)",
        "  Initialize left = i+1, right = n-1",
        "  While left < right:",
        "    Calculate sum = nums[i] + nums[left] + nums[right]",
        "    If sum == 0:",
        "      Add triplet to result",
        "      Skip duplicates for left and right",
        "      Move both pointers",
        "    Else if sum < 0: left++",
        "    Else: right--",
        "Return result"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(1)",
        "timeExplanation": "O(n log n) for sort + O(n²) for nested loops",
        "spaceExplanation": "Ignoring output array, only constant space used"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> result;\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        \n        for (int i = 0; i < n - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            \n            int left = i + 1, right = n - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == 0) {\n                    result.push_back({nums[i], nums[left], nums[right]});\n                    \n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        int n = nums.length;\n        \n        for (int i = 0; i < n - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            \n            int left = i + 1, right = n - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    \n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        nums.sort()\n        n = len(nums)\n        \n        for i in range(n - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            \n            left, right = i + 1, n - 1\n            \n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                \n                if total == 0:\n                    result.append([nums[i], nums[left], nums[right]])\n                    \n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    \n                    left += 1\n                    right -= 1\n                elif total < 0:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return result",
        "javascript": "var threeSum = function(nums) {\n    const result = [];\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    \n    for (let i = 0; i < n - 2; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        \n        let left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            \n            if (sum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n                \n                while (left < right && nums[left] === nums[left + 1]) left++;\n                while (left < right && nums[right] === nums[right - 1]) right--;\n                \n                left++;\n                right--;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling duplicates properly",
    "Forgetting to sort array first",
    "Including duplicate triplets in result",
    "Using HashSet to remove duplicates (inefficient)",
    "Wrong conditions for skipping duplicates"
  ],
  "hints": [
    "Sort the array first",
    "Fix one element, solve 2Sum for rest",
    "Skip duplicates at all three positions",
    "Target is 0, so nums[i] + nums[left] + nums[right] = 0",
    "i > 0 check prevents skipping first element"
  ],
  "followUp": [
    "What if target is not 0?",
    "Can you solve 4Sum?",
    "What about k-Sum?",
    "How to find all unique quadruplets?"
  ],
  "companies": ["Amazon", "Facebook", "Google", "Microsoft", "Apple"],
  "tags": ["array", "two-pointers", "sorting"],
  "relatedProblems": [
    "Two Sum",
    "3Sum Closest",
    "4Sum",
    "3Sum Smaller"
  ]
}
