{
  "questionId": "26",
  "questionSlug": "remove-duplicates-from-sorted-array",
  "title": "Remove Duplicates from Sorted Array",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
    "videos": [
      {
        "title": "Remove Duplicates from Sorted Array - Leetcode 26",
        "url": "https://www.youtube.com/watch?v=DEJAZBq0FDA",
        "channel": "NeetCode",
        "duration": "5:23",
        "language": "English"
      },
      {
        "title": "L3. Remove Duplicates in-place from Sorted Array",
        "url": "https://www.youtube.com/watch?v=Fm_p9lJ4Z_8",
        "channel": "take U forward",
        "duration": "11:40",
        "language": "English"
      },
      {
        "title": "Remove Duplicates From Sorted Array",
        "url": "https://www.youtube.com/watch?v=jSKdl4gBYPk",
        "channel": "Kevin Naughton Jr.",
        "duration": "6:12",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Remove Duplicates from Sorted Array - LeetCode Solution",
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solution/",
        "source": "LeetCode Official"
      },
      {
        "title": "Remove duplicates from sorted array",
        "url": "https://takeuforward.org/data-structure/remove-duplicates-in-place-from-sorted-array/",
        "source": "takeuforward"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Sorted array + in-place modification = Two Pointers (slow-fast). Slow pointer tracks position to place unique element, fast pointer scans array.",
  "approaches": [
    {
      "name": "Brute Force (Using Extra Space)",
      "order": 1,
      "intuition": "Use a Set or separate array to track unique elements, then copy back to original array.",
      "approach": "Iterate through array, add unique elements to Set, then copy Set elements back to array.",
      "steps": [
        "Create a Set or temporary array",
        "Iterate through nums and add unique elements",
        "Copy unique elements back to nums",
        "Return count of unique elements"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass to collect unique elements",
        "spaceExplanation": "Extra space for Set or array"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        \n        set<int> uniqueSet(nums.begin(), nums.end());\n        \n        int index = 0;\n        for (int num : uniqueSet) {\n            nums[index++] = num;\n        }\n        \n        return uniqueSet.size();\n    }\n};",
        "java": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        \n        Set<Integer> uniqueSet = new LinkedHashSet<>();\n        for (int num : nums) {\n            uniqueSet.add(num);\n        }\n        \n        int index = 0;\n        for (int num : uniqueSet) {\n            nums[index++] = num;\n        }\n        \n        return uniqueSet.size();\n    }\n}",
        "python": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        unique = []\n        seen = set()\n        \n        for num in nums:\n            if num not in seen:\n                seen.add(num)\n                unique.append(num)\n        \n        for i in range(len(unique)):\n            nums[i] = unique[i]\n        \n        return len(unique)",
        "javascript": "var removeDuplicates = function(nums) {\n    if (nums.length === 0) return 0;\n    \n    const uniqueSet = new Set(nums);\n    \n    let index = 0;\n    for (let num of uniqueSet) {\n        nums[index++] = num;\n    }\n    \n    return uniqueSet.size;\n};"
      }
    },
    {
      "name": "Better (Compare Adjacent)",
      "order": 2,
      "intuition": "Since array is sorted, duplicates are adjacent. Copy only when current element differs from previous.",
      "approach": "Maintain an index for placing unique elements. Compare each element with previous, copy if different.",
      "steps": [
        "Handle edge case: if array length <= 1, return length",
        "Initialize index = 1 (first element always unique)",
        "Iterate from position 1 to n-1:",
        "  If nums[i] != nums[i-1]:",
        "    Copy nums[i] to nums[index]",
        "    Increment index",
        "Return index"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through array",
        "spaceExplanation": "Only using index variable"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.size() <= 1) return nums.size();\n        \n        int index = 1;\n        \n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] != nums[i - 1]) {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        \n        return index;\n    }\n};",
        "java": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length <= 1) return nums.length;\n        \n        int index = 1;\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[i - 1]) {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        \n        return index;\n    }\n}",
        "python": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return len(nums)\n        \n        index = 1\n        \n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[index] = nums[i]\n                index += 1\n        \n        return index",
        "javascript": "var removeDuplicates = function(nums) {\n    if (nums.length <= 1) return nums.length;\n    \n    let index = 1;\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] !== nums[i - 1]) {\n            nums[index] = nums[i];\n            index++;\n        }\n    }\n    \n    return index;\n};"
      }
    },
    {
      "name": "Two Pointers - Optimal",
      "order": 3,
      "intuition": "Use slow pointer to track position for next unique element. Fast pointer scans array. When fast finds new unique element, place it at slow position.",
      "approach": "Slow pointer marks insertion position for unique elements. Fast pointer finds unique elements by comparing with previous.",
      "steps": [
        "Handle edge case: if array length <= 1, return length",
        "Initialize slow = 1 (position for next unique)",
        "Initialize fast = 1 (scanner)",
        "While fast < n:",
        "  If nums[fast] != nums[fast-1] (found unique):",
        "    Place nums[fast] at nums[slow]",
        "    Increment slow",
        "  Increment fast",
        "Return slow (number of unique elements)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through array",
        "spaceExplanation": "Only using two pointer variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.size() <= 1) return nums.size();\n        \n        int slow = 1;\n        \n        for (int fast = 1; fast < nums.size(); fast++) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n        \n        return slow;\n    }\n};",
        "java": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length <= 1) return nums.length;\n        \n        int slow = 1;\n        \n        for (int fast = 1; fast < nums.length; fast++) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n        \n        return slow;\n    }\n}",
        "python": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return len(nums)\n        \n        slow = 1\n        \n        for fast in range(1, len(nums)):\n            if nums[fast] != nums[fast - 1]:\n                nums[slow] = nums[fast]\n                slow += 1\n        \n        return slow",
        "javascript": "var removeDuplicates = function(nums) {\n    if (nums.length <= 1) return nums.length;\n    \n    let slow = 1;\n    \n    for (let fast = 1; fast < nums.length; fast++) {\n        if (nums[fast] !== nums[fast - 1]) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n    }\n    \n    return slow;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Using extra space when in-place solution required",
    "Not understanding that order must be maintained",
    "Comparing nums[fast] with nums[slow] instead of nums[fast-1]",
    "Forgetting to handle edge case of empty or single element array"
  ],
  "hints": [
    "Array is sorted, duplicates are adjacent",
    "Use slow pointer for placement, fast for scanning",
    "Only move slow when unique element found",
    "First element is always unique"
  ],
  "followUp": [
    "What if array is not sorted?",
    "What if duplicates allowed at most twice?",
    "Can you do it without modifying the array?"
  ],
  "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
  "tags": ["array", "two-pointers"],
  "relatedProblems": [
    "Remove Element",
    "Remove Duplicates from Sorted Array II",
    "Remove Duplicates from Sorted List"
  ]
}
