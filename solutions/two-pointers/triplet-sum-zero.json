{
  "questionId": "694d4a3a98494915f3bc8e7c",
  "questionSlug": "triplet-sum-zero",
  "title": "Triplet Sum Zero",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/3sum/",
    "videos": [
      {
        "title": "3Sum - Leetcode 15 - Python",
        "url": "https://www.youtube.com/watch?v=jzZsG8n2R9A",
        "channel": "NeetCode",
        "duration": "12:26",
        "language": "English"
      },
      {
        "title": "3 Sum | Two Pointers Technique",
        "url": "https://www.youtube.com/watch?v=DhFh8Kw7ymk",
        "channel": "takeUforward",
        "duration": "15:38",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "3Sum Solution",
        "url": "https://leetcode.com/problems/3sum/solution/",
        "source": "LeetCode Editorial"
      }
    ],
    "practice": [
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/find-triplets-array-whose-sum-equal-zero/",
        "platform": "GeeksforGeeks"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Two Pointers after sorting when you need to find triplets or combinations. Fix one element and use two pointers for the remaining array.",
  "approaches": [
    {
      "name": "Brute Force",
      "order": 1,
      "intuition": "Check all possible triplets in the array to find those that sum to zero.",
      "approach": "Use three nested loops to examine every possible combination of three numbers.",
      "steps": [
        "Use three nested loops with indices i, j, k",
        "For each combination, check if nums[i] + nums[j] + nums[k] == 0",
        "Store unique triplets in a set to avoid duplicates",
        "Convert set to list and return"
      ],
      "complexity": {
        "time": "O(n³)",
        "space": "O(n)",
        "timeExplanation": "Three nested loops iterate through the array",
        "spaceExplanation": "Set to store unique triplets"
      },
      "code": {
        "cpp": "vector<vector<int>> threeSum(vector<int>& nums) {\n    set<vector<int>> resultSet;\n    int n = nums.size();\n    \n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (nums[i] + nums[j] + nums[k] == 0) {\n                    vector<int> triplet = {nums[i], nums[j], nums[k]};\n                    sort(triplet.begin(), triplet.end());\n                    resultSet.insert(triplet);\n                }\n            }\n        }\n    }\n    \n    return vector<vector<int>>(resultSet.begin(), resultSet.end());\n}",
        "java": "public List<List<Integer>> threeSum(int[] nums) {\n    Set<List<Integer>> resultSet = new HashSet<>();\n    int n = nums.length;\n    \n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (nums[i] + nums[j] + nums[k] == 0) {\n                    List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);\n                    Collections.sort(triplet);\n                    resultSet.add(triplet);\n                }\n            }\n        }\n    }\n    \n    return new ArrayList<>(resultSet);\n}",
        "python": "def three_sum(nums):\n    result = set()\n    n = len(nums)\n    \n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    triplet = tuple(sorted([nums[i], nums[j], nums[k]]))\n                    result.add(triplet)\n    \n    return [list(t) for t in result]",
        "javascript": "function threeSum(nums) {\n    const resultSet = new Set();\n    const n = nums.length;\n    \n    for (let i = 0; i < n - 2; i++) {\n        for (let j = i + 1; j < n - 1; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (nums[i] + nums[j] + nums[k] === 0) {\n                    const triplet = [nums[i], nums[j], nums[k]].sort((a, b) => a - b);\n                    resultSet.add(JSON.stringify(triplet));\n                }\n            }\n        }\n    }\n    \n    return Array.from(resultSet).map(s => JSON.parse(s));\n}"
      }
    },
    {
      "name": "Hash Set",
      "order": 2,
      "intuition": "Fix one element, then use a hash set to find pairs that sum to the negative of the fixed element.",
      "approach": "Sort the array first for easier duplicate handling. For each element, use a hash set to find complementary pairs.",
      "steps": [
        "Sort the array",
        "For each element at index i:",
        "  Skip duplicates of nums[i]",
        "  Create a hash set for the current iteration",
        "  For each element at index j (from i+1 to end):",
        "    Calculate complement = -(nums[i] + nums[j])",
        "    If complement exists in set, add triplet to result",
        "    Add nums[j] to the set",
        "Return result"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(n)",
        "timeExplanation": "O(n log n) for sorting + O(n²) for two nested loops",
        "spaceExplanation": "O(n) for the hash set"
      },
      "code": {
        "cpp": "vector<vector<int>> threeSum(vector<int>& nums) {\n    vector<vector<int>> result;\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    \n    for (int i = 0; i < n - 2; i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        \n        unordered_set<int> seen;\n        for (int j = i + 1; j < n; j++) {\n            int complement = -(nums[i] + nums[j]);\n            \n            if (seen.find(complement) != seen.end()) {\n                result.push_back({nums[i], complement, nums[j]});\n                while (j + 1 < n && nums[j] == nums[j + 1]) j++;\n            }\n            seen.insert(nums[j]);\n        }\n    }\n    \n    return result;\n}",
        "java": "public List<List<Integer>> threeSum(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    int n = nums.length;\n    \n    for (int i = 0; i < n - 2; i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        \n        Set<Integer> seen = new HashSet<>();\n        for (int j = i + 1; j < n; j++) {\n            int complement = -(nums[i] + nums[j]);\n            \n            if (seen.contains(complement)) {\n                result.add(Arrays.asList(nums[i], complement, nums[j]));\n                while (j + 1 < n && nums[j] == nums[j + 1]) j++;\n            }\n            seen.add(nums[j]);\n        }\n    }\n    \n    return result;\n}",
        "python": "def three_sum(nums):\n    result = []\n    nums.sort()\n    n = len(nums)\n    \n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        seen = set()\n        j = i + 1\n        while j < n:\n            complement = -(nums[i] + nums[j])\n            \n            if complement in seen:\n                result.append([nums[i], complement, nums[j]])\n                while j + 1 < n and nums[j] == nums[j + 1]:\n                    j += 1\n            \n            seen.add(nums[j])\n            j += 1\n    \n    return result",
        "javascript": "function threeSum(nums) {\n    const result = [];\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    \n    for (let i = 0; i < n - 2; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        \n        const seen = new Set();\n        for (let j = i + 1; j < n; j++) {\n            const complement = -(nums[i] + nums[j]);\n            \n            if (seen.has(complement)) {\n                result.push([nums[i], complement, nums[j]]);\n                while (j + 1 < n && nums[j] === nums[j + 1]) j++;\n            }\n            seen.add(nums[j]);\n        }\n    }\n    \n    return result;\n}"
      }
    },
    {
      "name": "Two Pointers (Optimal)",
      "order": 3,
      "intuition": "Sort the array first. Fix one element and use two pointers on the remaining array to find pairs that sum to the negative of the fixed element.",
      "approach": "After sorting, fix the first element and use two pointers (left and right) to find pairs in the remaining sorted array.",
      "steps": [
        "Sort the array",
        "For each element at index i (up to n-3):",
        "  Skip duplicate values of nums[i]",
        "  Set left = i + 1, right = n - 1",
        "  While left < right:",
        "    Calculate sum = nums[i] + nums[left] + nums[right]",
        "    If sum == 0:",
        "      Add [nums[i], nums[left], nums[right]] to result",
        "      Skip duplicates of nums[left] and nums[right]",
        "      Move both pointers",
        "    If sum < 0: increment left",
        "    If sum > 0: decrement right",
        "Return result"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(1)",
        "timeExplanation": "O(n log n) for sorting + O(n²) for outer loop and two pointers",
        "spaceExplanation": "O(1) if we don't count the output array"
      },
      "code": {
        "cpp": "vector<vector<int>> threeSum(vector<int>& nums) {\n    vector<vector<int>> result;\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    \n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates for the first element\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            \n            if (sum == 0) {\n                result.push_back({nums[i], nums[left], nums[right]});\n                \n                // Skip duplicates for the second element\n                while (left < right && nums[left] == nums[left + 1]) left++;\n                // Skip duplicates for the third element\n                while (left < right && nums[right] == nums[right - 1]) right--;\n                \n                left++;\n                right--;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}",
        "java": "public List<List<Integer>> threeSum(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    int n = nums.length;\n    \n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates for the first element\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        \n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            \n            if (sum == 0) {\n                result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                \n                // Skip duplicates for the second element\n                while (left < right && nums[left] == nums[left + 1]) left++;\n                // Skip duplicates for the third element\n                while (left < right && nums[right] == nums[right - 1]) right--;\n                \n                left++;\n                right--;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}",
        "python": "def three_sum(nums):\n    result = []\n    nums.sort()\n    n = len(nums)\n    \n    for i in range(n - 2):\n        # Skip duplicates for the first element\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                # Skip duplicates for the second element\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                # Skip duplicates for the third element\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result",
        "javascript": "function threeSum(nums) {\n    const result = [];\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    \n    for (let i = 0; i < n - 2; i++) {\n        // Skip duplicates for the first element\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        \n        let left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            \n            if (sum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n                \n                // Skip duplicates for the second element\n                while (left < right && nums[left] === nums[left + 1]) left++;\n                // Skip duplicates for the third element\n                while (left < right && nums[right] === nums[right - 1]) right--;\n                \n                left++;\n                right--;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not sorting the array before using two pointers",
    "Forgetting to skip duplicate elements, resulting in duplicate triplets",
    "Not handling the edge case of all zeros [0, 0, 0]",
    "Using wrong indices for the two pointers (should start from i+1)",
    "Not moving both pointers after finding a valid triplet"
  ],
  "hints": [
    "Sorting the array first makes it easier to avoid duplicates and use two pointers",
    "Think of this as: for each element, find two elements that sum to its negative",
    "After sorting, you can skip duplicate elements to avoid duplicate triplets",
    "The two pointers technique works because the array is sorted"
  ],
  "followUp": [
    "How would you find all unique quadruplets that sum to a target (4Sum)?",
    "Can you solve it without sorting the array?",
    "What if you need to find triplets with a sum closest to zero instead of exactly zero?",
    "How would you optimize further if the array is very large?"
  ],
  "companies": [
    "Facebook",
    "Amazon",
    "Google",
    "Microsoft",
    "Apple",
    "Bloomberg",
    "Adobe"
  ],
  "tags": [
    "Array",
    "Two Pointers",
    "Sorting"
  ],
  "relatedProblems": [
    "Two Sum",
    "3Sum Closest",
    "4Sum",
    "3Sum Smaller"
  ]
}