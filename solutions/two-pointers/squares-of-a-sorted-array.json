{
  "questionId": "977",
  "questionSlug": "squares-of-a-sorted-array",
  "title": "Squares of a Sorted Array",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/squares-of-a-sorted-array/",
    "videos": [
      {
        "title": "Squares of a Sorted Array - Leetcode 977",
        "url": "https://www.youtube.com/watch?v=FPCZsG_AkUg",
        "channel": "NeetCode",
        "duration": "6:34",
        "language": "English"
      },
      {
        "title": "Squares of a Sorted Array",
        "url": "https://www.youtube.com/watch?v=3QJzHqNAEXs",
        "channel": "Kevin Naughton Jr.",
        "duration": "5:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Squares of a Sorted Array - LeetCode Solution",
        "url": "https://leetcode.com/problems/squares-of-a-sorted-array/solution/",
        "source": "LeetCode Official"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/squares-of-a-sorted-array/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Sorted array with negatives + merge from ends = Two Pointers. Compare absolute values from both ends, fill result from back.",
  "approaches": [
    {
      "name": "Brute Force (Square and Sort)",
      "order": 1,
      "intuition": "Square all elements first, then sort the result array.",
      "approach": "Square each element in array, then apply sorting algorithm to get sorted squares.",
      "steps": [
        "Create result array of same size",
        "Square each element and store in result",
        "Sort the result array",
        "Return sorted result"
      ],
      "complexity": {
        "time": "O(n log n)",
        "space": "O(n)",
        "timeExplanation": "O(n) to square + O(n log n) to sort",
        "spaceExplanation": "Result array of size n"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n);\n        \n        for (int i = 0; i < n; i++) {\n            result[i] = nums[i] * nums[i];\n        }\n        \n        sort(result.begin(), result.end());\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            result[i] = nums[i] * nums[i];\n        }\n        \n        Arrays.sort(result);\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        result = [num ** 2 for num in nums]\n        result.sort()\n        return result",
        "javascript": "var sortedSquares = function(nums) {\n    const result = nums.map(num => num ** 2);\n    result.sort((a, b) => a - b);\n    return result;\n};"
      }
    },
    {
      "name": "Better (Find Split Point)",
      "order": 2,
      "intuition": "Find the split between negative and non-negative numbers. Merge the two halves like merging two sorted arrays.",
      "approach": "Find transition point from negative to positive. Use two pointers to merge sorted squares from both sides.",
      "steps": [
        "Find index where numbers change from negative to positive",
        "Use two pointers: one going left from split, one going right",
        "Compare squares from both sides",
        "Add smaller square to result",
        "Move corresponding pointer",
        "Add remaining elements"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "O(n) to find split + O(n) to merge",
        "spaceExplanation": "Result array of size n"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n);\n        int split = 0;\n        \n        while (split < n && nums[split] < 0) {\n            split++;\n        }\n        \n        int left = split - 1;\n        int right = split;\n        int index = 0;\n        \n        while (left >= 0 && right < n) {\n            int leftSquare = nums[left] * nums[left];\n            int rightSquare = nums[right] * nums[right];\n            \n            if (leftSquare < rightSquare) {\n                result[index++] = leftSquare;\n                left--;\n            } else {\n                result[index++] = rightSquare;\n                right++;\n            }\n        }\n        \n        while (left >= 0) {\n            result[index++] = nums[left] * nums[left];\n            left--;\n        }\n        \n        while (right < n) {\n            result[index++] = nums[right] * nums[right];\n            right++;\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        int split = 0;\n        \n        while (split < n && nums[split] < 0) {\n            split++;\n        }\n        \n        int left = split - 1;\n        int right = split;\n        int index = 0;\n        \n        while (left >= 0 && right < n) {\n            int leftSquare = nums[left] * nums[left];\n            int rightSquare = nums[right] * nums[right];\n            \n            if (leftSquare < rightSquare) {\n                result[index++] = leftSquare;\n                left--;\n            } else {\n                result[index++] = rightSquare;\n                right++;\n            }\n        }\n        \n        while (left >= 0) {\n            result[index++] = nums[left] * nums[left];\n            left--;\n        }\n        \n        while (right < n) {\n            result[index++] = nums[right] * nums[right];\n            right++;\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        result = [0] * n\n        split = 0\n        \n        while split < n and nums[split] < 0:\n            split += 1\n        \n        left = split - 1\n        right = split\n        index = 0\n        \n        while left >= 0 and right < n:\n            left_square = nums[left] ** 2\n            right_square = nums[right] ** 2\n            \n            if left_square < right_square:\n                result[index] = left_square\n                left -= 1\n            else:\n                result[index] = right_square\n                right += 1\n            index += 1\n        \n        while left >= 0:\n            result[index] = nums[left] ** 2\n            left -= 1\n            index += 1\n        \n        while right < n:\n            result[index] = nums[right] ** 2\n            right += 1\n            index += 1\n        \n        return result",
        "javascript": "var sortedSquares = function(nums) {\n    const n = nums.length;\n    const result = new Array(n);\n    let split = 0;\n    \n    while (split < n && nums[split] < 0) {\n        split++;\n    }\n    \n    let left = split - 1;\n    let right = split;\n    let index = 0;\n    \n    while (left >= 0 && right < n) {\n        const leftSquare = nums[left] ** 2;\n        const rightSquare = nums[right] ** 2;\n        \n        if (leftSquare < rightSquare) {\n            result[index++] = leftSquare;\n            left--;\n        } else {\n            result[index++] = rightSquare;\n            right++;\n        }\n    }\n    \n    while (left >= 0) {\n        result[index++] = nums[left] ** 2;\n        left--;\n    }\n    \n    while (right < n) {\n        result[index++] = nums[right] ** 2;\n        right++;\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Two Pointers - Optimal (Fill from Back)",
      "order": 3,
      "intuition": "Largest squares are at ends (most negative or most positive). Compare from both ends, fill result array from back to front.",
      "approach": "Use two pointers at ends. Compare absolute values, place larger square at end of result, move that pointer inward.",
      "steps": [
        "Create result array of same size",
        "Initialize left = 0, right = n-1, pos = n-1",
        "While left <= right:",
        "  Calculate leftSquare = nums[left]²",
        "  Calculate rightSquare = nums[right]²",
        "  If leftSquare > rightSquare:",
        "    result[pos] = leftSquare, left++",
        "  Else:",
        "    result[pos] = rightSquare, right--",
        "  Decrement pos",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass through array",
        "spaceExplanation": "Result array of size n (output space, O(1) extra)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n);\n        int left = 0, right = n - 1, pos = n - 1;\n        \n        while (left <= right) {\n            int leftSquare = nums[left] * nums[left];\n            int rightSquare = nums[right] * nums[right];\n            \n            if (leftSquare > rightSquare) {\n                result[pos] = leftSquare;\n                left++;\n            } else {\n                result[pos] = rightSquare;\n                right--;\n            }\n            pos--;\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        int left = 0, right = n - 1, pos = n - 1;\n        \n        while (left <= right) {\n            int leftSquare = nums[left] * nums[left];\n            int rightSquare = nums[right] * nums[right];\n            \n            if (leftSquare > rightSquare) {\n                result[pos] = leftSquare;\n                left++;\n            } else {\n                result[pos] = rightSquare;\n                right--;\n            }\n            pos--;\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        result = [0] * n\n        left, right, pos = 0, n - 1, n - 1\n        \n        while left <= right:\n            left_square = nums[left] ** 2\n            right_square = nums[right] ** 2\n            \n            if left_square > right_square:\n                result[pos] = left_square\n                left += 1\n            else:\n                result[pos] = right_square\n                right -= 1\n            pos -= 1\n        \n        return result",
        "javascript": "var sortedSquares = function(nums) {\n    const n = nums.length;\n    const result = new Array(n);\n    let left = 0, right = n - 1, pos = n - 1;\n    \n    while (left <= right) {\n        const leftSquare = nums[left] ** 2;\n        const rightSquare = nums[right] ** 2;\n        \n        if (leftSquare > rightSquare) {\n            result[pos] = leftSquare;\n            left++;\n        } else {\n            result[pos] = rightSquare;\n            right--;\n        }\n        pos--;\n    }\n    \n    return result;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Squaring then sorting (O(n log n) instead of O(n))",
    "Trying to find middle point unnecessarily",
    "Not filling result from back to front",
    "Forgetting that negative numbers squared become positive"
  ],
  "hints": [
    "Largest squares must be at the ends",
    "Fill result array backwards",
    "Compare absolute values (or squares directly)",
    "Sorted array property: extremes have largest absolute values"
  ],
  "followUp": [
    "What if array not sorted?",
    "Can you do it in-place?",
    "What if array contains only positive numbers?",
    "What about cubes instead of squares?"
  ],
  "companies": ["Amazon", "Google", "Facebook", "Microsoft", "Bloomberg"],
  "tags": ["array", "two-pointers", "sorting"],
  "relatedProblems": [
    "Merge Sorted Array",
    "Sort Transformed Array",
    "Sort Colors"
  ]
}
