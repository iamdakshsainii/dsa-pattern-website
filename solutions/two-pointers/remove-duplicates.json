{
  "questionId": "694d4a3a98494915f3bc8e7a",
  "questionSlug": "remove-duplicates",
  "resources": {
    "leetcode": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
    "videos": [
      {
        "title": "Remove Duplicates from Sorted Array - Leetcode 26",
        "url": "https://www.youtube.com/watch?v=DEJAZBq0FDA",
        "channel": "NeetCode",
        "duration": "7:18",
        "language": "English"
      },
      {
        "title": "Two Pointer Approach Explained",
        "url": "https://www.youtube.com/watch?v=Fm_p9lJ4Z_8",
        "channel": "takeUforward",
        "duration": "10:25",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Remove Duplicates from Sorted Array Solution",
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solution/",
        "source": "LeetCode Editorial"
      }
    ],
    "practice": [
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/remove-duplicates-sorted-array/",
        "platform": "GeeksforGeeks"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Two Pointers when you need to modify an array in-place, especially when dealing with sorted arrays and removing/replacing elements.",
  "approaches": [
    {
      "name": "Brute Force - Extra Space",
      "order": 1,
      "intuition": "Use extra space to store unique elements, then copy them back to the original array.",
      "approach": "Create a new array or set to store unique elements, then overwrite the original array.",
      "steps": [
        "Create a temporary array or list",
        "Iterate through the original array",
        "Add only unique elements to the temporary storage",
        "Copy elements from temporary storage back to original array",
        "Return the count of unique elements"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass through the array",
        "spaceExplanation": "Extra array to store unique elements"
      },
      "code": {
        "cpp": "int removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    vector<int> unique;\n    unique.push_back(nums[0]);\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] != nums[i - 1]) {\n            unique.push_back(nums[i]);\n        }\n    }\n    \n    for (int i = 0; i < unique.size(); i++) {\n        nums[i] = unique[i];\n    }\n    \n    return unique.size();\n}",
        "java": "public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    \n    List<Integer> unique = new ArrayList<>();\n    unique.add(nums[0]);\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] != nums[i - 1]) {\n            unique.add(nums[i]);\n        }\n    }\n    \n    for (int i = 0; i < unique.size(); i++) {\n        nums[i] = unique.get(i);\n    }\n    \n    return unique.size();\n}",
        "python": "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    unique = [nums[0]]\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1]:\n            unique.append(nums[i])\n    \n    for i in range(len(unique)):\n        nums[i] = unique[i]\n    \n    return len(unique)",
        "javascript": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    \n    const unique = [nums[0]];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] !== nums[i - 1]) {\n            unique.push(nums[i]);\n        }\n    }\n    \n    for (let i = 0; i < unique.length; i++) {\n        nums[i] = unique[i];\n    }\n    \n    return unique.length;\n}"
      }
    },
    {
      "name": "Two Pointers (Optimal)",
      "order": 2,
      "intuition": "Use one pointer to track the position of unique elements and another to scan through the array.",
      "approach": "Keep a slow pointer for the position of unique elements and a fast pointer to scan through the array.",
      "steps": [
        "Handle edge case: if array is empty, return 0",
        "Initialize slow pointer (insertPos) at index 1",
        "Initialize fast pointer at index 1",
        "While fast < array length:",
        "  If nums[fast] != nums[fast-1] (found new unique element):",
        "    Place nums[fast] at nums[insertPos]",
        "    Increment insertPos",
        "  Increment fast",
        "Return insertPos (count of unique elements)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through the array",
        "spaceExplanation": "Only two pointer variables used, in-place modification"
      },
      "code": {
        "cpp": "int removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    int insertPos = 1; // Position to insert next unique element\n    \n    for (int i = 1; i < nums.size(); i++) {\n        // If current element is different from previous\n        if (nums[i] != nums[i - 1]) {\n            nums[insertPos] = nums[i];\n            insertPos++;\n        }\n    }\n    \n    return insertPos;\n}",
        "java": "public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    \n    int insertPos = 1; // Position to insert next unique element\n    \n    for (int i = 1; i < nums.length; i++) {\n        // If current element is different from previous\n        if (nums[i] != nums[i - 1]) {\n            nums[insertPos] = nums[i];\n            insertPos++;\n        }\n    }\n    \n    return insertPos;\n}",
        "python": "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    insert_pos = 1  # Position to insert next unique element\n    \n    for i in range(1, len(nums)):\n        # If current element is different from previous\n        if nums[i] != nums[i - 1]:\n            nums[insert_pos] = nums[i]\n            insert_pos += 1\n    \n    return insert_pos",
        "javascript": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    \n    let insertPos = 1; // Position to insert next unique element\n    \n    for (let i = 1; i < nums.length; i++) {\n        // If current element is different from previous\n        if (nums[i] !== nums[i - 1]) {\n            nums[insertPos] = nums[i];\n            insertPos++;\n        }\n    }\n    \n    return insertPos;\n}"
      }
    },
    {
      "name": "Two Pointers - Alternative",
      "order": 3,
      "intuition": "Compare current element with the last unique element placed, rather than with previous element.",
      "approach": "Use one pointer to track unique elements and compare with it directly.",
      "steps": [
        "Handle edge case: if array is empty, return 0",
        "Initialize uniqueIndex at 0 (first element is always unique)",
        "For each element from index 1:",
        "  If nums[i] != nums[uniqueIndex]:",
        "    Increment uniqueIndex",
        "    Place nums[i] at nums[uniqueIndex]",
        "Return uniqueIndex + 1 (count of unique elements)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through the array",
        "spaceExplanation": "Only one pointer variable used"
      },
      "code": {
        "cpp": "int removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    int uniqueIndex = 0;\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] != nums[uniqueIndex]) {\n            uniqueIndex++;\n            nums[uniqueIndex] = nums[i];\n        }\n    }\n    \n    return uniqueIndex + 1;\n}",
        "java": "public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    \n    int uniqueIndex = 0;\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] != nums[uniqueIndex]) {\n            uniqueIndex++;\n            nums[uniqueIndex] = nums[i];\n        }\n    }\n    \n    return uniqueIndex + 1;\n}",
        "python": "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    unique_index = 0\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[unique_index]:\n            unique_index += 1\n            nums[unique_index] = nums[i]\n    \n    return unique_index + 1",
        "javascript": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    \n    let uniqueIndex = 0;\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] !== nums[uniqueIndex]) {\n            uniqueIndex++;\n            nums[uniqueIndex] = nums[i];\n        }\n    }\n    \n    return uniqueIndex + 1;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Returning the wrong count (forgetting to add 1 when using 0-based index)",
    "Not handling empty array edge case",
    "Trying to remove elements instead of overwriting them in-place",
    "Comparing with wrong element (should compare with previous or last unique)",
    "Modifying the array length instead of just overwriting values"
  ],
  "hints": [
    "The array is already sorted, so duplicates will be adjacent",
    "You don't need to actually remove elements, just overwrite them",
    "Keep track of where to place the next unique element",
    "The first element is always unique"
  ],
  "followUp": [
    "What if the array is not sorted?",
    "How would you allow at most 2 duplicates of each element?",
    "Can you do this for a linked list?",
    "What if you need to preserve the original order but remove all duplicates entirely?"
  ],
  "companies": [
    "Facebook",
    "Microsoft",
    "Amazon",
    "Google",
    "Apple",
    "Bloomberg"
  ],
  "tags": [
    "Array",
    "Two Pointers"
  ],
  "relatedProblems": [
    "Remove Duplicates from Sorted Array II",
    "Remove Element",
    "Remove Duplicates from Sorted List"
  ]
}
