{
  "questionId": "694d4a3a98494915f3bc8e7a",
  "questionSlug": "remove-duplicates",
  "title": "Remove Duplicates",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
    "videos": [
      {
        "title": "Remove Duplicates from Sorted Array - Leetcode 26",
        "url": "https://www.youtube.com/watch?v=DEJAZBq0FDA",
        "channel": "NeetCode",
        "duration": "7:18",
        "language": "English"
      },
      {
        "title": "Two Pointer Approach Explained",
        "url": "https://www.youtube.com/watch?v=Fm_p9lJ4Z_8",
        "channel": "takeUforward",
        "duration": "10:25",
        "language": "English"
      },
      {
        "title": "Remove Duplicates In-Place | Two Pointers",
        "url": "https://www.youtube.com/watch?v=wT7gcXLFr5M",
        "channel": "Kevin Naughton Jr.",
        "duration": "6:42",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Remove Duplicates from Sorted Array Solution",
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solution/",
        "source": "LeetCode Editorial"
      },
      {
        "title": "Two Pointers Technique - Complete Guide",
        "url": "https://leetcode.com/discuss/study-guide/1688903/solved-all-two-pointers-problems-in-100-days",
        "source": "LeetCode Discuss"
      },
      {
        "title": "In-Place Array Modification Patterns",
        "url": "https://www.geeksforgeeks.org/remove-duplicates-sorted-array/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Remove Duplicates from Sorted Array II",
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/",
        "platform": "LeetCode"
      },
      {
        "title": "Remove Element",
        "url": "https://leetcode.com/problems/remove-element/",
        "platform": "LeetCode"
      },
      {
        "title": "Move Zeroes",
        "url": "https://leetcode.com/problems/move-zeroes/",
        "platform": "LeetCode"
      },
      {
        "title": "Remove Duplicates from Sorted List",
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Two Pointers when you need to modify an array in-place, especially when dealing with sorted arrays and removing/replacing elements. Keywords: 'remove duplicates', 'in-place', 'sorted array', 'modify array'.",
  "approaches": [
    {
      "name": "Brute Force - Extra Space",
      "order": 1,
      "intuition": "Use extra space to store unique elements, then copy them back to the original array. Simple but not optimal for space.",
      "approach": "Create a new array or list to store unique elements, then overwrite the original array.",
      "steps": [
        "Create a temporary array or list",
        "Iterate through the original array",
        "Add only unique elements to the temporary storage",
        "Copy elements from temporary storage back to original array",
        "Return the count of unique elements"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass through the array: O(n).",
        "spaceExplanation": "Extra array to store unique elements: O(n) in worst case."
      },
      "code": {
        "cpp": "int removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    vector<int> unique;\n    unique.push_back(nums[0]);\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] != nums[i - 1]) {\n            unique.push_back(nums[i]);\n        }\n    }\n    \n    for (int i = 0; i < unique.size(); i++) {\n        nums[i] = unique[i];\n    }\n    \n    return unique.size();\n}",
        "java": "public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    \n    List<Integer> unique = new ArrayList<>();\n    unique.add(nums[0]);\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] != nums[i - 1]) {\n            unique.add(nums[i]);\n        }\n    }\n    \n    for (int i = 0; i < unique.size(); i++) {\n        nums[i] = unique.get(i);\n    }\n    \n    return unique.size();\n}",
        "python": "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    unique = [nums[0]]\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1]:\n            unique.append(nums[i])\n    \n    for i in range(len(unique)):\n        nums[i] = unique[i]\n    \n    return len(unique)",
        "javascript": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    \n    const unique = [nums[0]];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] !== nums[i - 1]) {\n            unique.push(nums[i]);\n        }\n    }\n    \n    for (let i = 0; i < unique.length; i++) {\n        nums[i] = unique[i];\n    }\n    \n    return unique.length;\n}"
      }
    },
    {
      "name": "Two Pointers (Optimal)",
      "order": 2,
      "intuition": "Use one pointer to track the position of unique elements and another to scan through the array. This is the optimal O(1) space solution.",
      "approach": "Keep a slow pointer for the position of unique elements and a fast pointer to scan through the array.",
      "steps": [
        "Handle edge case: if array is empty, return 0",
        "Initialize slow pointer (insertPos) at index 1",
        "Initialize fast pointer at index 1",
        "While fast < array length:",
        "  If nums[fast] != nums[fast-1] (found new unique element):",
        "    Place nums[fast] at nums[insertPos]",
        "    Increment insertPos",
        "  Increment fast",
        "Return insertPos (count of unique elements)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through the array: O(n).",
        "spaceExplanation": "Only two pointer variables used, in-place modification: O(1)."
      },
      "code": {
        "cpp": "int removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    int insertPos = 1; // Position to insert next unique element\n    \n    for (int i = 1; i < nums.size(); i++) {\n        // If current element is different from previous\n        if (nums[i] != nums[i - 1]) {\n            nums[insertPos] = nums[i];\n            insertPos++;\n        }\n    }\n    \n    return insertPos;\n}",
        "java": "public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    \n    int insertPos = 1; // Position to insert next unique element\n    \n    for (int i = 1; i < nums.length; i++) {\n        // If current element is different from previous\n        if (nums[i] != nums[i - 1]) {\n            nums[insertPos] = nums[i];\n            insertPos++;\n        }\n    }\n    \n    return insertPos;\n}",
        "python": "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    insert_pos = 1  # Position to insert next unique element\n    \n    for i in range(1, len(nums)):\n        # If current element is different from previous\n        if nums[i] != nums[i - 1]:\n            nums[insert_pos] = nums[i]\n            insert_pos += 1\n    \n    return insert_pos",
        "javascript": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    \n    let insertPos = 1; // Position to insert next unique element\n    \n    for (let i = 1; i < nums.length; i++) {\n        // If current element is different from previous\n        if (nums[i] !== nums[i - 1]) {\n            nums[insertPos] = nums[i];\n            insertPos++;\n        }\n    }\n    \n    return insertPos;\n}"
      }
    },
    {
      "name": "Two Pointers - Alternative",
      "order": 3,
      "intuition": "Compare current element with the last unique element placed, rather than with previous element. Same efficiency but different comparison logic.",
      "approach": "Use one pointer to track unique elements and compare with it directly.",
      "steps": [
        "Handle edge case: if array is empty, return 0",
        "Initialize uniqueIndex at 0 (first element is always unique)",
        "For each element from index 1:",
        "  If nums[i] != nums[uniqueIndex]:",
        "    Increment uniqueIndex",
        "    Place nums[i] at nums[uniqueIndex]",
        "Return uniqueIndex + 1 (count of unique elements)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through the array: O(n).",
        "spaceExplanation": "Only one pointer variable used: O(1)."
      },
      "code": {
        "cpp": "int removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    int uniqueIndex = 0;\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] != nums[uniqueIndex]) {\n            uniqueIndex++;\n            nums[uniqueIndex] = nums[i];\n        }\n    }\n    \n    return uniqueIndex + 1;\n}",
        "java": "public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    \n    int uniqueIndex = 0;\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] != nums[uniqueIndex]) {\n            uniqueIndex++;\n            nums[uniqueIndex] = nums[i];\n        }\n    }\n    \n    return uniqueIndex + 1;\n}",
        "python": "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    unique_index = 0\n    \n    for i in range(1, len(nums)):\n        if nums[i] != nums[unique_index]:\n            unique_index += 1\n            nums[unique_index] = nums[i]\n    \n    return unique_index + 1",
        "javascript": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    \n    let uniqueIndex = 0;\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] !== nums[uniqueIndex]) {\n            uniqueIndex++;\n            nums[uniqueIndex] = nums[i];\n        }\n    }\n    \n    return uniqueIndex + 1;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Returning the wrong count (forgetting to add 1 when using 0-based index)",
    "Not handling empty array edge case",
    "Trying to remove elements instead of overwriting them in-place",
    "Comparing with wrong element (should compare with previous or last unique)",
    "Modifying the array length instead of just overwriting values",
    "Starting loop from index 0 instead of 1",
    "Using <= instead of < in loop condition",
    "Confusing insertPos with the actual count (off-by-one error)"
  ],
  "hints": [
    "The array is already sorted, so duplicates will be adjacent",
    "You don't need to actually remove elements, just overwrite them",
    "Keep track of where to place the next unique element",
    "The first element is always unique",
    "Think about maintaining a 'clean' section at the start of the array",
    "Each unique element should appear exactly once in the result",
    "The relative order of elements must be preserved",
    "Elements beyond the returned length don't matter"
  ],
  "followUp": [
    "What if the array is not sorted?",
    "How would you allow at most 2 duplicates of each element?",
    "Can you do this for a linked list?",
    "What if you need to preserve the original order but remove all duplicates entirely?",
    "How would you handle this if the array contains objects instead of primitives?",
    "Can you solve this recursively?",
    "What if you need to count how many duplicates were removed?",
    "How would you optimize for arrays with very few duplicates?"
  ],
  "companies": [
    "Facebook",
    "Microsoft",
    "Amazon",
    "Google",
    "Apple",
    "Bloomberg",
    "Adobe",
    "LinkedIn",
    "Uber",
    "Oracle"
  ],
  "tags": [
    "Array",
    "Two Pointers",
    "In-Place"
  ],
  "relatedProblems": [
    "Remove Duplicates from Sorted Array II",
    "Remove Element",
    "Remove Duplicates from Sorted List",
    "Move Zeroes",
    "Remove Duplicates from Unsorted Array",
    "Partition Array",
    "Find the Duplicate Number"
  ]
}