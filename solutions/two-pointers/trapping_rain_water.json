{
  "questionId": "42",
  "questionSlug": "trapping-rain-water",
  "title": "Trapping Rain Water",
  "difficulty": "Hard",
  "resources": {
    "leetcode": "https://leetcode.com/problems/trapping-rain-water/",
    "videos": [
      {
        "title": "Trapping Rain Water - Leetcode 42",
        "url": "https://www.youtube.com/watch?v=ZI2z5pq0TqA",
        "channel": "NeetCode",
        "duration": "13:22",
        "language": "English"
      },
      {
        "title": "L10. Trapping Rainwater",
        "url": "https://www.youtube.com/watch?v=m18Hntz4go8",
        "channel": "take U forward",
        "duration": "19:45",
        "language": "English"
      },
      {
        "title": "Trapping Rain Water Solution",
        "url": "https://www.youtube.com/watch?v=HmBbcDiJapY",
        "channel": "Kevin Naughton Jr.",
        "duration": "12:15",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Trapping Rain Water - LeetCode Solution",
        "url": "https://leetcode.com/problems/trapping-rain-water/solution/",
        "source": "LeetCode Official"
      },
      {
        "title": "Trapping Rainwater Problem",
        "url": "https://takeuforward.org/data-structure/trapping-rainwater/",
        "source": "takeuforward"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/trapping-rain-water/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Calculate trapped water = Track max heights from both sides. Water level at position = min(leftMax, rightMax) - height[i].",
  "approaches": [
    {
      "name": "Brute Force (For Each Position)",
      "order": 1,
      "intuition": "For each position, find maximum height on left and right. Water trapped = min(leftMax, rightMax) - current height.",
      "approach": "For every index, scan left and right to find maximum heights, then calculate water at that position.",
      "steps": [
        "Initialize totalWater = 0",
        "Iterate i from 0 to n-1:",
        "  Find leftMax by scanning from 0 to i",
        "  Find rightMax by scanning from i to n-1",
        "  water = min(leftMax, rightMax) - height[i]",
        "  If water > 0, add to totalWater",
        "Return totalWater"
      ],
      "complexity": {
        "time": "O(nÂ²)",
        "space": "O(1)",
        "timeExplanation": "For each position, scan entire array left and right",
        "spaceExplanation": "Only using variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n == 0) return 0;\n        \n        int totalWater = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int leftMax = 0;\n            for (int j = 0; j <= i; j++) {\n                leftMax = max(leftMax, height[j]);\n            }\n            \n            int rightMax = 0;\n            for (int j = i; j < n; j++) {\n                rightMax = max(rightMax, height[j]);\n            }\n            \n            int water = min(leftMax, rightMax) - height[i];\n            if (water > 0) {\n                totalWater += water;\n            }\n        }\n        \n        return totalWater;\n    }\n};",
        "java": "class Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        if (n == 0) return 0;\n        \n        int totalWater = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int leftMax = 0;\n            for (int j = 0; j <= i; j++) {\n                leftMax = Math.max(leftMax, height[j]);\n            }\n            \n            int rightMax = 0;\n            for (int j = i; j < n; j++) {\n                rightMax = Math.max(rightMax, height[j]);\n            }\n            \n            int water = Math.min(leftMax, rightMax) - height[i];\n            if (water > 0) {\n                totalWater += water;\n            }\n        }\n        \n        return totalWater;\n    }\n}",
        "python": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n == 0:\n            return 0\n        \n        total_water = 0\n        \n        for i in range(n):\n            left_max = max(height[0:i+1])\n            right_max = max(height[i:])\n            \n            water = min(left_max, right_max) - height[i]\n            if water > 0:\n                total_water += water\n        \n        return total_water",
        "javascript": "var trap = function(height) {\n    const n = height.length;\n    if (n === 0) return 0;\n    \n    let totalWater = 0;\n    \n    for (let i = 0; i < n; i++) {\n        let leftMax = 0;\n        for (let j = 0; j <= i; j++) {\n            leftMax = Math.max(leftMax, height[j]);\n        }\n        \n        let rightMax = 0;\n        for (let j = i; j < n; j++) {\n            rightMax = Math.max(rightMax, height[j]);\n        }\n        \n        const water = Math.min(leftMax, rightMax) - height[i];\n        if (water > 0) {\n            totalWater += water;\n        }\n    }\n    \n    return totalWater;\n};"
      }
    },
    {
      "name": "Better (Precompute Max Arrays)",
      "order": 2,
      "intuition": "Precompute maximum heights from left and right for each position to avoid repeated calculations.",
      "approach": "Create two arrays: leftMax[i] = max height from 0 to i, rightMax[i] = max height from i to n-1.",
      "steps": [
        "Create leftMax array of size n",
        "Fill leftMax: leftMax[i] = max(leftMax[i-1], height[i])",
        "Create rightMax array of size n",
        "Fill rightMax: rightMax[i] = max(rightMax[i+1], height[i])",
        "Calculate water at each position:",
        "  water[i] = min(leftMax[i], rightMax[i]) - height[i]",
        "Return sum of all water"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Three passes through array",
        "spaceExplanation": "Two arrays of size n for leftMax and rightMax"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n == 0) return 0;\n        \n        vector<int> leftMax(n);\n        vector<int> rightMax(n);\n        \n        leftMax[0] = height[0];\n        for (int i = 1; i < n; i++) {\n            leftMax[i] = max(leftMax[i - 1], height[i]);\n        }\n        \n        rightMax[n - 1] = height[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            rightMax[i] = max(rightMax[i + 1], height[i]);\n        }\n        \n        int totalWater = 0;\n        for (int i = 0; i < n; i++) {\n            int water = min(leftMax[i], rightMax[i]) - height[i];\n            totalWater += water;\n        }\n        \n        return totalWater;\n    }\n};",
        "java": "class Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        if (n == 0) return 0;\n        \n        int[] leftMax = new int[n];\n        int[] rightMax = new int[n];\n        \n        leftMax[0] = height[0];\n        for (int i = 1; i < n; i++) {\n            leftMax[i] = Math.max(leftMax[i - 1], height[i]);\n        }\n        \n        rightMax[n - 1] = height[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            rightMax[i] = Math.max(rightMax[i + 1], height[i]);\n        }\n        \n        int totalWater = 0;\n        for (int i = 0; i < n; i++) {\n            int water = Math.min(leftMax[i], rightMax[i]) - height[i];\n            totalWater += water;\n        }\n        \n        return totalWater;\n    }\n}",
        "python": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n == 0:\n            return 0\n        \n        left_max = [0] * n\n        right_max = [0] * n\n        \n        left_max[0] = height[0]\n        for i in range(1, n):\n            left_max[i] = max(left_max[i - 1], height[i])\n        \n        right_max[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            right_max[i] = max(right_max[i + 1], height[i])\n        \n        total_water = 0\n        for i in range(n):\n            water = min(left_max[i], right_max[i]) - height[i]\n            total_water += water\n        \n        return total_water",
        "javascript": "var trap = function(height) {\n    const n = height.length;\n    if (n === 0) return 0;\n    \n    const leftMax = new Array(n);\n    const rightMax = new Array(n);\n    \n    leftMax[0] = height[0];\n    for (let i = 1; i < n; i++) {\n        leftMax[i] = Math.max(leftMax[i - 1], height[i]);\n    }\n    \n    rightMax[n - 1] = height[n - 1];\n    for (let i = n - 2; i >= 0; i--) {\n        rightMax[i] = Math.max(rightMax[i + 1], height[i]);\n    }\n    \n    let totalWater = 0;\n    for (let i = 0; i < n; i++) {\n        const water = Math.min(leftMax[i], rightMax[i]) - height[i];\n        totalWater += water;\n    }\n    \n    return totalWater;\n};"
      }
    },
    {
      "name": "Two Pointers - Optimal",
      "order": 3,
      "intuition": "Use two pointers from both ends. Move pointer with smaller max height. Water at current position depends on smaller of two max heights.",
      "approach": "Maintain leftMax and rightMax while moving pointers inward. Calculate water based on smaller max.",
      "steps": [
        "Initialize left = 0, right = n-1",
        "Initialize leftMax = 0, rightMax = 0, totalWater = 0",
        "While left < right:",
        "  If height[left] < height[right]:",
        "    If height[left] >= leftMax: update leftMax",
        "    Else: add (leftMax - height[left]) to water",
        "    Move left++",
        "  Else:",
        "    If height[right] >= rightMax: update rightMax",
        "    Else: add (rightMax - height[right]) to water",
        "    Move right--",
        "Return totalWater"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass with two pointers",
        "spaceExplanation": "Only using pointer variables and counters"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n == 0) return 0;\n        \n        int left = 0, right = n - 1;\n        int leftMax = 0, rightMax = 0;\n        int totalWater = 0;\n        \n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    totalWater += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    totalWater += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        \n        return totalWater;\n    }\n};",
        "java": "class Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        if (n == 0) return 0;\n        \n        int left = 0, right = n - 1;\n        int leftMax = 0, rightMax = 0;\n        int totalWater = 0;\n        \n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    totalWater += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    totalWater += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        \n        return totalWater;\n    }\n}",
        "python": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n == 0:\n            return 0\n        \n        left, right = 0, n - 1\n        left_max, right_max = 0, 0\n        total_water = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                if height[left] >= left_max:\n                    left_max = height[left]\n                else:\n                    total_water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] >= right_max:\n                    right_max = height[right]\n                else:\n                    total_water += right_max - height[right]\n                right -= 1\n        \n        return total_water",
        "javascript": "var trap = function(height) {\n    const n = height.length;\n    if (n === 0) return 0;\n    \n    let left = 0, right = n - 1;\n    let leftMax = 0, rightMax = 0;\n    let totalWater = 0;\n    \n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) {\n                leftMax = height[left];\n            } else {\n                totalWater += leftMax - height[left];\n            }\n            left++;\n        } else {\n            if (height[right] >= rightMax) {\n                rightMax = height[right];\n            } else {\n                totalWater += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n    \n    return totalWater;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not understanding water level depends on min of left and right max",
    "Forgetting to handle edge cases (empty array, single element)",
    "Wrong pointer movement logic in two pointer approach",
    "Not considering that water can only be trapped between bars"
  ],
  "hints": [
    "Water at position i = min(maxLeft, maxRight) - height[i]",
    "Precompute max heights to optimize",
    "Two pointers: move from side with smaller max",
    "Water level limited by smaller boundary"
  ],
  "followUp": [
    "What if bars have different widths?",
    "Can you solve in one pass without extra space?",
    "3D version: trapping rain water in 2D grid?",
    "What if you need to minimize cost to trap certain amount of water?"
  ],
  "companies": ["Amazon", "Google", "Facebook", "Microsoft", "Apple", "Bloomberg"],
  "tags": ["array", "two-pointers", "dynamic-programming", "stack"],
  "relatedProblems": [
    "Container With Most Water",
    "Product of Array Except Self",
    "Trapping Rain Water II"
  ]
}
