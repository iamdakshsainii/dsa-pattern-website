{
  "questionId": "125",
  "questionSlug": "valid-palindrome",
  "title": "Valid Palindrome",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/valid-palindrome/",
    "videos": [
      {
        "title": "Valid Palindrome - Leetcode 125",
        "url": "https://www.youtube.com/watch?v=jJXJ16kPFWg",
        "channel": "NeetCode",
        "duration": "7:02",
        "language": "English"
      },
      {
        "title": "Valid Palindrome Solution",
        "url": "https://www.youtube.com/watch?v=rYyn9Vc-dCA",
        "channel": "Kevin Naughton Jr.",
        "duration": "5:15",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Valid Palindrome - LeetCode Solution",
        "url": "https://leetcode.com/problems/valid-palindrome/solution/",
        "source": "LeetCode Official"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/valid-palindrome/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "String comparison from ends + palindrome = Two Pointers. Compare characters from both ends, skip non-alphanumeric.",
  "approaches": [
    {
      "name": "Brute Force (Create Filtered String)",
      "order": 1,
      "intuition": "Filter out non-alphanumeric characters, convert to lowercase, then check if string equals its reverse.",
      "approach": "Build new string with only alphanumeric characters in lowercase, then compare with reversed version.",
      "steps": [
        "Create empty filtered string",
        "Iterate through original string:",
        "  If character is alphanumeric:",
        "    Add lowercase version to filtered string",
        "Reverse the filtered string",
        "Compare filtered with reversed",
        "Return true if equal, false otherwise"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass to filter + O(n) to reverse",
        "spaceExplanation": "Filtered string and reversed string storage"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        string filtered = \"\";\n        \n        for (char c : s) {\n            if (isalnum(c)) {\n                filtered += tolower(c);\n            }\n        }\n        \n        string reversed = filtered;\n        reverse(reversed.begin(), reversed.end());\n        \n        return filtered == reversed;\n    }\n};",
        "java": "class Solution {\n    public boolean isPalindrome(String s) {\n        StringBuilder filtered = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetterOrDigit(c)) {\n                filtered.append(Character.toLowerCase(c));\n            }\n        }\n        \n        String filteredStr = filtered.toString();\n        String reversed = filtered.reverse().toString();\n        \n        return filteredStr.equals(reversed);\n    }\n}",
        "python": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        filtered = ''.join(c.lower() for c in s if c.isalnum())\n        return filtered == filtered[::-1]",
        "javascript": "var isPalindrome = function(s) {\n    const filtered = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    const reversed = filtered.split('').reverse().join('');\n    return filtered === reversed;\n};"
      }
    },
    {
      "name": "Better (Two Pointers with Filtering)",
      "order": 2,
      "intuition": "Create filtered string first, then use two pointers to check palindrome without reversing.",
      "approach": "Filter to alphanumeric lowercase, then use two pointers from both ends to compare.",
      "steps": [
        "Create filtered string with only alphanumeric lowercase",
        "Initialize left = 0, right = filtered.length - 1",
        "While left < right:",
        "  If filtered[left] != filtered[right]:",
        "    Return false",
        "  Increment left, decrement right",
        "Return true"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "O(n) to filter + O(n) to check palindrome",
        "spaceExplanation": "Filtered string storage"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        string filtered = \"\";\n        \n        for (char c : s) {\n            if (isalnum(c)) {\n                filtered += tolower(c);\n            }\n        }\n        \n        int left = 0, right = filtered.length() - 1;\n        \n        while (left < right) {\n            if (filtered[left] != filtered[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n};",
        "java": "class Solution {\n    public boolean isPalindrome(String s) {\n        StringBuilder filtered = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetterOrDigit(c)) {\n                filtered.append(Character.toLowerCase(c));\n            }\n        }\n        \n        int left = 0, right = filtered.length() - 1;\n        \n        while (left < right) {\n            if (filtered.charAt(left) != filtered.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "python": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        filtered = ''.join(c.lower() for c in s if c.isalnum())\n        \n        left, right = 0, len(filtered) - 1\n        \n        while left < right:\n            if filtered[left] != filtered[right]:\n                return False\n            left += 1\n            right -= 1\n        \n        return True",
        "javascript": "var isPalindrome = function(s) {\n    const filtered = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    \n    let left = 0, right = filtered.length - 1;\n    \n    while (left < right) {\n        if (filtered[left] !== filtered[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n};"
      }
    },
    {
      "name": "Two Pointers - Optimal (In-Place)",
      "order": 3,
      "intuition": "Palindrome reads same forwards and backwards. Use two pointers from ends, skip non-alphanumeric on the fly, compare case-insensitive.",
      "approach": "Left pointer starts at beginning, right at end. Skip invalid characters dynamically, compare lowercase versions.",
      "steps": [
        "Initialize left = 0, right = s.length - 1",
        "While left < right:",
        "  Skip non-alphanumeric from left",
        "  Skip non-alphanumeric from right",
        "  Compare lowercase s[left] with lowercase s[right]",
        "  If not equal, return false",
        "  Move both pointers inward",
        "Return true"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through string",
        "spaceExplanation": "Only using two pointer variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            while (left < right && !isalnum(s[left])) left++;\n            while (left < right && !isalnum(s[right])) right--;\n            \n            if (tolower(s[left]) != tolower(s[right])) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n};",
        "java": "class Solution {\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            \n            if (Character.toLowerCase(s.charAt(left)) != \n                Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "python": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n        \n        while left < right:\n            while left < right and not s[left].isalnum():\n                left += 1\n            while left < right and not s[right].isalnum():\n                right -= 1\n            \n            if s[left].lower() != s[right].lower():\n                return False\n            \n            left += 1\n            right -= 1\n        \n        return True",
        "javascript": "var isPalindrome = function(s) {\n    let left = 0, right = s.length - 1;\n    \n    const isAlphaNumeric = (char) => {\n        return /[a-zA-Z0-9]/.test(char);\n    };\n    \n    while (left < right) {\n        while (left < right && !isAlphaNumeric(s[left])) left++;\n        while (left < right && !isAlphaNumeric(s[right])) right--;\n        \n        if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n            return false;\n        }\n        \n        left++;\n        right--;\n    }\n    \n    return true;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling non-alphanumeric characters properly",
    "Case-sensitive comparison",
    "Creating filtered string (uses extra space)",
    "Not checking left < right in while loops for skipping",
    "Comparing characters before converting to lowercase"
  ],
  "hints": [
    "Ignore non-alphanumeric characters",
    "Convert to same case before comparing",
    "Two pointers avoid creating new string",
    "Skip invalid characters on the fly for O(1) space"
  ],
  "followUp": [
    "What if only one character deletion allowed? (Valid Palindrome II)",
    "What about palindrome phrases ignoring spaces?",
    "Can you handle Unicode characters?",
    "What if you need to count palindromic substrings?"
  ],
  "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google", "Bloomberg"],
  "tags": ["two-pointers", "string"],
  "relatedProblems": [
    "Valid Palindrome II",
    "Palindrome Linked List",
    "Palindrome Number",
    "Longest Palindromic Substring"
  ]
}
