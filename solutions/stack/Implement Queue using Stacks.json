{
  "questionId": "232",
  "questionSlug": "implement-queue-using-stacks",
  "title": "Implement Queue using Stacks",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/implement-queue-using-stacks/",
    "videos": [
      {
        "title": "Implement Queue using Stacks",
        "url": "https://www.youtube.com/watch?v=eanwa3ht3YQ",
        "channel": "NeetCode",
        "duration": "8:30",
        "language": "English"
      },
      {
        "title": "Queue using Two Stacks",
        "url": "https://www.youtube.com/watch?v=ht_JuPq2JJw",
        "channel": "Kevin Naughton Jr.",
        "duration": "10:15",
        "language": "English"
      },
      {
        "title": "Queue Implementation with Stacks",
        "url": "https://www.youtube.com/watch?v=SPeeXYShB5I",
        "channel": "take U forward",
        "duration": "12:40",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Implement Queue using Stacks - LeetCode Official",
        "url": "https://leetcode.com/problems/implement-queue-using-stacks/editorial/",
        "source": "LeetCode"
      },
      {
        "title": "Queue using Stacks",
        "url": "https://takeuforward.org/data-structure/implement-queue-using-stack/",
        "source": "takeuforward"
      },
      {
        "title": "Queue using Stacks - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/queue-using-stacks/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/implement-queue-using-stacks/",
        "platform": "LeetCode"
      },
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://practice.geeksforgeeks.org/problems/queue-using-two-stacks/",
        "platform": "GeeksforGeeks"
      }
    ]
  },
  "patternTriggers": "Queue (FIFO) from Stacks (LIFO) = Two stacks. One for enqueue (input), one for dequeue (output). Transfer when output empty.",
  "approaches": [
    {
      "name": "Single Stack - Move Elements Every Operation",
      "order": 1,
      "intuition": "Use single stack plus temporary stack. For dequeue, move all elements to temp, pop, move back.",
      "approach": "All operations require moving elements between stacks to maintain order.",
      "steps": [
        "push(x):",
        "  Move all to temp",
        "  Push x",
        "  Move all back",
        "pop():",
        "  Simply pop from stack",
        "peek():",
        "  Return top of stack"
      ],
      "complexity": {
        "time": "O(n) push, O(1) pop/peek",
        "space": "O(n)",
        "timeExplanation": "Push requires moving all n elements twice",
        "spaceExplanation": "Two stacks storing elements"
      },
      "code": {
        "cpp": "class MyQueue {\nprivate:\n    stack<int> s1;\n    \npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        stack<int> temp;\n        \n        // Move all to temp\n        while (!s1.empty()) {\n            temp.push(s1.top());\n            s1.pop();\n        }\n        \n        // Push new element\n        s1.push(x);\n        \n        // Move back\n        while (!temp.empty()) {\n            s1.push(temp.top());\n            temp.pop();\n        }\n    }\n    \n    int pop() {\n        int top = s1.top();\n        s1.pop();\n        return top;\n    }\n    \n    int peek() {\n        return s1.top();\n    }\n    \n    bool empty() {\n        return s1.empty();\n    }\n};",
        "java": "class MyQueue {\n    private Stack<Integer> s1;\n    \n    public MyQueue() {\n        s1 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        Stack<Integer> temp = new Stack<>();\n        \n        while (!s1.isEmpty()) {\n            temp.push(s1.pop());\n        }\n        \n        s1.push(x);\n        \n        while (!temp.isEmpty()) {\n            s1.push(temp.pop());\n        }\n    }\n    \n    public int pop() {\n        return s1.pop();\n    }\n    \n    public int peek() {\n        return s1.peek();\n    }\n    \n    public boolean empty() {\n        return s1.isEmpty();\n    }\n}",
        "python": "class MyQueue:\n    def __init__(self):\n        self.s1 = []\n    \n    def push(self, x: int) -> None:\n        temp = []\n        \n        while self.s1:\n            temp.append(self.s1.pop())\n        \n        self.s1.append(x)\n        \n        while temp:\n            self.s1.append(temp.pop())\n    \n    def pop(self) -> int:\n        return self.s1.pop()\n    \n    def peek(self) -> int:\n        return self.s1[-1]\n    \n    def empty(self) -> bool:\n        return len(self.s1) == 0",
        "javascript": "var MyQueue = function() {\n    this.s1 = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    const temp = [];\n    \n    while (this.s1.length > 0) {\n        temp.push(this.s1.pop());\n    }\n    \n    this.s1.push(x);\n    \n    while (temp.length > 0) {\n        this.s1.push(temp.pop());\n    }\n};\n\nMyQueue.prototype.pop = function() {\n    return this.s1.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    return this.s1[this.s1.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.s1.length === 0;\n};"
      }
    },
    {
      "name": "Two Stacks - Transfer on Pop - Better",
      "order": 2,
      "intuition": "Use input stack for push, output stack for pop. Only transfer from input to output when output is empty.",
      "approach": "Push always to input. Pop/peek transfer if needed. Amortizes cost over operations.",
      "steps": [
        "push(x): s1.push(x)",
        "pop():",
        "  If s2 empty: move all from s1 to s2",
        "  Return s2.pop()",
        "peek():",
        "  If s2 empty: move all from s1 to s2",
        "  Return s2.top()",
        "empty(): return s1.empty() && s2.empty()"
      ],
      "complexity": {
        "time": "O(1) push, O(1) amortized pop/peek",
        "space": "O(n)",
        "timeExplanation": "Each element moved at most twice (s1→s2, then popped)",
        "spaceExplanation": "Two stacks store all elements"
      },
      "code": {
        "cpp": "class MyQueue {\nprivate:\n    stack<int> input;\n    stack<int> output;\n    \n    void transfer() {\n        while (!input.empty()) {\n            output.push(input.top());\n            input.pop();\n        }\n    }\n    \npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        input.push(x);\n    }\n    \n    int pop() {\n        if (output.empty()) {\n            transfer();\n        }\n        int top = output.top();\n        output.pop();\n        return top;\n    }\n    \n    int peek() {\n        if (output.empty()) {\n            transfer();\n        }\n        return output.top();\n    }\n    \n    bool empty() {\n        return input.empty() && output.empty();\n    }\n};",
        "java": "class MyQueue {\n    private Stack<Integer> input;\n    private Stack<Integer> output;\n    \n    public MyQueue() {\n        input = new Stack<>();\n        output = new Stack<>();\n    }\n    \n    private void transfer() {\n        while (!input.isEmpty()) {\n            output.push(input.pop());\n        }\n    }\n    \n    public void push(int x) {\n        input.push(x);\n    }\n    \n    public int pop() {\n        if (output.isEmpty()) {\n            transfer();\n        }\n        return output.pop();\n    }\n    \n    public int peek() {\n        if (output.isEmpty()) {\n            transfer();\n        }\n        return output.peek();\n    }\n    \n    public boolean empty() {\n        return input.isEmpty() && output.isEmpty();\n    }\n}",
        "python": "class MyQueue:\n    def __init__(self):\n        self.input = []\n        self.output = []\n    \n    def _transfer(self):\n        while self.input:\n            self.output.append(self.input.pop())\n    \n    def push(self, x: int) -> None:\n        self.input.append(x)\n    \n    def pop(self) -> int:\n        if not self.output:\n            self._transfer()\n        return self.output.pop()\n    \n    def peek(self) -> int:\n        if not self.output:\n            self._transfer()\n        return self.output[-1]\n    \n    def empty(self) -> bool:\n        return len(self.input) == 0 and len(self.output) == 0",
        "javascript": "var MyQueue = function() {\n    this.input = [];\n    this.output = [];\n};\n\nMyQueue.prototype.transfer = function() {\n    while (this.input.length > 0) {\n        this.output.push(this.input.pop());\n    }\n};\n\nMyQueue.prototype.push = function(x) {\n    this.input.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (this.output.length === 0) {\n        this.transfer();\n    }\n    return this.output.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (this.output.length === 0) {\n        this.transfer();\n    }\n    return this.output[this.output.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.input.length === 0 && this.output.length === 0;\n};"
      }
    },
    {
      "name": "Two Stacks - Lazy Transfer - Optimal",
      "order": 3,
      "intuition": "Same as approach 2 but with cleaner code. Only transfer when absolutely needed. Elements stay in output until depleted.",
      "approach": "Identical logic to approach 2, just cleaner implementation. This is the standard optimal solution.",
      "steps": [
        "Maintain input and output stacks",
        "push: always to input stack",
        "pop/peek:",
        "  If output not empty: use output",
        "  Else: transfer all from input to output, then use output",
        "empty: both stacks empty"
      ],
      "complexity": {
        "time": "O(1) push, O(1) amortized pop/peek",
        "space": "O(n)",
        "timeExplanation": "Amortized O(1) - each element pushed once, moved once, popped once",
        "spaceExplanation": "Two stacks total n elements"
      },
      "code": {
        "cpp": "class MyQueue {\nprivate:\n    stack<int> s1; // Input stack\n    stack<int> s2; // Output stack\n    \npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        peek(); // Ensures s2 has elements\n        int top = s2.top();\n        s2.pop();\n        return top;\n    }\n    \n    int peek() {\n        if (s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};",
        "java": "class MyQueue {\n    private Stack<Integer> s1; // Input\n    private Stack<Integer> s2; // Output\n    \n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n}",
        "python": "class MyQueue:\n    def __init__(self):\n        self.s1 = []  # Input\n        self.s2 = []  # Output\n    \n    def push(self, x: int) -> None:\n        self.s1.append(x)\n    \n    def pop(self) -> int:\n        self.peek()\n        return self.s2.pop()\n    \n    def peek(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2[-1]\n    \n    def empty(self) -> bool:\n        return not self.s1 and not self.s2",
        "javascript": "var MyQueue = function() {\n    this.s1 = []; // Input\n    this.s2 = []; // Output\n};\n\nMyQueue.prototype.push = function(x) {\n    this.s1.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    this.peek();\n    return this.s2.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (this.s2.length === 0) {\n        while (this.s1.length > 0) {\n            this.s2.push(this.s1.pop());\n        }\n    }\n    return this.s2[this.s2.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.s1.length === 0 && this.s2.length === 0;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Transferring elements on every operation (too expensive)",
    "Not checking if output stack has elements before transferring",
    "Transferring back to input stack (should only go s1→s2, never back)",
    "Wrong empty() check (must check both stacks)",
    "Forgetting that elements in s2 should be used first before transferring"
  ],
  "hints": [
    "Queue is FIFO (first in, first out), Stack is LIFO (last in, first out)",
    "Two stacks can reverse order twice, getting back to original order",
    "Key insight: don't transfer until you need to",
    "Once in output stack, keep using it until empty",
    "Amortized analysis: each element moved at most once total"
  ],
  "followUp": [
    "Can you do it with one stack? (Requires recursion)",
    "What's the amortized time complexity? How to prove it?",
    "Can you implement with minimum number of transfers?",
    "What if we need to support size() operation efficiently?",
    "How does this compare to circular array implementation?"
  ],
  "companies": ["Microsoft", "Amazon", "Bloomberg", "Adobe", "Oracle"],
  "tags": ["stack", "design", "queue"],
  "relatedProblems": [
    "Implement Stack using Queues",
    "Design Circular Queue",
    "Design Front Middle Back Queue",
    "Moving Average from Data Stream",
    "Design Hit Counter"
  ]
}
