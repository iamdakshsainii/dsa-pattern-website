{
  "questionId": "1209",
  "questionSlug": "remove-all-adjacent-duplicates-in-string-ii",
  "title": "Remove All Adjacent Duplicates in String II",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/",
    "videos": [
      {
        "title": "Remove K Adjacent Duplicates - Stack Solution",
        "url": "https://www.youtube.com/watch?v=w6LcypDgC4w",
        "channel": "NeetCode",
        "duration": "11:45",
        "language": "English"
      },
      {
        "title": "Remove Adjacent Duplicates II",
        "url": "https://www.youtube.com/watch?v=2908LYW_3_M",
        "channel": "take U forward",
        "duration": "15:30",
        "language": "English"
      },
      {
        "title": "Stack with Count - Duplicates Removal",
        "url": "https://www.youtube.com/watch?v=M3cDEUo_l-M",
        "channel": "Pepcoding",
        "duration": "13:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Remove All Adjacent Duplicates II - LeetCode Official",
        "url": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/editorial/",
        "source": "LeetCode"
      },
      {
        "title": "Remove K Adjacent Duplicates",
        "url": "https://takeuforward.org/data-structure/remove-k-adjacent-duplicates/",
        "source": "takeuforward"
      },
      {
        "title": "Remove Duplicates K Times - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/remove-all-adjacent-duplicates-from-a-string-k-times/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Remove K adjacent duplicates = Stack with (char, count) pairs. Increment count if match, pop when count reaches K.",
  "approaches": [
    {
      "name": "Repeated Removal - Brute Force",
      "order": 1,
      "intuition": "Repeatedly scan string, remove first occurrence of K consecutive duplicates, repeat until no more removals possible.",
      "approach": "Keep scanning and removing K duplicates until string stabilizes.",
      "steps": [
        "While changes occur:",
        "  Scan string",
        "  For each position:",
        "    Check if next K chars are same",
        "    If yes: remove them, mark changed",
        "    Break inner loop",
        "Return final string"
      ],
      "complexity": {
        "time": "O(nÂ²/k)",
        "space": "O(n)",
        "timeExplanation": "Multiple passes, each removing K characters",
        "spaceExplanation": "String copies"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    string removeDuplicates(string s, int k) {\n        bool changed = true;\n        \n        while (changed) {\n            changed = false;\n            string temp = \"\";\n            \n            for (int i = 0; i < s.length(); ) {\n                // Check if we have k consecutive duplicates\n                int j = i;\n                while (j < s.length() && s[j] == s[i]) {\n                    j++;\n                }\n                \n                int count = j - i;\n                if (count >= k) {\n                    // Remove k duplicates\n                    count -= k;\n                    changed = true;\n                }\n                \n                // Add remaining characters\n                for (int c = 0; c < count; c++) {\n                    temp += s[i];\n                }\n                \n                i = j;\n            }\n            \n            s = temp;\n        }\n        \n        return s;\n    }\n};",
        "java": "class Solution {\n    public String removeDuplicates(String s, int k) {\n        boolean changed = true;\n        \n        while (changed) {\n            changed = false;\n            StringBuilder temp = new StringBuilder();\n            \n            for (int i = 0; i < s.length(); ) {\n                int j = i;\n                while (j < s.length() && s.charAt(j) == s.charAt(i)) {\n                    j++;\n                }\n                \n                int count = j - i;\n                if (count >= k) {\n                    count -= k;\n                    changed = true;\n                }\n                \n                for (int c = 0; c < count; c++) {\n                    temp.append(s.charAt(i));\n                }\n                \n                i = j;\n            }\n            \n            s = temp.toString();\n        }\n        \n        return s;\n    }\n}",
        "python": "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        changed = True\n        \n        while changed:\n            changed = False\n            temp = []\n            i = 0\n            \n            while i < len(s):\n                j = i\n                while j < len(s) and s[j] == s[i]:\n                    j += 1\n                \n                count = j - i\n                if count >= k:\n                    count -= k\n                    changed = True\n                \n                temp.extend([s[i]] * count)\n                i = j\n            \n            s = ''.join(temp)\n        \n        return s",
        "javascript": "var removeDuplicates = function(s, k) {\n    let changed = true;\n    \n    while (changed) {\n        changed = false;\n        let temp = '';\n        \n        for (let i = 0; i < s.length; ) {\n            let j = i;\n            while (j < s.length && s[j] === s[i]) {\n                j++;\n            }\n            \n            let count = j - i;\n            if (count >= k) {\n                count -= k;\n                changed = true;\n            }\n            \n            temp += s[i].repeat(count);\n            i = j;\n        }\n        \n        s = temp;\n    }\n    \n    return s;\n};"
      }
    },
    {
      "name": "Stack with Count Array",
      "order": 2,
      "intuition": "Use stack for characters and parallel count array. Track consecutive count for each character. Pop when count reaches K.",
      "approach": "Maintain stack and count array in parallel. Increment count when char matches previous, reset otherwise.",
      "steps": [
        "stack = [], counts = []",
        "For each char:",
        "  If stack not empty and stack.top() == char:",
        "    Push char, increment top count",
        "    If count == k: pop k times",
        "  Else:",
        "    Push char with count 1",
        "Return stack as string"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass through string",
        "spaceExplanation": "Stack and count array"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    string removeDuplicates(string s, int k) {\n        vector<char> stack;\n        vector<int> counts;\n        \n        for (char c : s) {\n            if (!stack.empty() && stack.back() == c) {\n                stack.push_back(c);\n                counts.back()++;\n                \n                if (counts.back() == k) {\n                    // Remove k characters\n                    for (int i = 0; i < k; i++) {\n                        stack.pop_back();\n                    }\n                    counts.pop_back();\n                }\n            } else {\n                stack.push_back(c);\n                counts.push_back(1);\n            }\n        }\n        \n        return string(stack.begin(), stack.end());\n    }\n};",
        "java": "class Solution {\n    public String removeDuplicates(String s, int k) {\n        StringBuilder stack = new StringBuilder();\n        int[] counts = new int[s.length()];\n        int top = -1;\n        \n        for (char c : s.toCharArray()) {\n            if (top >= 0 && stack.charAt(top) == c) {\n                stack.append(c);\n                top++;\n                counts[top] = counts[top-1] + 1;\n                \n                if (counts[top] == k) {\n                    stack.delete(stack.length() - k, stack.length());\n                    top -= k;\n                }\n            } else {\n                stack.append(c);\n                top++;\n                counts[top] = 1;\n            }\n        }\n        \n        return stack.toString();\n    }\n}",
        "python": "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        stack = []\n        counts = []\n        \n        for char in s:\n            if stack and stack[-1] == char:\n                stack.append(char)\n                counts[-1] += 1\n                \n                if counts[-1] == k:\n                    for _ in range(k):\n                        stack.pop()\n                    counts.pop()\n            else:\n                stack.append(char)\n                counts.append(1)\n        \n        return ''.join(stack)",
        "javascript": "var removeDuplicates = function(s, k) {\n    const stack = [];\n    const counts = [];\n    \n    for (const char of s) {\n        if (stack.length > 0 && stack[stack.length - 1] === char) {\n            stack.push(char);\n            counts[counts.length - 1]++;\n            \n            if (counts[counts.length - 1] === k) {\n                for (let i = 0; i < k; i++) {\n                    stack.pop();\n                }\n                counts.pop();\n            }\n        } else {\n            stack.push(char);\n            counts.push(1);\n        }\n    }\n    \n    return stack.join('');\n};"
      }
    },
    {
      "name": "Stack with (Char, Count) Pairs - Optimal",
      "order": 3,
      "intuition": "Store (character, count) pairs in stack. Cleaner than parallel arrays. Increment count or add new pair. Pop when count reaches K.",
      "approach": "Stack stores pairs. Update count if top char matches, add new pair otherwise. Remove when count equals K.",
      "steps": [
        "stack = [] // stores (char, count)",
        "For each char:",
        "  If stack not empty and stack.top().char == char:",
        "    Increment stack.top().count",
        "    If count == k: pop",
        "  Else:",
        "    Push (char, 1)",
        "Build result from stack"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass, each char processed once",
        "spaceExplanation": "Stack stores at most n characters"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    string removeDuplicates(string s, int k) {\n        vector<pair<char, int>> stack; // {char, count}\n        \n        for (char c : s) {\n            if (!stack.empty() && stack.back().first == c) {\n                stack.back().second++;\n                if (stack.back().second == k) {\n                    stack.pop_back();\n                }\n            } else {\n                stack.push_back({c, 1});\n            }\n        }\n        \n        // Build result\n        string result = \"\";\n        for (auto [ch, count] : stack) {\n            result += string(count, ch);\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public String removeDuplicates(String s, int k) {\n        Stack<int[]> stack = new Stack<>(); // [char_code, count]\n        \n        for (char c : s.toCharArray()) {\n            if (!stack.isEmpty() && stack.peek()[0] == c) {\n                stack.peek()[1]++;\n                if (stack.peek()[1] == k) {\n                    stack.pop();\n                }\n            } else {\n                stack.push(new int[]{c, 1});\n            }\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (int[] pair : stack) {\n            for (int i = 0; i < pair[1]; i++) {\n                result.append((char) pair[0]);\n            }\n        }\n        \n        return result.toString();\n    }\n}",
        "python": "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        stack = []  # [(char, count)]\n        \n        for char in s:\n            if stack and stack[-1][0] == char:\n                stack[-1] = (char, stack[-1][1] + 1)\n                if stack[-1][1] == k:\n                    stack.pop()\n            else:\n                stack.append((char, 1))\n        \n        return ''.join(char * count for char, count in stack)",
        "javascript": "var removeDuplicates = function(s, k) {\n    const stack = []; // [{char, count}]\n    \n    for (const char of s) {\n        if (stack.length > 0 && stack[stack.length - 1].char === char) {\n            stack[stack.length - 1].count++;\n            if (stack[stack.length - 1].count === k) {\n                stack.pop();\n            }\n        } else {\n            stack.push({char, count: 1});\n        }\n    }\n    \n    return stack.map(({char, count}) => char.repeat(count)).join('');\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling counts correctly (should increment for consecutive chars)",
    "Removing all duplicates instead of exactly K",
    "Not handling cascading removals (removal can create new K duplicates)",
    "Forgetting to reconstruct string from (char, count) pairs",
    "Using wrong data structure (need to track both char and its consecutive count)"
  ],
  "hints": [
    "Extension of Remove Adjacent Duplicates I - track count instead of just presence",
    "Stack with (character, count) pairs is most elegant",
    "Increment count when top char matches current",
    "Pop entire group when count reaches exactly K",
    "Result may have multiple of same char with count < K (keep them all)"
  ],
  "followUp": [
    "What if we can remove any K duplicates (not necessarily adjacent)?",
    "Can you solve with O(1) extra space?",
    "What if K is very large relative to string length?",
    "How to handle streaming input?",
    "What about variable K (different K for different characters)?"
  ],
  "companies": ["Amazon", "Google", "Facebook", "Microsoft", "Bloomberg"],
  "tags": ["string", "stack"],
  "relatedProblems": [
    "Remove All Adjacent Duplicates In String",
    "Remove K Digits",
    "Longest Substring with At Most K Distinct Characters",
    "Crawler Log Folder",
    "Make The String Great"
  ]
}
