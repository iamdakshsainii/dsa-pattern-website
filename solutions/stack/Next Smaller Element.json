{
  "questionId": "GFG-NSE",
  "questionSlug": "next-smaller-element",
  "title": "Next Smaller Element",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/discuss/interview-question/1416548/",
    "videos": [
      {
        "title": "Next Smaller Element using Stack",
        "url": "https://www.youtube.com/watch?v=NXOOYYwpbg4",
        "channel": "Aditya Verma",
        "duration": "15:30",
        "language": "English"
      },
      {
        "title": "Next Smaller Element",
        "url": "https://www.youtube.com/watch?v=R2Vr7_bcvtI",
        "channel": "take U forward",
        "duration": "12:45",
        "language": "English"
      },
      {
        "title": "Monotonic Stack - Next Smaller",
        "url": "https://www.youtube.com/watch?v=T5c1pZu19YI",
        "channel": "Pepcoding",
        "duration": "14:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Next Smaller Element",
        "url": "https://takeuforward.org/data-structure/next-smaller-element-using-stack/",
        "source": "takeuforward"
      },
      {
        "title": "Next Smaller Element - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/next-smaller-element/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Immediate Smaller Element",
        "url": "https://practice.geeksforgeeks.org/problems/immediate-smaller-element/",
        "source": "GeeksforGeeks Practice"
      }
    ],
    "practice": [
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://practice.geeksforgeeks.org/problems/immediate-smaller-element/",
        "platform": "GeeksforGeeks"
      }
    ]
  },
  "patternTriggers": "Find next smaller element = Monotonic increasing stack. Traverse right to left, pop larger elements.",
  "approaches": [
    {
      "name": "Brute Force - Nested Loops",
      "order": 1,
      "intuition": "For each element, scan to the right to find next smaller element.",
      "approach": "For each index, iterate right until finding smaller element or reaching end.",
      "steps": [
        "For i from 0 to n-1:",
        "  result[i] = -1",
        "  For j from i+1 to n-1:",
        "    If arr[j] < arr[i]:",
        "      result[i] = arr[j]",
        "      break",
        "Return result"
      ],
      "complexity": {
        "time": "O(nÂ²)",
        "space": "O(1) excluding output",
        "timeExplanation": "Nested loops, worst case check all elements for each element",
        "spaceExplanation": "Only output array"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> nextSmallerElement(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> result(n, -1);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[i]) {\n                    result[i] = arr[j];\n                    break;\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[] nextSmallerElement(int[] arr) {\n        int n = arr.length;\n        int[] result = new int[n];\n        Arrays.fill(result, -1);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[i]) {\n                    result[i] = arr[j];\n                    break;\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def nextSmallerElement(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        result = [-1] * n\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if arr[j] < arr[i]:\n                    result[i] = arr[j]\n                    break\n        \n        return result",
        "javascript": "var nextSmallerElement = function(arr) {\n    const n = arr.length;\n    const result = new Array(n).fill(-1);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (arr[j] < arr[i]) {\n                result[i] = arr[j];\n                break;\n            }\n        }\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Monotonic Stack - Right to Left",
      "order": 2,
      "intuition": "Use monotonic increasing stack. Elements in stack are candidates for next smaller. Pop larger/equal elements.",
      "approach": "Traverse from right to left, maintain monotonic increasing stack. Top of stack is next smaller.",
      "steps": [
        "Initialize result with -1",
        "Create stack",
        "For i from n-1 to 0:",
        "  While stack not empty and stack.top() >= arr[i]:",
        "    Pop (these are not smaller)",
        "  If stack empty: result[i] = -1",
        "  Else: result[i] = stack.top()",
        "  Push arr[i]",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Each element pushed and popped at most once",
        "spaceExplanation": "Stack can hold up to n elements"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> nextSmallerElement(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> result(n);\n        stack<int> st;\n        \n        // Traverse from right to left\n        for (int i = n - 1; i >= 0; i--) {\n            // Pop larger or equal elements\n            while (!st.empty() && st.top() >= arr[i]) {\n                st.pop();\n            }\n            \n            // Store result\n            result[i] = st.empty() ? -1 : st.top();\n            \n            // Push current element\n            st.push(arr[i]);\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[] nextSmallerElement(int[] arr) {\n        int n = arr.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() >= arr[i]) {\n                stack.pop();\n            }\n            \n            result[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(arr[i]);\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def nextSmallerElement(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        result = [-1] * n\n        stack = []\n        \n        for i in range(n - 1, -1, -1):\n            while stack and stack[-1] >= arr[i]:\n                stack.pop()\n            \n            result[i] = stack[-1] if stack else -1\n            stack.append(arr[i])\n        \n        return result",
        "javascript": "var nextSmallerElement = function(arr) {\n    const n = arr.length;\n    const result = new Array(n).fill(-1);\n    const stack = [];\n    \n    for (let i = n - 1; i >= 0; i--) {\n        while (stack.length > 0 && stack[stack.length - 1] >= arr[i]) {\n            stack.pop();\n        }\n        \n        result[i] = stack.length === 0 ? -1 : stack[stack.length - 1];\n        stack.push(arr[i]);\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Monotonic Stack - Store Indices - Optimal",
      "order": 3,
      "intuition": "Store indices instead of values in stack. Provides more flexibility for related problems. Same logic.",
      "approach": "Same as approach 2 but store indices. Access values using arr[stack.top()].",
      "steps": [
        "Initialize result with -1",
        "Create stack (stores indices)",
        "For i from n-1 to 0:",
        "  While stack not empty and arr[stack.top()] >= arr[i]:",
        "    Pop",
        "  If stack empty: result[i] = -1",
        "  Else: result[i] = arr[stack.top()]",
        "  Push i (current index)",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Each element pushed and popped at most once",
        "spaceExplanation": "Stack stores indices"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> nextSmallerElement(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> result(n);\n        stack<int> st;  // Store indices\n        \n        // Traverse from right to left\n        for (int i = n - 1; i >= 0; i--) {\n            // Pop indices with larger or equal values\n            while (!st.empty() && arr[st.top()] >= arr[i]) {\n                st.pop();\n            }\n            \n            // Store result\n            result[i] = st.empty() ? -1 : arr[st.top()];\n            \n            // Push current index\n            st.push(i);\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int[] nextSmallerElement(int[] arr) {\n        int n = arr.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();  // Store indices\n        \n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {\n                stack.pop();\n            }\n            \n            result[i] = stack.isEmpty() ? -1 : arr[stack.peek()];\n            stack.push(i);\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def nextSmallerElement(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        result = [-1] * n\n        stack = []  # Store indices\n        \n        for i in range(n - 1, -1, -1):\n            while stack and arr[stack[-1]] >= arr[i]:\n                stack.pop()\n            \n            result[i] = arr[stack[-1]] if stack else -1\n            stack.append(i)\n        \n        return result",
        "javascript": "var nextSmallerElement = function(arr) {\n    const n = arr.length;\n    const result = new Array(n).fill(-1);\n    const stack = [];  // Store indices\n    \n    for (let i = n - 1; i >= 0; i--) {\n        while (stack.length > 0 && arr[stack[stack.length - 1]] >= arr[i]) {\n            stack.pop();\n        }\n        \n        result[i] = stack.length === 0 ? -1 : arr[stack[stack.length - 1]];\n        stack.push(i);\n    }\n    \n    return result;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Using >= instead of > for popping (should pop equal elements too)",
    "Not maintaining monotonic increasing property",
    "Traversing left to right instead of right to left",
    "Confusing with next greater element logic",
    "Not pushing current element after processing"
  ],
  "hints": [
    "Opposite of next greater element",
    "Use monotonic increasing stack instead of decreasing",
    "Traverse from right to left",
    "Pop elements that are greater than or equal to current",
    "Stack top always has next smaller candidate"
  ],
  "followUp": [
    "How to find previous smaller element?",
    "Can you find next smaller in circular array?",
    "What about finding nearest smaller on both sides?",
    "How to use this for histogram problems?",
    "Can you find next smaller and next greater together?"
  ],
  "companies": ["Amazon", "Google", "Microsoft", "Adobe"],
  "tags": ["stack", "array", "monotonic-stack"],
  "relatedProblems": [
    "Next Greater Element I",
    "Next Greater Element II",
    "Previous Smaller Element",
    "Largest Rectangle in Histogram",
    "Daily Temperatures"
  ]
}
