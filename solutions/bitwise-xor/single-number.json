{
  "questionId": "694d4a3a98494915f3bc8ef4",
  "questionSlug": "single-number",
  "title": "Single Number",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/single-number/",
    "videos": [
      {
        "title": "Single Number - Bit Manipulation - Leetcode 136",
        "url": "https://www.youtube.com/watch?v=qMPX1AOa83k",
        "channel": "NeetCode",
        "duration": "5:17",
        "language": "English"
      },
      {
        "title": "Single Number | XOR Solution Explained",
        "url": "https://www.youtube.com/watch?v=eZr-6pfStatus",
        "channel": "takeUforward",
        "duration": "8:42",
        "language": "English"
      },
      {
        "title": "LeetCode 136 Single Number",
        "url": "https://www.youtube.com/watch?v=XzZa9IT8zlA",
        "channel": "Kevin Naughton Jr.",
        "duration": "4:35",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Single Number - LeetCode Solution",
        "url": "https://leetcode.com/problems/single-number/solution/",
        "source": "LeetCode Editorial"
      },
      {
        "title": "Find the element that appears once",
        "url": "https://www.geeksforgeeks.org/find-element-appears-array-every-element-appears-twice/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Single Number II",
        "url": "https://leetcode.com/problems/single-number-ii/",
        "platform": "LeetCode"
      },
      {
        "title": "Single Number III",
        "url": "https://leetcode.com/problems/single-number-iii/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Bitwise XOR pattern when every element appears even number of times except one. Key indicators: find unique element, all others appear twice, O(1) space requirement, XOR properties (a^a=0, a^0=a).",
  "approaches": [
    {
      "name": "Brute Force (Nested Loop)",
      "order": 1,
      "intuition": "Compare each element with every other element in the array. If an element doesn't have a duplicate, it's the single number. This is straightforward but inefficient.",
      "approach": "For each element, search through the entire array to count its occurrences. The element that appears exactly once is our answer.",
      "steps": [
        "For each element at index i:",
        "  Initialize count = 0",
        "  For each element at index j:",
        "    If nums[i] == nums[j], increment count",
        "  After inner loop, if count == 1:",
        "    Return nums[i] as the single number",
        "This guarantees finding the unique element"
      ],
      "complexity": {
        "time": "O(nÂ²)",
        "space": "O(1)",
        "timeExplanation": "Nested loops: outer loop runs n times, inner loop runs n times for each iteration",
        "spaceExplanation": "Only using constant extra space for count variable"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        \n        // Check each element\n        for (int i = 0; i < n; i++) {\n            int count = 0;\n            \n            // Count occurrences\n            for (int j = 0; j < n; j++) {\n                if (nums[i] == nums[j]) {\n                    count++;\n                }\n            }\n            \n            // If appears once, return it\n            if (count == 1) {\n                return nums[i];\n            }\n        }\n        \n        return -1; // Should never reach here\n    }\n};",
        "java": "class Solution {\n    public int singleNumber(int[] nums) {\n        int n = nums.length;\n        \n        // Check each element\n        for (int i = 0; i < n; i++) {\n            int count = 0;\n            \n            // Count occurrences\n            for (int j = 0; j < n; j++) {\n                if (nums[i] == nums[j]) {\n                    count++;\n                }\n            }\n            \n            // If appears once, return it\n            if (count == 1) {\n                return nums[i];\n            }\n        }\n        \n        return -1; // Should never reach here\n    }\n}",
        "python": "def single_number(nums):\n    n = len(nums)\n    \n    # Check each element\n    for i in range(n):\n        count = 0\n        \n        # Count occurrences\n        for j in range(n):\n            if nums[i] == nums[j]:\n                count += 1\n        \n        # If appears once, return it\n        if count == 1:\n            return nums[i]\n    \n    return -1  # Should never reach here",
        "javascript": "function singleNumber(nums) {\n    const n = nums.length;\n    \n    // Check each element\n    for (let i = 0; i < n; i++) {\n        let count = 0;\n        \n        // Count occurrences\n        for (let j = 0; j < n; j++) {\n            if (nums[i] === nums[j]) {\n                count++;\n            }\n        }\n        \n        // If appears once, return it\n        if (count === 1) {\n            return nums[i];\n        }\n    }\n    \n    return -1; // Should never reach here\n}"
      }
    },
    {
      "name": "Better (Hash Map/Set)",
      "order": 2,
      "intuition": "Use a hash map to count occurrences of each number, then find the one with count = 1. Alternatively, use a set: add numbers that don't exist, remove numbers that do exist. The remaining number is the answer.",
      "approach": "Use a hash set. When we see a number for the first time, add it to set. When we see it again, remove it from set. The final remaining element is the single number.",
      "steps": [
        "Create an empty hash set",
        "For each number in the array:",
        "  If number exists in set:",
        "    Remove it from set (it's a duplicate)",
        "  Else:",
        "    Add it to set (first occurrence)",
        "After processing all numbers, set contains only one element",
        "Return the single element from the set"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass through array, hash set operations are O(1) average case",
        "spaceExplanation": "Hash set can store up to n/2 + 1 unique numbers in worst case"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_set<int> numSet;\n        \n        // Process each number\n        for (int num : nums) {\n            if (numSet.find(num) != numSet.end()) {\n                // Number exists, remove it\n                numSet.erase(num);\n            } else {\n                // First occurrence, add it\n                numSet.insert(num);\n            }\n        }\n        \n        // Return the only remaining number\n        return *numSet.begin();\n    }\n};",
        "java": "class Solution {\n    public int singleNumber(int[] nums) {\n        Set<Integer> numSet = new HashSet<>();\n        \n        // Process each number\n        for (int num : nums) {\n            if (numSet.contains(num)) {\n                // Number exists, remove it\n                numSet.remove(num);\n            } else {\n                // First occurrence, add it\n                numSet.add(num);\n            }\n        }\n        \n        // Return the only remaining number\n        return numSet.iterator().next();\n    }\n}",
        "python": "def single_number(nums):\n    num_set = set()\n    \n    # Process each number\n    for num in nums:\n        if num in num_set:\n            # Number exists, remove it\n            num_set.remove(num)\n        else:\n            # First occurrence, add it\n            num_set.add(num)\n    \n    # Return the only remaining number\n    return num_set.pop()",
        "javascript": "function singleNumber(nums) {\n    const numSet = new Set();\n    \n    // Process each number\n    for (const num of nums) {\n        if (numSet.has(num)) {\n            // Number exists, remove it\n            numSet.delete(num);\n        } else {\n            // First occurrence, add it\n            numSet.add(num);\n        }\n    }\n    \n    // Return the only remaining number\n    return Array.from(numSet)[0];\n}"
      }
    },
    {
      "name": "Optimal (XOR Bit Manipulation)",
      "order": 3,
      "intuition": "XOR has special properties: a^a = 0 and a^0 = a. Also, XOR is commutative and associative. If we XOR all numbers together, pairs will cancel out (become 0), leaving only the single number. Example: 2^1^2^1^3 = (2^2)^(1^1)^3 = 0^0^3 = 3.",
      "approach": "Initialize result to 0. XOR all elements with result. Duplicate pairs cancel to 0, leaving only the unique number.",
      "steps": [
        "Initialize result = 0",
        "For each number in array:",
        "  result = result XOR number",
        "After processing all numbers:",
        "  All pairs cancel out (x ^ x = 0)",
        "  Only single number remains (0 ^ x = x)",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through the array, XOR operation is O(1)",
        "spaceExplanation": "Only using one variable to store result, no extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int result = 0;\n        \n        // XOR all numbers\n        for (int num : nums) {\n            result ^= num;\n        }\n        \n        // Pairs cancel out, single number remains\n        return result;\n    }\n};",
        "java": "class Solution {\n    public int singleNumber(int[] nums) {\n        int result = 0;\n        \n        // XOR all numbers\n        for (int num : nums) {\n            result ^= num;\n        }\n        \n        // Pairs cancel out, single number remains\n        return result;\n    }\n}",
        "python": "def single_number(nums):\n    result = 0\n    \n    # XOR all numbers\n    for num in nums:\n        result ^= num\n    \n    # Pairs cancel out, single number remains\n    return result",
        "javascript": "function singleNumber(nums) {\n    let result = 0;\n    \n    // XOR all numbers\n    for (const num of nums) {\n        result ^= num;\n    }\n    \n    // Pairs cancel out, single number remains\n    return result;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not understanding XOR properties: forgetting that a^a=0 and a^0=a",
    "Trying to use AND or OR operations instead of XOR for cancellation",
    "In hash map approach, forgetting to handle the case when number appears for first time",
    "Thinking XOR only works for positive numbers (it works for negative too)",
    "Not initializing result to 0 before starting XOR operations",
    "Overthinking the problem and not recognizing the simple XOR pattern"
  ],
  "hints": [
    "What happens when you XOR a number with itself?",
    "XOR has the property: a ^ a = 0 and a ^ 0 = a",
    "XOR is commutative: order doesn't matter (a^b^c = c^a^b)",
    "Think about what remains when you XOR all numbers in pairs",
    "Can you solve this without using extra space?",
    "The problem guarantees every element appears twice except one - can XOR help?"
  ],
  "followUp": [
    "What if every element appears three times instead of twice? (Single Number II)",
    "What if there are two numbers that appear once? (Single Number III)",
    "How would you find the element that appears odd number of times?",
    "Can you extend this to find missing number in a sequence?",
    "What if elements appear k times except one that appears once?",
    "How would you handle if numbers are in a stream rather than array?"
  ],
  "companies": [
    "Amazon",
    "Google",
    "Facebook",
    "Microsoft",
    "Apple",
    "Bloomberg",
    "Adobe",
    "Uber"
  ],
  "tags": [
    "Array",
    "Bit Manipulation",
    "Bitwise XOR",
    "Hash Table"
  ],
  "relatedProblems": [
    "Single Number II",
    "Single Number III",
    "Missing Number",
    "Find the Duplicate Number",
    "Two Single Numbers",
    "Find the Difference"
  ]
}
