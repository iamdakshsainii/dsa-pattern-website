{
  "questionId": "694d4a3a98494915f3bc8ef6",
  "questionSlug": "complement-base-10",
  "title": "Complement Base 10",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/complement-of-base-10-integer/",
    "videos": [
      {
        "title": "Complement of Base 10 Integer - Leetcode 1009",
        "url": "https://www.youtube.com/watch?v=oUSkey_t6xc",
        "channel": "Nick White",
        "duration": "5:12",
        "language": "English"
      },
      {
        "title": "Biwise Complement of Number - Bit Manipulation",
        "url": "https://www.youtube.com/watch?v=TGGxKD7flCg",
        "channel": "Kevin Naughton Jr.",
        "duration": "7:45",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Complement of Base 10 Integer",
        "url": "https://leetcode.com/problems/complement-of-base-10-integer/solution/",
        "source": "LeetCode Editorial"
      },
      {
        "title": "Bitwise Complement Solution",
        "url": "https://www.geeksforgeeks.org/bitwise-complement-number/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Number Complement",
        "url": "https://leetcode.com/problems/number-complement/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Bitwise XOR pattern when you need to flip bits, find complements, or toggle specific bits. Key indicators: complement/invert operations, binary representation manipulation, flipping all bits in a number.",
  "approaches": [
    {
      "name": "Brute Force (String Conversion)",
      "order": 1,
      "intuition": "Convert the number to binary string, flip each bit character ('0' to '1' and '1' to '0'), then convert back to decimal.",
      "approach": "Use built-in functions to convert to binary string, iterate through characters to flip them, and convert the result back to integer.",
      "steps": [
        "Handle edge case: if num is 0, return 1",
        "Convert number to binary string (without '0b' prefix)",
        "Create empty result string",
        "Iterate through each character in binary string:",
        "  If character is '0', append '1' to result",
        "  If character is '1', append '0' to result",
        "Convert the flipped binary string back to decimal",
        "Return the decimal result"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(log n)",
        "timeExplanation": "Converting to binary string takes O(log n) where n is the number, as there are log n bits",
        "spaceExplanation": "Binary string storage requires O(log n) space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int bitwiseComplement(int num) {\n        // Edge case\n        if (num == 0) return 1;\n        \n        // Convert to binary string\n        string binary = \"\";\n        int temp = num;\n        while (temp > 0) {\n            binary = to_string(temp % 2) + binary;\n            temp /= 2;\n        }\n        \n        // Flip each bit\n        string flipped = \"\";\n        for (char c : binary) {\n            if (c == '0') {\n                flipped += '1';\n            } else {\n                flipped += '0';\n            }\n        }\n        \n        // Convert back to decimal\n        int result = 0;\n        int power = 0;\n        for (int i = flipped.length() - 1; i >= 0; i--) {\n            if (flipped[i] == '1') {\n                result += pow(2, power);\n            }\n            power++;\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int bitwiseComplement(int num) {\n        // Edge case\n        if (num == 0) return 1;\n        \n        // Convert to binary string\n        String binary = Integer.toBinaryString(num);\n        \n        // Flip each bit\n        StringBuilder flipped = new StringBuilder();\n        for (char c : binary.toCharArray()) {\n            if (c == '0') {\n                flipped.append('1');\n            } else {\n                flipped.append('0');\n            }\n        }\n        \n        // Convert back to decimal\n        return Integer.parseInt(flipped.toString(), 2);\n    }\n}",
        "python": "def bitwise_complement(num):\n    # Edge case\n    if num == 0:\n        return 1\n    \n    # Convert to binary string (remove '0b' prefix)\n    binary = bin(num)[2:]\n    \n    # Flip each bit\n    flipped = ''\n    for bit in binary:\n        if bit == '0':\n            flipped += '1'\n        else:\n            flipped += '0'\n    \n    # Convert back to decimal\n    return int(flipped, 2)",
        "javascript": "function bitwiseComplement(num) {\n    // Edge case\n    if (num === 0) return 1;\n    \n    // Convert to binary string\n    const binary = num.toString(2);\n    \n    // Flip each bit\n    let flipped = '';\n    for (let bit of binary) {\n        if (bit === '0') {\n            flipped += '1';\n        } else {\n            flipped += '0';\n        }\n    }\n    \n    // Convert back to decimal\n    return parseInt(flipped, 2);\n}"
      }
    },
    {
      "name": "Better (Bit Manipulation with Loop)",
      "order": 2,
      "intuition": "Instead of using strings, we can manipulate bits directly. Check each bit of the number, and if it's 0, set corresponding bit in result to 1, and vice versa. We need to know how many bits the number has.",
      "approach": "Count the number of bits in the input number, then iterate through each bit position, checking and flipping it to build the complement.",
      "steps": [
        "Handle edge case: if num is 0, return 1",
        "Count total bits in the number:",
        "  Use log2(num) + 1 or count by right shifting until num becomes 0",
        "Initialize result = 0",
        "For each bit position i from 0 to (bit_count - 1):",
        "  Check if ith bit in num is 0 (using num & (1 << i))",
        "  If bit is 0, set ith bit in result to 1 (using result |= (1 << i))",
        "Return result"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "We iterate through all bits of the number, which is log n bits",
        "spaceExplanation": "Only using constant extra space for variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int bitwiseComplement(int num) {\n        // Edge case\n        if (num == 0) return 1;\n        \n        // Count number of bits\n        int bitCount = 0;\n        int temp = num;\n        while (temp > 0) {\n            bitCount++;\n            temp >>= 1;\n        }\n        \n        // Build complement by checking each bit\n        int result = 0;\n        for (int i = 0; i < bitCount; i++) {\n            // If ith bit is 0 in num, set it to 1 in result\n            if ((num & (1 << i)) == 0) {\n                result |= (1 << i);\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int bitwiseComplement(int num) {\n        // Edge case\n        if (num == 0) return 1;\n        \n        // Count number of bits\n        int bitCount = 0;\n        int temp = num;\n        while (temp > 0) {\n            bitCount++;\n            temp >>= 1;\n        }\n        \n        // Build complement by checking each bit\n        int result = 0;\n        for (int i = 0; i < bitCount; i++) {\n            // If ith bit is 0 in num, set it to 1 in result\n            if ((num & (1 << i)) == 0) {\n                result |= (1 << i);\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "def bitwise_complement(num):\n    # Edge case\n    if num == 0:\n        return 1\n    \n    # Count number of bits\n    bit_count = 0\n    temp = num\n    while temp > 0:\n        bit_count += 1\n        temp >>= 1\n    \n    # Build complement by checking each bit\n    result = 0\n    for i in range(bit_count):\n        # If ith bit is 0 in num, set it to 1 in result\n        if (num & (1 << i)) == 0:\n            result |= (1 << i)\n    \n    return result",
        "javascript": "function bitwiseComplement(num) {\n    // Edge case\n    if (num === 0) return 1;\n    \n    // Count number of bits\n    let bitCount = 0;\n    let temp = num;\n    while (temp > 0) {\n        bitCount++;\n        temp >>= 1;\n    }\n    \n    // Build complement by checking each bit\n    let result = 0;\n    for (let i = 0; i < bitCount; i++) {\n        // If ith bit is 0 in num, set it to 1 in result\n        if ((num & (1 << i)) === 0) {\n            result |= (1 << i);\n        }\n    }\n    \n    return result;\n}"
      }
    },
    {
      "name": "Optimal (XOR with All Ones Mask)",
      "order": 3,
      "intuition": "The complement of a number is essentially XORing it with a number that has all bits set to 1 for the same bit length. For example, complement of 5 (101) is 5 XOR 7 (111) = 2 (010). We need to create a mask with all 1s having the same bit length as the number.",
      "approach": "Find the number of bits in the input number, create a mask with all bits set to 1 for that length, then XOR the input with this mask to get the complement.",
      "steps": [
        "Handle edge case: if num is 0, return 1",
        "Count the number of bits in num (can use log2 or bit shifting)",
        "Create a mask with all 1s of same bit length:",
        "  Method 1: mask = (1 << bitCount) - 1",
        "  Method 2: mask = pow(2, bitCount) - 1",
        "  Example: if num has 3 bits, mask = (1 << 3) - 1 = 8 - 1 = 7 (111 in binary)",
        "XOR num with mask: result = num ^ mask",
        "Return result"
      ],
      "complexity": {
        "time": "O(1)",
        "space": "O(1)",
        "timeExplanation": "Only performing constant time operations: bit counting can be done with log2 which is O(1) for fixed integer size, and XOR is O(1)",
        "spaceExplanation": "Using only constant extra space for mask and result variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int bitwiseComplement(int num) {\n        // Edge case: complement of 0 is 1\n        if (num == 0) return 1;\n        \n        // Count number of bits using log2\n        int bitCount = floor(log2(num)) + 1;\n        \n        // Create mask with all 1s of same bit length\n        // (1 << bitCount) gives us 2^bitCount\n        // Subtracting 1 gives us all 1s\n        int mask = (1 << bitCount) - 1;\n        \n        // XOR with mask to get complement\n        return num ^ mask;\n    }\n};",
        "java": "class Solution {\n    public int bitwiseComplement(int num) {\n        // Edge case: complement of 0 is 1\n        if (num == 0) return 1;\n        \n        // Count number of bits using log2\n        int bitCount = (int)(Math.log(num) / Math.log(2)) + 1;\n        \n        // Create mask with all 1s of same bit length\n        int mask = (1 << bitCount) - 1;\n        \n        // XOR with mask to get complement\n        return num ^ mask;\n    }\n}",
        "python": "import math\n\ndef bitwise_complement(num):\n    # Edge case: complement of 0 is 1\n    if num == 0:\n        return 1\n    \n    # Count number of bits using log2\n    bit_count = math.floor(math.log2(num)) + 1\n    \n    # Create mask with all 1s of same bit length\n    # (1 << bit_count) gives us 2^bit_count\n    # Subtracting 1 gives us all 1s\n    mask = (1 << bit_count) - 1\n    \n    # XOR with mask to get complement\n    return num ^ mask",
        "javascript": "function bitwiseComplement(num) {\n    // Edge case: complement of 0 is 1\n    if (num === 0) return 1;\n    \n    // Count number of bits using log2\n    const bitCount = Math.floor(Math.log2(num)) + 1;\n    \n    // Create mask with all 1s of same bit length\n    const mask = (1 << bitCount) - 1;\n    \n    // XOR with mask to get complement\n    return num ^ mask;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Forgetting to handle the edge case when num = 0 (should return 1, not 0)",
    "Creating a mask with wrong number of bits (using 32 bits instead of actual bit count)",
    "Confusing bitwise NOT (~) with complement - NOT flips all 32 bits including leading zeros",
    "Off-by-one error in bit counting (forgetting the +1 after log2)",
    "Using signed integer operations that may cause issues with negative numbers",
    "Not considering that XOR with 0 returns the same number, XOR with 1 flips the bit"
  ],
  "hints": [
    "Think about what XOR operation does: 1 XOR 1 = 0, 0 XOR 1 = 1",
    "If you XOR a number with all 1s of same length, what happens?",
    "How can you create a number with all bits set to 1 for n bits?",
    "Consider the formula: 2^n - 1 gives you n bits all set to 1",
    "The complement is just flipping bits, and XOR with 1 flips a bit",
    "For a 3-bit number like 101, XORing with 111 gives you the complement"
  ],
  "followUp": [
    "What if you need to find complement of a binary string instead of integer?",
    "How would you handle very large numbers (64-bit or beyond)?",
    "Can you find the complement without using logarithm or counting bits?",
    "What's the relationship between this problem and finding XOR of all numbers from 1 to n?",
    "How would you modify this to flip only specific bits at given positions?",
    "What if you need to flip alternating bits instead of all bits?"
  ],
  "companies": [
    "Amazon",
    "Microsoft",
    "Google",
    "Facebook",
    "Apple",
    "Bloomberg"
  ],
  "tags": [
    "Bit Manipulation",
    "Bitwise XOR",
    "Math",
    "Binary"
  ],
  "relatedProblems": [
    "Number Complement",
    "Single Number",
    "Reverse Bits",
    "Counting Bits",
    "Hamming Distance",
    "Power of Two"
  ]
}