{
  "questionId": "875",
  "questionSlug": "koko-eating-bananas",
  "title": "Koko Eating Bananas",
  "difficulty": "Medium",
  "leetcodeLink": "https://leetcode.com/problems/koko-eating-bananas/",
  "resources": {
    "leetcode": "https://leetcode.com/problems/koko-eating-bananas/",
    "videos": [
      {
        "title": "Koko Eating Bananas - Binary Search",
        "url": "https://www.youtube.com/watch?v=U2SozAs9RzA",
        "channel": "NeetCode",
        "duration": "10:45",
        "language": "English"
      }
    ]
  },
  "problemStatement": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer k such that she can eat all the bananas within h hours.",
  "examples": [
    {
      "input": "piles = [3,6,7,11], h = 8",
      "output": "4",
      "explanation": "If k=4, hours needed: ceil(3/4)+ceil(6/4)+ceil(7/4)+ceil(11/4) = 1+2+2+3 = 8 hours"
    },
    {
      "input": "piles = [30,11,23,4,20], h = 5",
      "output": "30",
      "explanation": "k=30 means she finishes each pile in 1 hour, total 5 hours"
    },
    {
      "input": "piles = [30,11,23,4,20], h = 6",
      "output": "23",
      "explanation": "k=23: 2+1+1+1+1 = 6 hours"
    }
  ],
  "constraints": [
    "1 <= piles.length <= 10^4",
    "piles.length <= h <= 10^9",
    "1 <= piles[i] <= 10^9"
  ],
  "patternTriggers": "Minimize/maximize value + can we do it in X time/resources + monotonic answer space = Binary search on answer",
  "approaches": [
    {
      "name": "Brute Force - Try All Speeds",
      "order": 1,
      "intuition": "Try every possible speed from 1 to max(piles), find minimum that works",
      "approach": "Linear search through all possible speeds",
      "steps": [
        "Start with k = 1",
        "For each k from 1 to max(piles):",
        "  Calculate hours needed with speed k",
        "  If hours <= h, return k",
        "Return max(piles)"
      ],
      "complexity": {
        "time": "O(n * max(piles))",
        "space": "O(1)",
        "timeExplanation": "For each speed (up to max(piles)), calculate hours in O(n)",
        "spaceExplanation": "No extra space"
      },
      "code": {
        "cpp": "class Solution {\nprivate:\n    long long calculateHours(vector<int>& piles, int k) {\n        long long hours = 0;\n        for (int pile : piles) {\n            hours += (pile + k - 1) / k; // Ceiling division\n        }\n        return hours;\n    }\n    \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int maxPile = *max_element(piles.begin(), piles.end());\n        \n        for (int k = 1; k <= maxPile; k++) {\n            if (calculateHours(piles, k) <= h) {\n                return k;\n            }\n        }\n        \n        return maxPile;\n    }\n};",
        "java": "class Solution {\n    private long calculateHours(int[] piles, int k) {\n        long hours = 0;\n        for (int pile : piles) {\n            hours += (pile + k - 1) / k;\n        }\n        return hours;\n    }\n    \n    public int minEatingSpeed(int[] piles, int h) {\n        int maxPile = 0;\n        for (int pile : piles) {\n            maxPile = Math.max(maxPile, pile);\n        }\n        \n        for (int k = 1; k <= maxPile; k++) {\n            if (calculateHours(piles, k) <= h) {\n                return k;\n            }\n        }\n        \n        return maxPile;\n    }\n}",
        "python": "class Solution:\n    def calculateHours(self, piles: List[int], k: int) -> int:\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k  # Ceiling division\n        return hours\n    \n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        max_pile = max(piles)\n        \n        for k in range(1, max_pile + 1):\n            if self.calculateHours(piles, k) <= h:\n                return k\n        \n        return max_pile",
        "javascript": "var minEatingSpeed = function(piles, h) {\n    const calculateHours = (k) => {\n        let hours = 0;\n        for (const pile of piles) {\n            hours += Math.ceil(pile / k);\n        }\n        return hours;\n    };\n    \n    const maxPile = Math.max(...piles);\n    \n    for (let k = 1; k <= maxPile; k++) {\n        if (calculateHours(k) <= h) {\n            return k;\n        }\n    }\n    \n    return maxPile;\n};"
      }
    },
    {
      "name": "Binary Search on Answer Space (Optimal)",
      "order": 2,
      "intuition": "Answer space [1, max(piles)] is monotonic: if speed k works, all speeds > k also work. Binary search to find minimum k that works.",
      "approach": "Binary search on eating speed, check if speed allows finishing in h hours",
      "steps": [
        "left = 1, right = max(piles)",
        "While left < right:",
        "  mid = (left + right) / 2",
        "  hours = calculateHours(piles, mid)",
        "  If hours <= h:",
        "    We can finish in time, try smaller speed",
        "    right = mid",
        "  Else:",
        "    Too slow, need faster speed",
        "    left = mid + 1",
        "Return left"
      ],
      "complexity": {
        "time": "O(n log m)",
        "space": "O(1)",
        "timeExplanation": "Binary search O(log m) where m=max(piles), each check O(n)",
        "spaceExplanation": "No extra space"
      },
      "code": {
        "cpp": "class Solution {\nprivate:\n    long long calculateHours(vector<int>& piles, int k) {\n        long long hours = 0;\n        for (int pile : piles) {\n            hours += (pile + k - 1) / k; // Ceiling: (a+b-1)/b\n        }\n        return hours;\n    }\n    \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int left = 1;\n        int right = *max_element(piles.begin(), piles.end());\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            long long hours = calculateHours(piles, mid);\n            \n            if (hours <= h) {\n                right = mid; // Can finish in time, try slower\n            } else {\n                left = mid + 1; // Too slow, need faster\n            }\n        }\n        \n        return left;\n    }\n};",
        "java": "class Solution {\n    private long calculateHours(int[] piles, int k) {\n        long hours = 0;\n        for (int pile : piles) {\n            hours += (pile + k - 1) / k;\n        }\n        return hours;\n    }\n    \n    public int minEatingSpeed(int[] piles, int h) {\n        int left = 1;\n        int right = 0;\n        for (int pile : piles) {\n            right = Math.max(right, pile);\n        }\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            long hours = calculateHours(piles, mid);\n            \n            if (hours <= h) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n}",
        "python": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def calculateHours(k: int) -> int:\n            hours = 0\n            for pile in piles:\n                hours += math.ceil(pile / k)\n                # Or: hours += (pile + k - 1) // k\n            return hours\n        \n        left, right = 1, max(piles)\n        \n        while left < right:\n            mid = (left + right) // 2\n            hours = calculateHours(mid)\n            \n            if hours <= h:\n                right = mid  # Can finish, try slower\n            else:\n                left = mid + 1  # Too slow, need faster\n        \n        return left",
        "javascript": "var minEatingSpeed = function(piles, h) {\n    const calculateHours = (k) => {\n        let hours = 0;\n        for (const pile of piles) {\n            hours += Math.ceil(pile / k);\n        }\n        return hours;\n    };\n    \n    let left = 1;\n    let right = Math.max(...piles);\n    \n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        const hours = calculateHours(mid);\n        \n        if (hours <= h) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return left;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Using integer division instead of ceiling division (pile/k vs ceil(pile/k))",
    "Not handling the case when h = piles.length (answer is max(piles))",
    "Integer overflow when calculating total hours (use long)",
    "Wrong binary search bounds: right should be max(piles), not sum(piles)",
    "Using left <= right instead of left < right (causes infinite loop)"
  ],
  "hints": [
    "Key insight: answer space is monotonic - if k works, all k' > k also work",
    "Binary search on the SPEED (answer), not on the array",
    "Ceiling division trick: (a + b - 1) / b = ceil(a / b)",
    "Minimum possible speed is 1, maximum is max(piles)",
    "For each speed, check if Koko can finish all piles in h hours",
    "Use 'right = mid' when condition is satisfied (finding minimum)"
  ],
  "followUp": [
    "What if Koko can eat from multiple piles in one hour?",
    "What if some piles cannot be eaten (too hard)?",
    "Can you solve it with early termination optimization?",
    "What if we want to maximize eating time instead of minimize speed?"
  ],
  "companies": ["Google", "Amazon", "Facebook", "Microsoft", "Apple"],
  "tags": ["binary-search", "array"],
  "relatedProblems": [
    "Capacity To Ship Packages Within D Days",
    "Minimum Number of Days to Make M Bouquets",
    "Minimized Maximum of Products Distributed to Any Store",
    "Minimum Speed to Arrive on Time"
  ]
}
