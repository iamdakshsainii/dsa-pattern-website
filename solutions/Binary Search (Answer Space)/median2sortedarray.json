{
  "questionId": "4",
  "questionSlug": "median-of-two-sorted-arrays",
  "title": "Median of Two Sorted Arrays",
  "difficulty": "Hard",
  "resources": {
    "leetcode": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
    "videos": [
      {
        "title": "Median of Two Sorted Arrays",
        "url": "https://www.youtube.com/watch?v=NTop3VTjmxk",
        "channel": "take U forward",
        "duration": "28:45",
        "language": "English"
      },
      {
        "title": "Median of Two Sorted Arrays - Binary Search",
        "url": "https://www.youtube.com/watch?v=q6IEA26hvXc",
        "channel": "NeetCode",
        "duration": "16:20",
        "language": "English"
      },
      {
        "title": "Median of Two Sorted Arrays Explained",
        "url": "https://www.youtube.com/watch?v=LPFhl65R7ww",
        "channel": "Tushar Roy",
        "duration": "24:15",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Median of Two Sorted Arrays - LeetCode Solution",
        "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solution/",
        "source": "LeetCode Official"
      },
      {
        "title": "Median of 2 Sorted Arrays",
        "url": "https://takeuforward.org/data-structure/median-of-two-sorted-arrays-of-different-sizes/",
        "source": "takeuforward"
      },
      {
        "title": "Median of Two Sorted Arrays - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Two sorted arrays + Find median = Binary search on smaller array. Partition both arrays such that left half has (n+m+1)/2 elements.",
  "approaches": [
    {
      "name": "Brute Force (Merge Arrays)",
      "order": 1,
      "intuition": "Merge both arrays into one sorted array, then find median by accessing middle element(s).",
      "approach": "Use two pointers to merge both arrays completely, then calculate median based on total length (odd/even).",
      "steps": [
        "Create merged array of size m + n",
        "Use two pointers i, j starting at 0",
        "Compare elements and merge in sorted order",
        "After merging, find median:",
        "  If total length is odd: return merged[(n+m)/2]",
        "  If even: return average of merged[(n+m)/2-1] and merged[(n+m)/2]"
      ],
      "complexity": {
        "time": "O(m + n)",
        "space": "O(m + n)",
        "timeExplanation": "Need to merge entire arrays",
        "spaceExplanation": "Storing merged array"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size(), n = nums2.size();\n        vector<int> merged(m + n);\n        int i = 0, j = 0, k = 0;\n        \n        while (i < m && j < n) {\n            if (nums1[i] < nums2[j]) {\n                merged[k++] = nums1[i++];\n            } else {\n                merged[k++] = nums2[j++];\n            }\n        }\n        \n        while (i < m) merged[k++] = nums1[i++];\n        while (j < n) merged[k++] = nums2[j++];\n        \n        int total = m + n;\n        if (total % 2 == 1) {\n            return merged[total / 2];\n        } else {\n            return (merged[total / 2 - 1] + merged[total / 2]) / 2.0;\n        }\n    }\n};",
        "java": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int m = nums1.length, n = nums2.length;\n        int[] merged = new int[m + n];\n        int i = 0, j = 0, k = 0;\n        \n        while (i < m && j < n) {\n            if (nums1[i] < nums2[j]) {\n                merged[k++] = nums1[i++];\n            } else {\n                merged[k++] = nums2[j++];\n            }\n        }\n        \n        while (i < m) merged[k++] = nums1[i++];\n        while (j < n) merged[k++] = nums2[j++];\n        \n        int total = m + n;\n        if (total % 2 == 1) {\n            return merged[total / 2];\n        } else {\n            return (merged[total / 2 - 1] + merged[total / 2]) / 2.0;\n        }\n    }\n}",
        "python": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m, n = len(nums1), len(nums2)\n        merged = []\n        i, j = 0, 0\n        \n        while i < m and j < n:\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        \n        merged.extend(nums1[i:])\n        merged.extend(nums2[j:])\n        \n        total = m + n\n        if total % 2 == 1:\n            return merged[total // 2]\n        else:\n            return (merged[total // 2 - 1] + merged[total // 2]) / 2.0",
        "javascript": "var findMedianSortedArrays = function(nums1, nums2) {\n    const m = nums1.length, n = nums2.length;\n    const merged = [];\n    let i = 0, j = 0;\n    \n    while (i < m && j < n) {\n        if (nums1[i] < nums2[j]) {\n            merged.push(nums1[i++]);\n        } else {\n            merged.push(nums2[j++]);\n        }\n    }\n    \n    while (i < m) merged.push(nums1[i++]);\n    while (j < n) merged.push(nums2[j++]);\n    \n    const total = m + n;\n    if (total % 2 === 1) {\n        return merged[Math.floor(total / 2)];\n    } else {\n        return (merged[total / 2 - 1] + merged[total / 2]) / 2.0;\n    }\n};"
      }
    },
    {
      "name": "Better (Count to Median)",
      "order": 2,
      "intuition": "We don't need full merged array. Just track elements until we reach median position(s).",
      "approach": "Merge arrays using two pointers but stop when we reach median position. Track last two elements for even length case.",
      "steps": [
        "Calculate total length and median positions",
        "Use two pointers to merge",
        "Track current and previous elements",
        "Stop when we reach median position(s)",
        "For odd length: return element at position (n+m)/2",
        "For even length: return average of two middle elements"
      ],
      "complexity": {
        "time": "O((m + n) / 2)",
        "space": "O(1)",
        "timeExplanation": "Only need to iterate until middle",
        "spaceExplanation": "Only storing few variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size(), n = nums2.size();\n        int total = m + n;\n        int targetIdx = total / 2;\n        int i = 0, j = 0, count = 0;\n        int prev = 0, curr = 0;\n        \n        while (count <= targetIdx) {\n            prev = curr;\n            \n            if (i < m && (j >= n || nums1[i] <= nums2[j])) {\n                curr = nums1[i++];\n            } else {\n                curr = nums2[j++];\n            }\n            count++;\n        }\n        \n        if (total % 2 == 1) {\n            return curr;\n        } else {\n            return (prev + curr) / 2.0;\n        }\n    }\n};",
        "java": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int m = nums1.length, n = nums2.length;\n        int total = m + n;\n        int targetIdx = total / 2;\n        int i = 0, j = 0, count = 0;\n        int prev = 0, curr = 0;\n        \n        while (count <= targetIdx) {\n            prev = curr;\n            \n            if (i < m && (j >= n || nums1[i] <= nums2[j])) {\n                curr = nums1[i++];\n            } else {\n                curr = nums2[j++];\n            }\n            count++;\n        }\n        \n        if (total % 2 == 1) {\n            return curr;\n        } else {\n            return (prev + curr) / 2.0;\n        }\n    }\n}",
        "python": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        target_idx = total // 2\n        i, j, count = 0, 0, 0\n        prev, curr = 0, 0\n        \n        while count <= target_idx:\n            prev = curr\n            \n            if i < m and (j >= n or nums1[i] <= nums2[j]):\n                curr = nums1[i]\n                i += 1\n            else:\n                curr = nums2[j]\n                j += 1\n            count += 1\n        \n        if total % 2 == 1:\n            return float(curr)\n        else:\n            return (prev + curr) / 2.0",
        "javascript": "var findMedianSortedArrays = function(nums1, nums2) {\n    const m = nums1.length, n = nums2.length;\n    const total = m + n;\n    const targetIdx = Math.floor(total / 2);\n    let i = 0, j = 0, count = 0;\n    let prev = 0, curr = 0;\n    \n    while (count <= targetIdx) {\n        prev = curr;\n        \n        if (i < m && (j >= n || nums1[i] <= nums2[j])) {\n            curr = nums1[i++];\n        } else {\n            curr = nums2[j++];\n        }\n        count++;\n    }\n    \n    if (total % 2 === 1) {\n        return curr;\n    } else {\n        return (prev + curr) / 2.0;\n    }\n};"
      }
    },
    {
      "name": "Binary Search - Optimal",
      "order": 3,
      "intuition": "Partition both arrays such that left half has exactly (m+n+1)/2 elements. Use binary search on smaller array to find correct partition.",
      "approach": "Binary search on smaller array to find partition point. Ensure all elements in left half ≤ all elements in right half.",
      "steps": [
        "Ensure nums1 is smaller array (swap if needed)",
        "Binary search on nums1: low = 0, high = m",
        "For partition1 in nums1, calculate partition2 = (m+n+1)/2 - partition1",
        "Get boundary elements:",
        "  maxLeft1, minRight1 from nums1",
        "  maxLeft2, minRight2 from nums2",
        "Check if partition is valid:",
        "  maxLeft1 ≤ minRight2 AND maxLeft2 ≤ minRight1",
        "If valid: calculate median based on odd/even total",
        "If maxLeft1 > minRight2: move left (high = partition1 - 1)",
        "Else: move right (low = partition1 + 1)"
      ],
      "complexity": {
        "time": "O(log(min(m, n)))",
        "space": "O(1)",
        "timeExplanation": "Binary search on smaller array",
        "spaceExplanation": "Only constant variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int low = 0, high = m;\n        \n        while (low <= high) {\n            int partition1 = (low + high) / 2;\n            int partition2 = (m + n + 1) / 2 - partition1;\n            \n            int maxLeft1 = (partition1 == 0) ? INT_MIN : nums1[partition1 - 1];\n            int minRight1 = (partition1 == m) ? INT_MAX : nums1[partition1];\n            \n            int maxLeft2 = (partition2 == 0) ? INT_MIN : nums2[partition2 - 1];\n            int minRight2 = (partition2 == n) ? INT_MAX : nums2[partition2];\n            \n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0;\n                } else {\n                    return max(maxLeft1, maxLeft2);\n                }\n            } else if (maxLeft1 > minRight2) {\n                high = partition1 - 1;\n            } else {\n                low = partition1 + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};",
        "java": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.length, n = nums2.length;\n        int low = 0, high = m;\n        \n        while (low <= high) {\n            int partition1 = (low + high) / 2;\n            int partition2 = (m + n + 1) / 2 - partition1;\n            \n            int maxLeft1 = (partition1 == 0) ? Integer.MIN_VALUE : nums1[partition1 - 1];\n            int minRight1 = (partition1 == m) ? Integer.MAX_VALUE : nums1[partition1];\n            \n            int maxLeft2 = (partition2 == 0) ? Integer.MIN_VALUE : nums2[partition2 - 1];\n            int minRight2 = (partition2 == n) ? Integer.MAX_VALUE : nums2[partition2];\n            \n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n                if ((m + n) % 2 == 0) {\n                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;\n                } else {\n                    return Math.max(maxLeft1, maxLeft2);\n                }\n            } else if (maxLeft1 > minRight2) {\n                high = partition1 - 1;\n            } else {\n                low = partition1 + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n}",
        "python": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums1) > len(nums2):\n            return self.findMedianSortedArrays(nums2, nums1)\n        \n        m, n = len(nums1), len(nums2)\n        low, high = 0, m\n        \n        while low <= high:\n            partition1 = (low + high) // 2\n            partition2 = (m + n + 1) // 2 - partition1\n            \n            maxLeft1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]\n            minRight1 = float('inf') if partition1 == m else nums1[partition1]\n            \n            maxLeft2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]\n            minRight2 = float('inf') if partition2 == n else nums2[partition2]\n            \n            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n                if (m + n) % 2 == 0:\n                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0\n                else:\n                    return max(maxLeft1, maxLeft2)\n            elif maxLeft1 > minRight2:\n                high = partition1 - 1\n            else:\n                low = partition1 + 1\n        \n        return 0.0",
        "javascript": "var findMedianSortedArrays = function(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const m = nums1.length, n = nums2.length;\n    let low = 0, high = m;\n    \n    while (low <= high) {\n        const partition1 = Math.floor((low + high) / 2);\n        const partition2 = Math.floor((m + n + 1) / 2) - partition1;\n        \n        const maxLeft1 = partition1 === 0 ? -Infinity : nums1[partition1 - 1];\n        const minRight1 = partition1 === m ? Infinity : nums1[partition1];\n        \n        const maxLeft2 = partition2 === 0 ? -Infinity : nums2[partition2 - 1];\n        const minRight2 = partition2 === n ? Infinity : nums2[partition2];\n        \n        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n            if ((m + n) % 2 === 0) {\n                return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;\n            } else {\n                return Math.max(maxLeft1, maxLeft2);\n            }\n        } else if (maxLeft1 > minRight2) {\n            high = partition1 - 1;\n        } else {\n            low = partition1 + 1;\n        }\n    }\n    \n    return 0.0;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not ensuring nums1 is the smaller array",
    "Wrong partition calculation: should be (m+n+1)/2",
    "Not handling edge cases: empty partitions",
    "Incorrect boundary conditions in binary search",
    "Forgetting to handle odd vs even total length differently"
  ],
  "hints": [
    "Binary search on the smaller array",
    "Partition both arrays such that left half has (m+n+1)/2 elements",
    "All elements in left half should be ≤ all elements in right half",
    "Use INT_MIN/INT_MAX for boundary cases",
    "The key is finding the correct partition point"
  ],
  "followUp": [
    "What if arrays are not sorted?",
    "Can you find kth smallest element using similar approach?",
    "How to handle duplicate elements?",
    "What if one array is much larger than the other?",
    "Can you extend this to find median of 3 sorted arrays?"
  ],
  "companies": ["Google", "Amazon", "Microsoft", "Facebook", "Apple", "Adobe"],
  "tags": ["binary-search", "array", "divide-and-conquer"],
  "relatedProblems": [
    "Kth Smallest Element in Sorted Matrix",
    "Find K Pairs with Smallest Sums",
    "Median of Two Sorted Arrays II",
    "K-th Smallest Prime Fraction"
  ]
}
