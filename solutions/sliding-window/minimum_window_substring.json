{
  "questionId": "76",
  "questionSlug": "minimum-window-substring",
  "title": "Minimum Window Substring",
  "difficulty": "Hard",
  "resources": {
    "leetcode": "https://leetcode.com/problems/minimum-window-substring/",
    "videos": [
      {
        "title": "Minimum Window Substring - Sliding Window",
        "url": "https://www.youtube.com/watch?v=jSto0O4AJbM",
        "channel": "NeetCode",
        "duration": "16:45",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Find minimum window containing all characters = Variable sliding window. Expand until valid, shrink while valid, track minimum.",
  "approaches": [
    {
      "name": "Brute Force (All Substrings)",
      "order": 1,
      "intuition": "Try all substrings, check if each contains all characters of t, track minimum length substring.",
      "approach": "Generate all substrings, for each check if it contains all chars from t with correct frequencies.",
      "steps": [
        "Initialize minLen = infinity, result = \"\"",
        "Build frequency map for t",
        "For i from 0 to s.length:",
        "  For j from i to s.length:",
        "    Extract substring s[i:j+1]",
        "    Build frequency map for substring",
        "    If substring contains all chars from t:",
        "      If j - i + 1 < minLen:",
        "        minLen = j - i + 1",
        "        result = substring",
        "Return result"
      ],
      "complexity": {
        "time": "O(n² * m)",
        "space": "O(m)",
        "timeExplanation": "n² substrings, m time to validate each",
        "spaceExplanation": "Frequency maps for t and current substring"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        if (s.length() < t.length()) return \"\";\n        \n        unordered_map<char, int> tFreq;\n        for (char c : t) {\n            tFreq[c]++;\n        }\n        \n        string result = \"\";\n        int minLen = INT_MAX;\n        \n        for (int i = 0; i < s.length(); i++) {\n            unordered_map<char, int> windowFreq;\n            for (int j = i; j < s.length(); j++) {\n                windowFreq[s[j]]++;\n                \n                bool valid = true;\n                for (auto& [ch, count] : tFreq) {\n                    if (windowFreq[ch] < count) {\n                        valid = false;\n                        break;\n                    }\n                }\n                \n                if (valid && j - i + 1 < minLen) {\n                    minLen = j - i + 1;\n                    result = s.substr(i, minLen);\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public String minWindow(String s, String t) {\n        if (s.length() < t.length()) return \"\";\n        \n        Map<Character, Integer> tFreq = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            tFreq.put(c, tFreq.getOrDefault(c, 0) + 1);\n        }\n        \n        String result = \"\";\n        int minLen = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < s.length(); i++) {\n            Map<Character, Integer> windowFreq = new HashMap<>();\n            for (int j = i; j < s.length(); j++) {\n                windowFreq.put(s.charAt(j), windowFreq.getOrDefault(s.charAt(j), 0) + 1);\n                \n                boolean valid = true;\n                for (Map.Entry<Character, Integer> entry : tFreq.entrySet()) {\n                    if (windowFreq.getOrDefault(entry.getKey(), 0) < entry.getValue()) {\n                        valid = false;\n                        break;\n                    }\n                }\n                \n                if (valid && j - i + 1 < minLen) {\n                    minLen = j - i + 1;\n                    result = s.substring(i, j + 1);\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if len(s) < len(t):\n            return \"\"\n        \n        from collections import Counter\n        t_freq = Counter(t)\n        \n        result = \"\"\n        min_len = float('inf')\n        \n        for i in range(len(s)):\n            window_freq = {}\n            for j in range(i, len(s)):\n                window_freq[s[j]] = window_freq.get(s[j], 0) + 1\n                \n                valid = all(window_freq.get(ch, 0) >= count for ch, count in t_freq.items())\n                \n                if valid and j - i + 1 < min_len:\n                    min_len = j - i + 1\n                    result = s[i:j+1]\n        \n        return result",
        "javascript": "var minWindow = function(s, t) {\n    if (s.length < t.length) return \"\";\n    \n    const tFreq = {};\n    for (const c of t) {\n        tFreq[c] = (tFreq[c] || 0) + 1;\n    }\n    \n    let result = \"\";\n    let minLen = Infinity;\n    \n    for (let i = 0; i < s.length; i++) {\n        const windowFreq = {};\n        for (let j = i; j < s.length; j++) {\n            windowFreq[s[j]] = (windowFreq[s[j]] || 0) + 1;\n            \n            const valid = Object.keys(tFreq).every(ch => \n                (windowFreq[ch] || 0) >= tFreq[ch]\n            );\n            \n            if (valid && j - i + 1 < minLen) {\n                minLen = j - i + 1;\n                result = s.substring(i, j + 1);\n            }\n        }\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Variable Sliding Window - Optimal",
      "order": 2,
      "intuition": "Expand window with right pointer until valid (contains all t chars). Then shrink from left while maintaining validity. Track minimum.",
      "approach": "Use two pointers. Track required and formed characters. Expand right, shrink left when valid.",
      "steps": [
        "Build frequency map for t, set required = unique chars in t",
        "Initialize left = 0, formed = 0 (chars with required frequency)",
        "Initialize minLen = infinity, result indices",
        "For right from 0 to s.length:",
        "  Add s[right] to window frequency",
        "  If s[right] frequency matches t: formed++",
        "  While window is valid (formed == required):",
        "    Update minimum if current window smaller",
        "    Remove s[left] from window",
        "    If s[left] frequency drops below required: formed--",
        "    left++",
        "Return minimum window substring"
      ],
      "complexity": {
        "time": "O(n + m)",
        "space": "O(m)",
        "timeExplanation": "Each element visited at most twice",
        "spaceExplanation": "Frequency maps for t and window"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        if (s.empty() || t.empty()) return \"\";\n        \n        unordered_map<char, int> tFreq, windowFreq;\n        for (char c : t) {\n            tFreq[c]++;\n        }\n        \n        int required = tFreq.size();\n        int formed = 0;\n        int left = 0;\n        int minLen = INT_MAX;\n        int minLeft = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char c = s[right];\n            windowFreq[c]++;\n            \n            if (tFreq.count(c) && windowFreq[c] == tFreq[c]) {\n                formed++;\n            }\n            \n            while (formed == required && left <= right) {\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    minLeft = left;\n                }\n                \n                char leftChar = s[left];\n                windowFreq[leftChar]--;\n                if (tFreq.count(leftChar) && windowFreq[leftChar] < tFreq[leftChar]) {\n                    formed--;\n                }\n                left++;\n            }\n        }\n        \n        return minLen == INT_MAX ? \"\" : s.substr(minLeft, minLen);\n    }\n};",
        "java": "class Solution {\n    public String minWindow(String s, String t) {\n        if (s.isEmpty() || t.isEmpty()) return \"\";\n        \n        Map<Character, Integer> tFreq = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            tFreq.put(c, tFreq.getOrDefault(c, 0) + 1);\n        }\n        \n        Map<Character, Integer> windowFreq = new HashMap<>();\n        int required = tFreq.size();\n        int formed = 0;\n        int left = 0;\n        int minLen = Integer.MAX_VALUE;\n        int minLeft = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            windowFreq.put(c, windowFreq.getOrDefault(c, 0) + 1);\n            \n            if (tFreq.containsKey(c) && windowFreq.get(c).intValue() == tFreq.get(c).intValue()) {\n                formed++;\n            }\n            \n            while (formed == required && left <= right) {\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    minLeft = left;\n                }\n                \n                char leftChar = s.charAt(left);\n                windowFreq.put(leftChar, windowFreq.get(leftChar) - 1);\n                if (tFreq.containsKey(leftChar) && windowFreq.get(leftChar) < tFreq.get(leftChar)) {\n                    formed--;\n                }\n                left++;\n            }\n        }\n        \n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minLeft, minLeft + minLen);\n    }\n}",
        "python": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        \n        from collections import Counter\n        t_freq = Counter(t)\n        window_freq = {}\n        \n        required = len(t_freq)\n        formed = 0\n        left = 0\n        min_len = float('inf')\n        min_left = 0\n        \n        for right in range(len(s)):\n            c = s[right]\n            window_freq[c] = window_freq.get(c, 0) + 1\n            \n            if c in t_freq and window_freq[c] == t_freq[c]:\n                formed += 1\n            \n            while formed == required and left <= right:\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    min_left = left\n                \n                left_char = s[left]\n                window_freq[left_char] -= 1\n                if left_char in t_freq and window_freq[left_char] < t_freq[left_char]:\n                    formed -= 1\n                left += 1\n        \n        return \"\" if min_len == float('inf') else s[min_left:min_left + min_len]",
        "javascript": "var minWindow = function(s, t) {\n    if (!s || !t) return \"\";\n    \n    const tFreq = {};\n    for (const c of t) {\n        tFreq[c] = (tFreq[c] || 0) + 1;\n    }\n    \n    const windowFreq = {};\n    const required = Object.keys(tFreq).length;\n    let formed = 0;\n    let left = 0;\n    let minLen = Infinity;\n    let minLeft = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        const c = s[right];\n        windowFreq[c] = (windowFreq[c] || 0) + 1;\n        \n        if (tFreq[c] && windowFreq[c] === tFreq[c]) {\n            formed++;\n        }\n        \n        while (formed === required && left <= right) {\n            if (right - left + 1 < minLen) {\n                minLen = right - left + 1;\n                minLeft = left;\n            }\n            \n            const leftChar = s[left];\n            windowFreq[leftChar]--;\n            if (tFreq[leftChar] && windowFreq[leftChar] < tFreq[leftChar]) {\n                formed--;\n            }\n            left++;\n        }\n    }\n    \n    return minLen === Infinity ? \"\" : s.substring(minLeft, minLeft + minLen);\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not tracking 'formed' vs 'required' correctly",
    "Comparing total characters instead of unique characters",
    "Not handling empty string edge cases",
    "Forgetting to update formed when removing from left"
  ],
  "hints": [
    "Track how many unique characters have required frequency (formed)",
    "Only when formed == required is window valid",
    "Shrink from left while maintaining validity",
    "Use indices to track minimum window, extract at end"
  ],
  "followUp": [
    "What if t contains duplicate characters?",
    "Find all minimum windows?",
    "What if we need to handle unicode?"
  ],
  "companies": ["Amazon", "Google", "Facebook", "Microsoft", "Uber"],
  "tags": ["string", "sliding-window", "hash-table"],
  "relatedProblems": [
    "Substring with Concatenation of All Words",
    "Minimum Size Subarray Sum",
    "Find All Anagrams in a String"
  ]
}
