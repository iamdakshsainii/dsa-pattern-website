{
  "questionId": "209",
  "questionSlug": "minimum-size-subarray-sum",
  "title": "Minimum Size Subarray Sum",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/minimum-size-subarray-sum/",
    "videos": [
      {
        "title": "Minimum Size Subarray Sum - Sliding Window",
        "url": "https://www.youtube.com/watch?v=aYqYMIqZx5s",
        "channel": "NeetCode",
        "duration": "9:15",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Find minimum length subarray with sum ≥ target = Variable sliding window. Expand until valid, shrink while valid.",
  "approaches": [
    {
      "name": "Brute Force (All Subarrays)",
      "order": 1,
      "intuition": "Try all possible subarrays, calculate sum for each, track minimum length where sum ≥ target.",
      "approach": "Two nested loops to generate subarrays, calculate running sum, update min length.",
      "steps": [
        "Initialize minLen = infinity",
        "For i from 0 to n-1:",
        "  sum = 0",
        "  For j from i to n-1:",
        "    sum += nums[j]",
        "    If sum >= target:",
        "      minLen = min(minLen, j - i + 1)",
        "      Break (optimization)",
        "Return minLen if found, else 0"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(1)",
        "timeExplanation": "Nested loops try all subarrays",
        "spaceExplanation": "Only variables used"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int n = nums.size();\n        int minLen = INT_MAX;\n        \n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                if (sum >= target) {\n                    minLen = min(minLen, j - i + 1);\n                    break;\n                }\n            }\n        }\n        \n        return minLen == INT_MAX ? 0 : minLen;\n    }\n};",
        "java": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        int minLen = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                if (sum >= target) {\n                    minLen = Math.min(minLen, j - i + 1);\n                    break;\n                }\n            }\n        }\n        \n        return minLen == Integer.MAX_VALUE ? 0 : minLen;\n    }\n}",
        "python": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        min_len = float('inf')\n        \n        for i in range(n):\n            total = 0\n            for j in range(i, n):\n                total += nums[j]\n                if total >= target:\n                    min_len = min(min_len, j - i + 1)\n                    break\n        \n        return 0 if min_len == float('inf') else min_len",
        "javascript": "var minSubArrayLen = function(target, nums) {\n    const n = nums.length;\n    let minLen = Infinity;\n    \n    for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = i; j < n; j++) {\n            sum += nums[j];\n            if (sum >= target) {\n                minLen = Math.min(minLen, j - i + 1);\n                break;\n            }\n        }\n    }\n    \n    return minLen === Infinity ? 0 : minLen;\n};"
      }
    },
    {
      "name": "Variable Sliding Window - Optimal",
      "order": 2,
      "intuition": "Expand window by moving right pointer. When sum ≥ target, try shrinking from left while condition holds. Track minimum.",
      "approach": "Two pointers approach. Expand right to grow sum, shrink left when sum is sufficient.",
      "steps": [
        "Initialize left = 0, sum = 0, minLen = infinity",
        "For right from 0 to n-1:",
        "  sum += nums[right]",
        "  While sum >= target:",
        "    minLen = min(minLen, right - left + 1)",
        "    sum -= nums[left]",
        "    left++",
        "Return minLen if found, else 0"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Each element visited at most twice",
        "spaceExplanation": "Only pointer and counter variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int n = nums.size();\n        int left = 0;\n        int sum = 0;\n        int minLen = INT_MAX;\n        \n        for (int right = 0; right < n; right++) {\n            sum += nums[right];\n            \n            while (sum >= target) {\n                minLen = min(minLen, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n        \n        return minLen == INT_MAX ? 0 : minLen;\n    }\n};",
        "java": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        int left = 0;\n        int sum = 0;\n        int minLen = Integer.MAX_VALUE;\n        \n        for (int right = 0; right < n; right++) {\n            sum += nums[right];\n            \n            while (sum >= target) {\n                minLen = Math.min(minLen, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n        \n        return minLen == Integer.MAX_VALUE ? 0 : minLen;\n    }\n}",
        "python": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        left = 0\n        total = 0\n        min_len = float('inf')\n        \n        for right in range(n):\n            total += nums[right]\n            \n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n        \n        return 0 if min_len == float('inf') else min_len",
        "javascript": "var minSubArrayLen = function(target, nums) {\n    const n = nums.length;\n    let left = 0;\n    let sum = 0;\n    let minLen = Infinity;\n    \n    for (let right = 0; right < n; right++) {\n        sum += nums[right];\n        \n        while (sum >= target) {\n            minLen = Math.min(minLen, right - left + 1);\n            sum -= nums[left];\n            left++;\n        }\n    }\n    \n    return minLen === Infinity ? 0 : minLen;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Using if instead of while when shrinking window",
    "Not handling case when no valid subarray exists",
    "Forgetting to subtract nums[left] when shrinking",
    "Not updating minLen before shrinking window"
  ],
  "hints": [
    "This is a minimization problem - find smallest window",
    "Expand right to grow sum, shrink left when valid",
    "Use while loop for shrinking, not if",
    "Return 0 if no valid subarray found"
  ],
  "followUp": [
    "What if array contains negative numbers?",
    "Find maximum length subarray with sum < target?",
    "Count all subarrays with sum >= target?"
  ],
  "companies": ["Amazon", "Google", "Facebook", "Microsoft"],
  "tags": ["array", "sliding-window", "two-pointers", "prefix-sum"],
  "relatedProblems": [
    "Minimum Window Substring",
    "Maximum Size Subarray Sum Equals k",
    "Maximum Length of Repeated Subarray"
  ]
}
