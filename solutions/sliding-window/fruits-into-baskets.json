{
  "questionId": "904",
  "questionSlug": "fruit-into-baskets",
  "title": "Fruit Into Baskets (At Most 2 Distinct)",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/fruit-into-baskets/",
    "videos": [
      {
        "title": "Fruit Into Baskets - Sliding Window",
        "url": "https://www.youtube.com/watch?v=s_zu2dOkq80",
        "channel": "NeetCode",
        "duration": "13:25",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Collect max fruits with 2 baskets (2 types) = Longest Subarray with At Most 2 Distinct Elements. Variable sliding window + HashMap.",
  "approaches": [
    {
      "name": "Brute Force (All Subarrays)",
      "order": 1,
      "intuition": "Try all contiguous subarrays, check if they have at most 2 distinct fruit types, track maximum length.",
      "approach": "Two nested loops to generate subarrays, use set to count distinct types, update max when distinct <= 2.",
      "steps": [
        "Initialize maxFruits = 0",
        "For i from 0 to n-1:",
        "  fruitTypes = set()",
        "  For j from i to n-1:",
        "    fruitTypes.add(fruits[j])",
        "    If fruitTypes.size() <= 2:",
        "      maxFruits = max(maxFruits, j - i + 1)",
        "    Else:",
        "      Break",
        "Return maxFruits"
      ],
      "complexity": {
        "time": "O(nÂ²)",
        "space": "O(1)",
        "timeExplanation": "Nested loops try all subarrays",
        "spaceExplanation": "Set stores at most 3 elements"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int totalFruit(vector<int>& fruits) {\n        int n = fruits.size();\n        int maxFruits = 0;\n        \n        for (int i = 0; i < n; i++) {\n            unordered_set<int> fruitTypes;\n            for (int j = i; j < n; j++) {\n                fruitTypes.insert(fruits[j]);\n                if (fruitTypes.size() <= 2) {\n                    maxFruits = max(maxFruits, j - i + 1);\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        return maxFruits;\n    }\n};",
        "java": "class Solution {\n    public int totalFruit(int[] fruits) {\n        int n = fruits.length;\n        int maxFruits = 0;\n        \n        for (int i = 0; i < n; i++) {\n            Set<Integer> fruitTypes = new HashSet<>();\n            for (int j = i; j < n; j++) {\n                fruitTypes.add(fruits[j]);\n                if (fruitTypes.size() <= 2) {\n                    maxFruits = Math.max(maxFruits, j - i + 1);\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        return maxFruits;\n    }\n}",
        "python": "class Solution:\n    def totalFruit(self, fruits: List[int]) -> int:\n        n = len(fruits)\n        max_fruits = 0\n        \n        for i in range(n):\n            fruit_types = set()\n            for j in range(i, n):\n                fruit_types.add(fruits[j])\n                if len(fruit_types) <= 2:\n                    max_fruits = max(max_fruits, j - i + 1)\n                else:\n                    break\n        \n        return max_fruits",
        "javascript": "var totalFruit = function(fruits) {\n    const n = fruits.length;\n    let maxFruits = 0;\n    \n    for (let i = 0; i < n; i++) {\n        const fruitTypes = new Set();\n        for (let j = i; j < n; j++) {\n            fruitTypes.add(fruits[j]);\n            if (fruitTypes.size <= 2) {\n                maxFruits = Math.max(maxFruits, j - i + 1);\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return maxFruits;\n};"
      }
    },
    {
      "name": "Variable Sliding Window + HashMap - Optimal",
      "order": 2,
      "intuition": "This is exactly 'Longest Substring with At Most K Distinct Characters' where K=2. Use sliding window with HashMap.",
      "approach": "Expand window with right pointer. When distinct types > 2, shrink from left. Track maximum length.",
      "steps": [
        "Initialize left = 0, maxFruits = 0, fruitCount = {}",
        "For right from 0 to n-1:",
        "  fruitCount[fruits[right]]++",
        "  While fruitCount.size() > 2:",
        "    fruitCount[fruits[left]]--",
        "    If fruitCount[fruits[left]] == 0:",
        "      Remove fruits[left] from map",
        "    left++",
        "  maxFruits = max(maxFruits, right - left + 1)",
        "Return maxFruits"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Each element visited at most twice by right and left pointers",
        "spaceExplanation": "HashMap stores at most 3 fruit types"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int totalFruit(vector<int>& fruits) {\n        int n = fruits.size();\n        int left = 0;\n        int maxFruits = 0;\n        unordered_map<int, int> fruitCount;\n        \n        for (int right = 0; right < n; right++) {\n            fruitCount[fruits[right]]++;\n            \n            while (fruitCount.size() > 2) {\n                fruitCount[fruits[left]]--;\n                if (fruitCount[fruits[left]] == 0) {\n                    fruitCount.erase(fruits[left]);\n                }\n                left++;\n            }\n            \n            maxFruits = max(maxFruits, right - left + 1);\n        }\n        \n        return maxFruits;\n    }\n};",
        "java": "class Solution {\n    public int totalFruit(int[] fruits) {\n        int n = fruits.length;\n        int left = 0;\n        int maxFruits = 0;\n        Map<Integer, Integer> fruitCount = new HashMap<>();\n        \n        for (int right = 0; right < n; right++) {\n            fruitCount.put(fruits[right], fruitCount.getOrDefault(fruits[right], 0) + 1);\n            \n            while (fruitCount.size() > 2) {\n                fruitCount.put(fruits[left], fruitCount.get(fruits[left]) - 1);\n                if (fruitCount.get(fruits[left]) == 0) {\n                    fruitCount.remove(fruits[left]);\n                }\n                left++;\n            }\n            \n            maxFruits = Math.max(maxFruits, right - left + 1);\n        }\n        \n        return maxFruits;\n    }\n}",
        "python": "class Solution:\n    def totalFruit(self, fruits: List[int]) -> int:\n        n = len(fruits)\n        left = 0\n        max_fruits = 0\n        fruit_count = {}\n        \n        for right in range(n):\n            fruit_count[fruits[right]] = fruit_count.get(fruits[right], 0) + 1\n            \n            while len(fruit_count) > 2:\n                fruit_count[fruits[left]] -= 1\n                if fruit_count[fruits[left]] == 0:\n                    del fruit_count[fruits[left]]\n                left += 1\n            \n            max_fruits = max(max_fruits, right - left + 1)\n        \n        return max_fruits",
        "javascript": "var totalFruit = function(fruits) {\n    const n = fruits.length;\n    let left = 0;\n    let maxFruits = 0;\n    const fruitCount = new Map();\n    \n    for (let right = 0; right < n; right++) {\n        fruitCount.set(fruits[right], (fruitCount.get(fruits[right]) || 0) + 1);\n        \n        while (fruitCount.size > 2) {\n            fruitCount.set(fruits[left], fruitCount.get(fruits[left]) - 1);\n            if (fruitCount.get(fruits[left]) === 0) {\n                fruitCount.delete(fruits[left]);\n            }\n            left++;\n        }\n        \n        maxFruits = Math.max(maxFruits, right - left + 1);\n    }\n    \n    return maxFruits;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not recognizing this is 'At Most K Distinct' with K=2",
    "Not removing fruit type from map when count becomes 0",
    "Using if instead of while for shrinking",
    "Not updating max length continuously"
  ],
  "hints": [
    "This is identical to 'Longest Substring with At Most 2 Distinct Characters'",
    "Use HashMap to track fruit type counts",
    "Shrink window when you have more than 2 types",
    "Remove type from map only when count = 0"
  ],
  "followUp": [
    "What if you have K baskets instead of 2?",
    "Find minimum fruits collected with 2 types?",
    "Count all subarrays with at most 2 types?"
  ],
  "companies": ["Amazon", "Google", "Bloomberg"],
  "tags": ["array", "sliding-window", "hash-map"],
  "relatedProblems": [
    "Longest Substring with At Most K Distinct Characters",
    "Longest Substring Without Repeating Characters"
  ]
}
