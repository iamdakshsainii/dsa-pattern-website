{
  "questionId": "694d4a3a98494915f3bc8ed1",
  "questionSlug": "path-maximum-sum",
  "title": "Path Maximum Sum",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
    "videos": [
      {
        "title": "Binary Tree Maximum Path Sum - Leetcode 124",
        "url": "https://www.youtube.com/watch?v=Hr5cWUld4vU",
        "channel": "NeetCode",
        "duration": "11:45",
        "language": "English"
      },
      {
        "title": "Maximum Path Sum in Binary Tree",
        "url": "https://www.youtube.com/watch?v=WszrfSwMz58",
        "channel": "take U forward",
        "duration": "18:30",
        "language": "English"
      },
      {
        "title": "Binary Tree Maximum Path Sum Explained",
        "url": "https://www.youtube.com/watch?v=TO5zsKtc1Ic",
        "channel": "TECH DOSE",
        "duration": "16:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Binary Tree Maximum Path Sum",
        "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/",
        "source": "LeetCode"
      },
      {
        "title": "Maximum Path Sum in Binary Tree Tutorial",
        "url": "https://www.geeksforgeeks.org/find-maximum-path-sum-in-a-binary-tree/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Understanding Maximum Path Sum",
        "url": "https://algo.monster/problems/binary_tree_max_path_sum",
        "source": "AlgoMonster"
      }
    ],
    "practice": [
      {
        "title": "Path Sum III",
        "url": "https://leetcode.com/problems/path-sum-iii/",
        "platform": "LeetCode"
      },
      {
        "title": "Diameter of Binary Tree",
        "url": "https://leetcode.com/problems/diameter-of-binary-tree/",
        "platform": "LeetCode"
      },
      {
        "title": "Longest Univalue Path",
        "url": "https://leetcode.com/problems/longest-univalue-path/",
        "platform": "LeetCode"
      },
      {
        "title": "Maximum Sum BST in Binary Tree",
        "url": "https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Path Maximum Sum pattern when finding maximum sum path where path can start/end at any node. Key indicators: maximum path sum, path can curve (go through node and both children), any node to any node path, find highest sum.",
  "approaches": [
    {
      "name": "DFS with Global Maximum (Optimal)",
      "order": 1,
      "intuition": "At each node, calculate maximum path sum that includes this node. Path can either continue through node (using both children) or extend to parent (using one child). Track global maximum for paths curving at each node. Return single-branch path sum to parent.",
      "approach": "Use post-order DFS. At each node, calculate max gain from left and right children (take 0 if negative). Update global max with current node + left gain + right gain (curving path). Return to parent: node value + max(left gain, right gain) (extending path upward).",
      "steps": [
        "Initialize global variable maxSum = Integer.MIN_VALUE",
        "Define DFS function maxGain(node):",
        " - If node is null, return 0",
        " - Recursively get maxGain from left child",
        " - Recursively get maxGain from right child",
        " - leftGain = max(0, leftGain) (ignore negative paths)",
        " - rightGain = max(0, rightGain) (ignore negative paths)",
        " - currentPathSum = node.val + leftGain + rightGain",
        " - Update maxSum = max(maxSum, currentPathSum)",
        " - Return node.val + max(leftGain, rightGain) to parent",
        "Call maxGain(root) and return maxSum"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(h)",
        "timeExplanation": "Visit each node exactly once in post-order traversal. n nodes total. O(n) time.",
        "spaceExplanation": "Recursion call stack depth equals tree height h. O(h) space."
      },
      "code": {
        "cpp": "class Solution {\nprivate:\n    int maxSum = INT_MIN;\n    \n    int maxGain(TreeNode* node) {\n        if (node == nullptr) return 0;\n        \n        // Get max gain from left and right (ignore negative)\n        int leftGain = max(0, maxGain(node->left));\n        int rightGain = max(0, maxGain(node->right));\n        \n        // Current path sum curving through this node\n        int currentPathSum = node->val + leftGain + rightGain;\n        \n        // Update global maximum\n        maxSum = max(maxSum, currentPathSum);\n        \n        // Return max gain if we extend to parent\n        return node->val + max(leftGain, rightGain);\n    }\n    \npublic:\n    int maxPathSum(TreeNode* root) {\n        maxGain(root);\n        return maxSum;\n    }\n};",
        "java": "class Solution {\n    private int maxSum = Integer.MIN_VALUE;\n    \n    private int maxGain(TreeNode node) {\n        if (node == null) return 0;\n        \n        // Get max gain from left and right (ignore negative)\n        int leftGain = Math.max(0, maxGain(node.left));\n        int rightGain = Math.max(0, maxGain(node.right));\n        \n        // Current path sum curving through this node\n        int currentPathSum = node.val + leftGain + rightGain;\n        \n        // Update global maximum\n        maxSum = Math.max(maxSum, currentPathSum);\n        \n        // Return max gain if we extend to parent\n        return node.val + Math.max(leftGain, rightGain);\n    }\n    \n    public int maxPathSum(TreeNode root) {\n        maxGain(root);\n        return maxSum;\n    }\n}",
        "python": "class Solution:\n    def maxPathSum(self, root: TreeNode) -> int:\n        max_sum = float('-inf')\n        \n        def max_gain(node):\n            nonlocal max_sum\n            \n            if not node:\n                return 0\n            \n            # Get max gain from left and right (ignore negative)\n            left_gain = max(0, max_gain(node.left))\n            right_gain = max(0, max_gain(node.right))\n            \n            # Current path sum curving through this node\n            current_path_sum = node.val + left_gain + right_gain\n            \n            # Update global maximum\n            max_sum = max(max_sum, current_path_sum)\n            \n            # Return max gain if we extend to parent\n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return max_sum",
        "javascript": "function maxPathSum(root) {\n    let maxSum = -Infinity;\n    \n    function maxGain(node) {\n        if (node === null) return 0;\n        \n        // Get max gain from left and right (ignore negative)\n        const leftGain = Math.max(0, maxGain(node.left));\n        const rightGain = Math.max(0, maxGain(node.right));\n        \n        // Current path sum curving through this node\n        const currentPathSum = node.val + leftGain + rightGain;\n        \n        // Update global maximum\n        maxSum = Math.max(maxSum, currentPathSum);\n        \n        // Return max gain if we extend to parent\n        return node.val + Math.max(leftGain, rightGain);\n    }\n    \n    maxGain(root);\n    return maxSum;\n}"
      }
    },
    {
      "name": "DFS with Return Tuple",
      "order": 2,
      "intuition": "Similar to first approach but return both max path through node and max single branch. This makes the logic more explicit. Return tuple: (max path including current node, max single branch from current node).",
      "approach": "At each node, calculate two values: max path sum that curves through node, and max single-branch sum extending upward. Return both. Use post-order traversal to get values from children first.",
      "steps": [
        "Define DFS function that returns (maxPathThrough, maxBranch):",
        " - If node is null, return (MIN_VALUE, 0)",
        " - Get (leftPath, leftBranch) from left child",
        " - Get (rightPath, rightBranch) from right child",
        " - maxBranch = node.val + max(0, leftBranch, rightBranch)",
        " - maxPathThrough = node.val + max(0, leftBranch) + max(0, rightBranch)",
        " - maxPath = max(leftPath, rightPath, maxPathThrough)",
        " - Return (maxPath, maxBranch)",
        "Call DFS and return maxPath from result tuple"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(h)",
        "timeExplanation": "Visit each node once. n nodes in tree. O(n) time complexity.",
        "spaceExplanation": "Recursion depth equals tree height h. O(h) space for call stack."
      },
      "code": {
        "cpp": "class Solution {\nprivate:\n    pair<int, int> dfs(TreeNode* node) {\n        if (node == nullptr) {\n            return {INT_MIN, 0};\n        }\n        \n        auto [leftPath, leftBranch] = dfs(node->left);\n        auto [rightPath, rightBranch] = dfs(node->right);\n        \n        // Max single branch extending upward\n        int maxBranch = node->val + max({0, leftBranch, rightBranch});\n        \n        // Max path curving through current node\n        int maxPathThrough = node->val + max(0, leftBranch) + max(0, rightBranch);\n        \n        // Overall max path in this subtree\n        int maxPath = max({leftPath, rightPath, maxPathThrough});\n        \n        return {maxPath, maxBranch};\n    }\n    \npublic:\n    int maxPathSum(TreeNode* root) {\n        return dfs(root).first;\n    }\n};",
        "java": "class Solution {\n    private class Result {\n        int maxPath;\n        int maxBranch;\n        Result(int p, int b) {\n            maxPath = p;\n            maxBranch = b;\n        }\n    }\n    \n    private Result dfs(TreeNode node) {\n        if (node == null) {\n            return new Result(Integer.MIN_VALUE, 0);\n        }\n        \n        Result left = dfs(node.left);\n        Result right = dfs(node.right);\n        \n        // Max single branch extending upward\n        int maxBranch = node.val + Math.max(0, Math.max(left.maxBranch, right.maxBranch));\n        \n        // Max path curving through current node\n        int maxPathThrough = node.val + Math.max(0, left.maxBranch) + Math.max(0, right.maxBranch);\n        \n        // Overall max path in this subtree\n        int maxPath = Math.max(Math.max(left.maxPath, right.maxPath), maxPathThrough);\n        \n        return new Result(maxPath, maxBranch);\n    }\n    \n    public int maxPathSum(TreeNode root) {\n        return dfs(root).maxPath;\n    }\n}",
        "python": "class Solution:\n    def maxPathSum(self, root: TreeNode) -> int:\n        def dfs(node):\n            if not node:\n                return (float('-inf'), 0)\n            \n            left_path, left_branch = dfs(node.left)\n            right_path, right_branch = dfs(node.right)\n            \n            # Max single branch extending upward\n            max_branch = node.val + max(0, left_branch, right_branch)\n            \n            # Max path curving through current node\n            max_path_through = node.val + max(0, left_branch) + max(0, right_branch)\n            \n            # Overall max path in this subtree\n            max_path = max(left_path, right_path, max_path_through)\n            \n            return (max_path, max_branch)\n        \n        return dfs(root)[0]",
        "javascript": "function maxPathSum(root) {\n    function dfs(node) {\n        if (node === null) {\n            return [-Infinity, 0];\n        }\n        \n        const [leftPath, leftBranch] = dfs(node.left);\n        const [rightPath, rightBranch] = dfs(node.right);\n        \n        // Max single branch extending upward\n        const maxBranch = node.val + Math.max(0, leftBranch, rightBranch);\n        \n        // Max path curving through current node\n        const maxPathThrough = node.val + Math.max(0, leftBranch) + Math.max(0, rightBranch);\n        \n        // Overall max path in this subtree\n        const maxPath = Math.max(leftPath, rightPath, maxPathThrough);\n        \n        return [maxPath, maxBranch];\n    }\n    \n    return dfs(root)[0];\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not handling negative node values correctly",
    "Forgetting to ignore negative path contributions (use max(0, gain))",
    "Not considering single-node paths (just the node itself)",
    "Returning curving path sum to parent instead of single branch",
    "Using Integer.MAX_VALUE instead of MIN_VALUE for initialization",
    "Not updating global maximum at every node",
    "Confusing path that extends upward vs path that curves through node",
    "Forgetting that path must have at least one node"
  ],
  "hints": [
    "Path can start and end at any nodes, including curving through a node",
    "At each node, decide: extend path upward or curve through this node",
    "Use max(0, childGain) to ignore negative contributions",
    "Track global maximum separately from value returned to parent",
    "Post-order traversal: process children before parent",
    "Return single-branch sum to parent, update global with curving sum",
    "Path can be just a single node if all others are negative"
  ],
  "followUp": [
    "What if path must go through root?",
    "How to return the actual path nodes instead of just sum?",
    "What if you need the longest path instead of maximum sum?",
    "How to handle if path must include at least k nodes?",
    "What if you need to find top K maximum path sums?",
    "How to solve if tree has cycles (becomes a graph)?",
    "What if node values can be floating point?",
    "How to handle very large trees that don't fit in memory?"
  ],
  "companies": [
    "Amazon",
    "Google",
    "Facebook",
    "Microsoft",
    "Apple",
    "Bloomberg",
    "Adobe",
    "Uber",
    "Airbnb"
  ],
  "tags": [
    "Tree",
    "Binary Tree",
    "Depth-First Search",
    "Dynamic Programming",
    "Recursion"
  ],
  "relatedProblems": [
    "Path Sum",
    "Path Sum II",
    "Path Sum III",
    "Diameter of Binary Tree",
    "Longest Univalue Path",
    "Maximum Sum BST in Binary Tree",
    "Sum Root to Leaf Numbers",
    "Binary Tree Maximum Path Sum II"
  ]
}