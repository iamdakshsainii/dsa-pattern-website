{
  "questionId": "694d4a3a98494915f3bc8ecb",
  "questionSlug": "binary-tree-path-sum",
  "title": "Binary Tree Path Sum",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/path-sum/",
    "videos": [
      {
        "title": "Path Sum - LeetCode 112",
        "url": "https://www.youtube.com/watch?v=LSKQyOz_P8I",
        "channel": "NeetCode",
        "duration": "8:15",
        "language": "English"
      },
      {
        "title": "Binary Tree Path Sum Problem",
        "url": "https://www.youtube.com/watch?v=Hg82DzMemMI",
        "channel": "TECH DOSE",
        "duration": "10:45",
        "language": "English"
      },
      {
        "title": "Path Sum Explained",
        "url": "https://www.youtube.com/watch?v=gj8VJsJRF9E",
        "channel": "Kevin Naughton Jr.",
        "duration": "7:30",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Path Sum Problem",
        "url": "https://leetcode.com/problems/path-sum/solutions/",
        "source": "LeetCode"
      },
      {
        "title": "Root to Leaf Path Sum",
        "url": "https://www.geeksforgeeks.org/root-to-leaf-path-sum-equal-to-a-given-number/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Binary Tree Path Sum Pattern",
        "url": "https://algo.monster/problems/path_sum",
        "source": "AlgoMonster"
      }
    ],
    "practice": [
      {
        "title": "Path Sum II",
        "url": "https://leetcode.com/problems/path-sum-ii/",
        "platform": "LeetCode"
      },
      {
        "title": "Path Sum III",
        "url": "https://leetcode.com/problems/path-sum-iii/",
        "platform": "LeetCode"
      },
      {
        "title": "Binary Tree Maximum Path Sum",
        "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
        "platform": "LeetCode"
      },
      {
        "title": "Sum Root to Leaf Numbers",
        "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Binary Tree Path Sum pattern when checking if root-to-leaf path exists with given sum. Key indicators: root to leaf path, target sum, path validation, leaf node requirement, sum along path equals target.",
  "approaches": [
    {
      "name": "Recursive DFS",
      "order": 1,
      "intuition": "At each node, subtract current node's value from target sum. Recursively check left and right subtrees with remaining sum. Base case: if we reach a leaf node (no children) and remaining sum equals node value, path exists. If node is null, return false.",
      "approach": "Use DFS recursion. At each node, check if it's a leaf with value equal to remaining target. If not, recursively check left and right children with updated target (target - node.val). Return true if either subtree has valid path.",
      "steps": [
        "Base case: If root is null, return false",
        "Leaf node check: If node has no children:",
        "  - Return true if node.val == targetSum",
        "  - Return false otherwise",
        "Calculate remaining sum: targetSum - root.val",
        "Recursively check left subtree: hasPathSum(root.left, remainingSum)",
        "Recursively check right subtree: hasPathSum(root.right, remainingSum)",
        "Return true if either left OR right has valid path"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(h)",
        "timeExplanation": "Visit each node once in DFS traversal. n nodes total. O(n) time.",
        "spaceExplanation": "Recursion stack depth equals tree height h. O(h) space. Worst case O(n) for skewed tree."
      },
      "code": {
        "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        // Base case: empty tree\n        if (root == nullptr) {\n            return false;\n        }\n        \n        // Leaf node: check if value equals target\n        if (root->left == nullptr && root->right == nullptr) {\n            return root->val == targetSum;\n        }\n        \n        // Recursive case: check left and right subtrees\n        int remainingSum = targetSum - root->val;\n        return hasPathSum(root->left, remainingSum) || \n               hasPathSum(root->right, remainingSum);\n    }\n};",
        "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        // Base case: empty tree\n        if (root == null) {\n            return false;\n        }\n        \n        // Leaf node: check if value equals target\n        if (root.left == null && root.right == null) {\n            return root.val == targetSum;\n        }\n        \n        // Recursive case: check left and right subtrees\n        int remainingSum = targetSum - root.val;\n        return hasPathSum(root.left, remainingSum) || \n               hasPathSum(root.right, remainingSum);\n    }\n}",
        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\n        # Base case: empty tree\n        if not root:\n            return False\n        \n        # Leaf node: check if value equals target\n        if not root.left and not root.right:\n            return root.val == targetSum\n        \n        # Recursive case: check left and right subtrees\n        remaining_sum = targetSum - root.val\n        return (self.hasPathSum(root.left, remaining_sum) or \n                self.hasPathSum(root.right, remaining_sum))",
        "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\nfunction hasPathSum(root, targetSum) {\n    // Base case: empty tree\n    if (root === null) {\n        return false;\n    }\n    \n    // Leaf node: check if value equals target\n    if (root.left === null && root.right === null) {\n        return root.val === targetSum;\n    }\n    \n    // Recursive case: check left and right subtrees\n    const remainingSum = targetSum - root.val;\n    return hasPathSum(root.left, remainingSum) || \n           hasPathSum(root.right, remainingSum);\n}"
      }
    },
    {
      "name": "Iterative DFS with Stack",
      "order": 2,
      "intuition": "Use stack to simulate recursion. Store pairs of (node, remainingSum) in stack. Pop node and check if it's a leaf with remaining sum equal to its value. If not leaf, push children with updated remaining sum. Continue until stack is empty or valid path found.",
      "approach": "Initialize stack with (root, targetSum). While stack not empty, pop (node, sum). If leaf and node.val == sum, return true. Otherwise, push children with updated sum. Return false if stack empties without finding path.",
      "steps": [
        "If root is null, return false",
        "Initialize stack with (root, targetSum)",
        "While stack is not empty:",
        "  - Pop (node, remainingSum) from stack",
        "  - If node is leaf (no children):",
        "    - If node.val == remainingSum, return true",
        "  - If node has left child:",
        "    - Push (left, remainingSum - node.val) to stack",
        "  - If node has right child:",
        "    - Push (right, remainingSum - node.val) to stack",
        "Return false (no valid path found)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(h)",
        "timeExplanation": "Visit each node once. n nodes total. O(n) time.",
        "spaceExplanation": "Stack stores at most h nodes (tree height) at any time. O(h) space."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if (root == nullptr) return false;\n        \n        stack<pair<TreeNode*, int>> stk;\n        stk.push({root, targetSum});\n        \n        while (!stk.empty()) {\n            auto [node, remainingSum] = stk.top();\n            stk.pop();\n            \n            // Check if leaf node\n            if (node->left == nullptr && node->right == nullptr) {\n                if (node->val == remainingSum) {\n                    return true;\n                }\n            }\n            \n            // Add children to stack\n            if (node->right != nullptr) {\n                stk.push({node->right, remainingSum - node->val});\n            }\n            if (node->left != nullptr) {\n                stk.push({node->left, remainingSum - node->val});\n            }\n        }\n        \n        return false;\n    }\n};",
        "java": "class Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null) return false;\n        \n        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\n        stack.push(new Pair<>(root, targetSum));\n        \n        while (!stack.isEmpty()) {\n            Pair<TreeNode, Integer> current = stack.pop();\n            TreeNode node = current.getKey();\n            int remainingSum = current.getValue();\n            \n            // Check if leaf node\n            if (node.left == null && node.right == null) {\n                if (node.val == remainingSum) {\n                    return true;\n                }\n            }\n            \n            // Add children to stack\n            if (node.right != null) {\n                stack.push(new Pair<>(node.right, remainingSum - node.val));\n            }\n            if (node.left != null) {\n                stack.push(new Pair<>(node.left, remainingSum - node.val));\n            }\n        }\n        \n        return false;\n    }\n}",
        "python": "class Solution:\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\n        if not root:\n            return False\n        \n        stack = [(root, targetSum)]\n        \n        while stack:\n            node, remaining_sum = stack.pop()\n            \n            # Check if leaf node\n            if not node.left and not node.right:\n                if node.val == remaining_sum:\n                    return True\n            \n            # Add children to stack\n            if node.right:\n                stack.append((node.right, remaining_sum - node.val))\n            if node.left:\n                stack.append((node.left, remaining_sum - node.val))\n        \n        return False",
        "javascript": "function hasPathSum(root, targetSum) {\n    if (root === null) return false;\n    \n    const stack = [[root, targetSum]];\n    \n    while (stack.length > 0) {\n        const [node, remainingSum] = stack.pop();\n        \n        // Check if leaf node\n        if (node.left === null && node.right === null) {\n            if (node.val === remainingSum) {\n                return true;\n            }\n        }\n        \n        // Add children to stack\n        if (node.right !== null) {\n            stack.push([node.right, remainingSum - node.val]);\n        }\n        if (node.left !== null) {\n            stack.push([node.left, remainingSum - node.val]);\n        }\n    }\n    \n    return false;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not checking if node is a leaf before returning true (internal nodes don't count)",
    "Forgetting to handle null/empty tree case",
    "Checking targetSum == 0 at every node instead of only at leaves",
    "Not subtracting current node value before recursive calls",
    "Using AND instead of OR when checking left and right subtrees",
    "Returning true for internal nodes that match the target",
    "Not handling negative node values correctly"
  ],
  "hints": [
    "A valid path must go from root to a LEAF node (not just any node)",
    "Subtract current node's value from target as you traverse down",
    "Use DFS (recursive or iterative) to explore all root-to-leaf paths",
    "At leaf node, check if remaining sum equals leaf's value",
    "Return true if ANY path has the target sum (use OR for left/right)",
    "Base case: null node returns false, leaf node checks value"
  ],
  "followUp": [
    "How to return the actual path(s) that sum to target? (Path Sum II)",
    "What if path doesn't need to start at root or end at leaf? (Path Sum III)",
    "How to count all paths with given sum?",
    "What if you need to find maximum path sum instead?",
    "How to handle if tree can have cycles (not a tree anymore)?",
    "Can you solve with constant space (no recursion/stack)?",
    "What if target sum changes for each query?",
    "How to find all unique path sums in the tree?"
  ],
  "companies": [
    "Amazon",
    "Microsoft",
    "Facebook",
    "Google",
    "Apple",
    "Bloomberg",
    "Adobe"
  ],
  "tags": [
    "Tree",
    "Binary Tree",
    "Depth-First Search",
    "Recursion",
    "Backtracking"
  ],
  "relatedProblems": [
    "Path Sum II",
    "Path Sum III",
    "Binary Tree Maximum Path Sum",
    "Sum Root to Leaf Numbers",
    "Path Sum IV",
    "Minimum Depth of Binary Tree",
    "All Paths From Source to Target"
  ]
}
