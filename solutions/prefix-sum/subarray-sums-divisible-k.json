{
  "questionId": "694d4a3a98494915f3bc8e9e",
  "questionSlug": "subarray-sums-divisible-k",
  "title": "Subarray Sums Divisible K",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/subarray-sums-divisible-by-k/description/",
    "videos": [
      {
        "title": "Subarray Sums Divisible by K - Leetcode 974",
        "url": "https://www.youtube.com/watch?v=ufXxc8K1xHM",
        "channel": "NeetCode",
        "duration": "11:45",
        "language": "English"
      },
      {
        "title": "Count Subarrays Divisible by K",
        "url": "https://www.youtube.com/watch?v=QM0klnvTQzk",
        "channel": "TECH DOSE",
        "duration": "18:30",
        "language": "English"
      },
      {
        "title": "Modular Arithmetic for Subarray Sum",
        "url": "https://www.youtube.com/watch?v=7Jajy5jKPHg",
        "channel": "take U forward",
        "duration": "16:50",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Subarray Sums Divisible by K Solution",
        "url": "https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/",
        "source": "LeetCode"
      },
      {
        "title": "Count Subarrays with Sum Divisible by K",
        "url": "https://www.geeksforgeeks.org/count-sub-arrays-sum-divisible-k/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Modulo Prefix Sum Technique",
        "url": "https://algo.monster/problems/subarray_sums_divisible_k",
        "source": "AlgoMonster"
      }
    ],
    "practice": [
      {
        "title": "Subarray Sum Equals K",
        "url": "https://leetcode.com/problems/subarray-sum-equals-k/",
        "platform": "LeetCode"
      },
      {
        "title": "Continuous Subarray Sum",
        "url": "https://leetcode.com/problems/continuous-subarray-sum/",
        "platform": "LeetCode"
      },
      {
        "title": "Make Sum Divisible by P",
        "url": "https://leetcode.com/problems/make-sum-divisible-by-p/",
        "platform": "LeetCode"
      },
      {
        "title": "Count Number of Nice Subarrays",
        "url": "https://leetcode.com/problems/count-number-of-nice-subarrays/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Subarray Sums Divisible by K pattern when counting subarrays with sum divisible by K. Key indicators: count subarrays, divisible by K, modular arithmetic, remainder tracking.",
  "approaches": [
    {
      "name": "HashMap with Modulo Prefix Sum (Optimal)",
      "order": 1,
      "intuition": "If two prefix sums have same remainder when divided by K, the subarray between them has sum divisible by K. Use hashmap to track frequency of each remainder seen. At each position, count how many times current remainder appeared before - those represent valid subarrays. Handle negative remainders by adding K.",
      "approach": "Maintain running prefix sum modulo K. Store frequency of each remainder in hashmap. When remainder repeats, all previous occurrences form valid subarrays with current position. Use formula: count += frequency[remainder].",
      "steps": [
        "Initialize hashmap with {0: 1} (empty subarray)",
        "Initialize currentSum = 0, count = 0",
        "For each element in array:",
        " - currentSum += element",
        " - remainder = currentSum % K",
        " - Handle negative: remainder = (remainder + K) % K",
        " - count += frequency of remainder in hashmap",
        " - Increment frequency of remainder in hashmap",
        "Return count"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(min(n, K))",
        "timeExplanation": "Single pass through array. HashMap operations are O(1). Total: O(n) time.",
        "spaceExplanation": "HashMap stores at most K unique remainders (0 to K-1). O(min(n, K)) space."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> remainderCount;\n        remainderCount[0] = 1; // Empty subarray\n        \n        int currentSum = 0;\n        int count = 0;\n        \n        for (int num : nums) {\n            currentSum += num;\n            \n            // Calculate remainder (handle negative)\n            int remainder = currentSum % k;\n            if (remainder < 0) {\n                remainder += k;\n            }\n            \n            // Count subarrays ending at current position\n            if (remainderCount.find(remainder) != remainderCount.end()) {\n                count += remainderCount[remainder];\n            }\n            \n            // Update frequency of remainder\n            remainderCount[remainder]++;\n        }\n        \n        return count;\n    }\n};",
        "java": "class Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        Map<Integer, Integer> remainderCount = new HashMap<>();\n        remainderCount.put(0, 1); // Empty subarray\n        \n        int currentSum = 0;\n        int count = 0;\n        \n        for (int num : nums) {\n            currentSum += num;\n            \n            // Calculate remainder (handle negative)\n            int remainder = currentSum % k;\n            if (remainder < 0) {\n                remainder += k;\n            }\n            \n            // Count subarrays ending at current position\n            count += remainderCount.getOrDefault(remainder, 0);\n            \n            // Update frequency of remainder\n            remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0) + 1);\n        }\n        \n        return count;\n    }\n}",
        "python": "class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        remainder_count = {0: 1}  # Empty subarray\n        \n        current_sum = 0\n        count = 0\n        \n        for num in nums:\n            current_sum += num\n            \n            # Calculate remainder (handle negative automatically in Python)\n            remainder = current_sum % k\n            \n            # Count subarrays ending at current position\n            if remainder in remainder_count:\n                count += remainder_count[remainder]\n            \n            # Update frequency of remainder\n            remainder_count[remainder] = remainder_count.get(remainder, 0) + 1\n        \n        return count",
        "javascript": "function subarraysDivByK(nums, k) {\n    const remainderCount = new Map();\n    remainderCount.set(0, 1); // Empty subarray\n    \n    let currentSum = 0;\n    let count = 0;\n    \n    for (const num of nums) {\n        currentSum += num;\n        \n        // Calculate remainder (handle negative)\n        let remainder = currentSum % k;\n        if (remainder < 0) {\n            remainder += k;\n        }\n        \n        // Count subarrays ending at current position\n        if (remainderCount.has(remainder)) {\n            count += remainderCount.get(remainder);\n        }\n        \n        // Update frequency of remainder\n        remainderCount.set(remainder, (remainderCount.get(remainder) || 0) + 1);\n    }\n    \n    return count;\n}"
      }
    },
    {
      "name": "Brute Force (Check All Subarrays)",
      "order": 2,
      "intuition": "Check every possible subarray. Calculate sum for each and check if divisible by K. Count valid subarrays. Simple but inefficient.",
      "approach": "Use nested loops to generate all subarrays. For each subarray, calculate sum and check if sum % K == 0. Count matching subarrays.",
      "steps": [
        "Initialize count = 0",
        "For each starting index i from 0 to n-1:",
        " - Initialize sum = 0",
        " - For each ending index j from i to n-1:",
        "   - sum += nums[j]",
        "   - If sum % K == 0:",
        "     - count++",
        "Return count"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(1)",
        "timeExplanation": "Two nested loops check all n² subarrays. O(n²) time complexity.",
        "spaceExplanation": "Only constant extra space for variables. O(1) space."
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int count = 0;\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                if (sum % k == 0) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n};",
        "java": "class Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int count = 0;\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                if (sum % k == 0) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n}",
        "python": "class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            total = 0\n            for j in range(i, n):\n                total += nums[j]\n                if total % k == 0:\n                    count += 1\n        \n        return count",
        "javascript": "function subarraysDivByK(nums, k) {\n    let count = 0;\n    const n = nums.length;\n    \n    for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = i; j < n; j++) {\n            sum += nums[j];\n            if (sum % k === 0) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not handling negative remainders correctly (must add K to make positive)",
    "Forgetting to initialize hashmap with {0: 1}",
    "Using wrong formula: checking sum % K directly instead of remainder matching",
    "Not understanding why same remainders indicate divisible subarray",
    "Checking and updating hashmap in wrong order",
    "Integer overflow with large sums",
    "Confusing remainder 0 with no remainder (0 is valid remainder)",
    "In Python, forgetting that % already handles negatives correctly"
  ],
  "hints": [
    "If (prefixSum[j] - prefixSum[i]) % K == 0, then prefixSum[j] % K == prefixSum[i] % K",
    "Same remainder means subarray between has sum divisible by K",
    "Track frequency of each remainder, not just presence",
    "Handle negative remainders: (x % K + K) % K",
    "Python's % operator handles negatives differently than C++/Java",
    "Initialize with {0: 1} for subarrays starting at index 0",
    "Use combinatorics: if remainder appears n times, it forms n*(n-1)/2 pairs? No, use frequency count incrementally"
  ],
  "followUp": [
    "What if you need to return the actual subarrays?",
    "How to find longest subarray with sum divisible by K?",
    "What if K changes dynamically (Q queries)?",
    "How to count subarrays with sum NOT divisible by K?",
    "What if array elements are always positive?",
    "How to solve for 2D array (submatrix divisible by K)?",
    "What if you need count with remainder equal to specific value R?",
    "How to handle very large K values?"
  ],
  "companies": [
    "Google",
    "Facebook",
    "Amazon",
    "Microsoft",
    "Apple",
    "Bloomberg",
    "Adobe",
    "Uber"
  ],
  "tags": [
    "Array",
    "Hash Table",
    "Prefix Sum",
    "Modular Arithmetic"
  ],
  "relatedProblems": [
    "Subarray Sum Equals K",
    "Continuous Subarray Sum",
    "Make Sum Divisible by P",
    "Count Number of Nice Subarrays",
    "Binary Subarrays With Sum",
    "Contiguous Array",
    "Find the Longest Substring Containing Vowels in Even Counts",
    "Number of Ways to Split Array"
  ]
}