{
  "questionId": "525",
  "questionSlug": "contiguous-array",
  "title": "Contiguous Array",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/contiguous-array/",
    "videos": [
      {
        "title": "Contiguous Array - HashMap Solution",
        "url": "https://www.youtube.com/watch?v=agB1LyObtnA",
        "channel": "NeetCode",
        "duration": "10:55",
        "language": "English"
      },
      {
        "title": "Equal 0s and 1s Subarray",
        "url": "https://www.youtube.com/watch?v=9ZyLjjk536U",
        "channel": "take U forward",
        "duration": "13:40",
        "language": "English"
      },
      {
        "title": "Contiguous Array Explained",
        "url": "https://www.youtube.com/watch?v=yCZZO1jgT34",
        "channel": "Kevin Naughton Jr.",
        "duration": "11:25",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Contiguous Array - LeetCode Official",
        "url": "https://leetcode.com/problems/contiguous-array/editorial/",
        "source": "LeetCode"
      },
      {
        "title": "Longest Subarray with Equal 0s and 1s",
        "url": "https://takeuforward.org/data-structure/length-of-the-longest-subarray-with-zero-sum/",
        "source": "takeuforward"
      },
      {
        "title": "Contiguous Array - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/contiguous-array/",
        "platform": "LeetCode"
      },
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://practice.geeksforgeeks.org/problems/largest-subarray-of-0s-and-1s/",
        "platform": "GeeksforGeeks"
      }
    ]
  },
  "patternTriggers": "Equal 0s and 1s? Convert 0→-1, find longest subarray with sum=0. Track cumulative sum in hashmap.",
  "approaches": [
    {
      "name": "Brute Force - Check All Subarrays",
      "order": 1,
      "intuition": "Generate all subarrays, count 0s and 1s, track maximum length where counts are equal.",
      "approach": "Two nested loops to generate subarrays, count 0s and 1s for each.",
      "steps": [
        "maxLen = 0",
        "For each start i:",
        "  zeros = 0, ones = 0",
        "  For each end j from i:",
        "    If nums[j] == 0: zeros++",
        "    Else: ones++",
        "    If zeros == ones:",
        "      maxLen = max(maxLen, j - i + 1)",
        "Return maxLen"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(1)",
        "timeExplanation": "Two nested loops",
        "spaceExplanation": "Constant space"
      },
      "code": {
        "cpp": "int findMaxLength(vector<int>& nums) {\n    int n = nums.size();\n    int maxLen = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int zeros = 0, ones = 0;\n        for (int j = i; j < n; j++) {\n            if (nums[j] == 0) zeros++;\n            else ones++;\n            \n            if (zeros == ones) {\n                maxLen = max(maxLen, j - i + 1);\n            }\n        }\n    }\n    \n    return maxLen;\n}",
        "java": "public int findMaxLength(int[] nums) {\n    int n = nums.length;\n    int maxLen = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int zeros = 0, ones = 0;\n        for (int j = i; j < n; j++) {\n            if (nums[j] == 0) zeros++;\n            else ones++;\n            \n            if (zeros == ones) {\n                maxLen = Math.max(maxLen, j - i + 1);\n            }\n        }\n    }\n    \n    return maxLen;\n}",
        "python": "def findMaxLength(nums):\n    n = len(nums)\n    max_len = 0\n    \n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if nums[j] == 0:\n                zeros += 1\n            else:\n                ones += 1\n            \n            if zeros == ones:\n                max_len = max(max_len, j - i + 1)\n    \n    return max_len",
        "javascript": "function findMaxLength(nums) {\n    const n = nums.length;\n    let maxLen = 0;\n    \n    for (let i = 0; i < n; i++) {\n        let zeros = 0, ones = 0;\n        for (let j = i; j < n; j++) {\n            if (nums[j] === 0) zeros++;\n            else ones++;\n            \n            if (zeros === ones) {\n                maxLen = Math.max(maxLen, j - i + 1);\n            }\n        }\n    }\n    \n    return maxLen;\n}"
      }
    },
    {
      "name": "Convert to Sum Problem with Tracking",
      "order": 2,
      "intuition": "Convert 0 to -1, 1 stays 1. Equal 0s/1s means sum = 0. Find longest subarray with sum 0 using array.",
      "approach": "Replace 0 with -1. Calculate cumulative sums. Track first occurrence of each sum.",
      "steps": [
        "Replace all 0s with -1",
        "Calculate cumulative sum array",
        "For each index i:",
        "  If sum == 0: maxLen = i + 1",
        "  Search for same sum at earlier index j:",
        "    maxLen = max(maxLen, i - j)",
        "Return maxLen"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(n)",
        "timeExplanation": "Finding first occurrence takes O(n) for each position",
        "spaceExplanation": "Cumulative sum array"
      },
      "code": {
        "cpp": "int findMaxLength(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> arr(n);\n    \n    // Convert 0 to -1\n    for (int i = 0; i < n; i++) {\n        arr[i] = (nums[i] == 0) ? -1 : 1;\n    }\n    \n    // Calculate cumulative sums\n    vector<int> cumSum(n);\n    cumSum[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        cumSum[i] = cumSum[i-1] + arr[i];\n    }\n    \n    int maxLen = 0;\n    for (int i = 0; i < n; i++) {\n        if (cumSum[i] == 0) {\n            maxLen = max(maxLen, i + 1);\n        }\n        \n        // Find first occurrence of same sum\n        for (int j = 0; j < i; j++) {\n            if (cumSum[j] == cumSum[i]) {\n                maxLen = max(maxLen, i - j);\n                break;\n            }\n        }\n    }\n    \n    return maxLen;\n}",
        "java": "public int findMaxLength(int[] nums) {\n    int n = nums.length;\n    int[] arr = new int[n];\n    \n    for (int i = 0; i < n; i++) {\n        arr[i] = (nums[i] == 0) ? -1 : 1;\n    }\n    \n    int[] cumSum = new int[n];\n    cumSum[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        cumSum[i] = cumSum[i-1] + arr[i];\n    }\n    \n    int maxLen = 0;\n    for (int i = 0; i < n; i++) {\n        if (cumSum[i] == 0) {\n            maxLen = Math.max(maxLen, i + 1);\n        }\n        \n        for (int j = 0; j < i; j++) {\n            if (cumSum[j] == cumSum[i]) {\n                maxLen = Math.max(maxLen, i - j);\n                break;\n            }\n        }\n    }\n    \n    return maxLen;\n}",
        "python": "def findMaxLength(nums):\n    n = len(nums)\n    arr = [-1 if x == 0 else 1 for x in nums]\n    \n    cum_sum = [0] * n\n    cum_sum[0] = arr[0]\n    for i in range(1, n):\n        cum_sum[i] = cum_sum[i-1] + arr[i]\n    \n    max_len = 0\n    for i in range(n):\n        if cum_sum[i] == 0:\n            max_len = max(max_len, i + 1)\n        \n        for j in range(i):\n            if cum_sum[j] == cum_sum[i]:\n                max_len = max(max_len, i - j)\n                break\n    \n    return max_len",
        "javascript": "function findMaxLength(nums) {\n    const n = nums.length;\n    const arr = nums.map(x => x === 0 ? -1 : 1);\n    \n    const cumSum = new Array(n);\n    cumSum[0] = arr[0];\n    for (let i = 1; i < n; i++) {\n        cumSum[i] = cumSum[i-1] + arr[i];\n    }\n    \n    let maxLen = 0;\n    for (let i = 0; i < n; i++) {\n        if (cumSum[i] === 0) {\n            maxLen = Math.max(maxLen, i + 1);\n        }\n        \n        for (let j = 0; j < i; j++) {\n            if (cumSum[j] === cumSum[i]) {\n                maxLen = Math.max(maxLen, i - j);\n                break;\n            }\n        }\n    }\n    \n    return maxLen;\n}"
      }
    },
    {
      "name": "HashMap with Cumulative Sum - Optimal",
      "order": 3,
      "intuition": "Convert 0→-1. Track cumulative sum in hashmap with first occurrence index. Same sum means equal 0s and 1s between.",
      "approach": "Treat 0 as -1. Running sum in hashmap. When sum repeats, calculate length.",
      "steps": [
        "map = {0: -1}, sum = 0, maxLen = 0",
        "For i from 0 to n-1:",
        "  sum += (nums[i] == 0 ? -1 : 1)",
        "  If sum in map:",
        "    maxLen = max(maxLen, i - map[sum])",
        "  Else:",
        "    map[sum] = i",
        "Return maxLen"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass with O(1) operations",
        "spaceExplanation": "HashMap stores at most n sums"
      },
      "code": {
        "cpp": "int findMaxLength(vector<int>& nums) {\n    unordered_map<int, int> sumIndex;\n    sumIndex[0] = -1;  // For subarrays starting from index 0\n    \n    int sum = 0;\n    int maxLen = 0;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        // Treat 0 as -1, 1 as +1\n        sum += (nums[i] == 0) ? -1 : 1;\n        \n        if (sumIndex.find(sum) != sumIndex.end()) {\n            maxLen = max(maxLen, i - sumIndex[sum]);\n        } else {\n            // Store first occurrence only\n            sumIndex[sum] = i;\n        }\n    }\n    \n    return maxLen;\n}",
        "java": "public int findMaxLength(int[] nums) {\n    HashMap<Integer, Integer> sumIndex = new HashMap<>();\n    sumIndex.put(0, -1);\n    \n    int sum = 0;\n    int maxLen = 0;\n    \n    for (int i = 0; i < nums.length; i++) {\n        sum += (nums[i] == 0) ? -1 : 1;\n        \n        if (sumIndex.containsKey(sum)) {\n            maxLen = Math.max(maxLen, i - sumIndex.get(sum));\n        } else {\n            sumIndex.put(sum, i);\n        }\n    }\n    \n    return maxLen;\n}",
        "python": "def findMaxLength(nums):\n    sum_index = {0: -1}\n    sum_val = 0\n    max_len = 0\n    \n    for i in range(len(nums)):\n        sum_val += -1 if nums[i] == 0 else 1\n        \n        if sum_val in sum_index:\n            max_len = max(max_len, i - sum_index[sum_val])\n        else:\n            sum_index[sum_val] = i\n    \n    return max_len",
        "javascript": "function findMaxLength(nums) {\n    const sumIndex = new Map();\n    sumIndex.set(0, -1);\n    \n    let sum = 0;\n    let maxLen = 0;\n    \n    for (let i = 0; i < nums.length; i++) {\n        sum += (nums[i] === 0) ? -1 : 1;\n        \n        if (sumIndex.has(sum)) {\n            maxLen = Math.max(maxLen, i - sumIndex.get(sum));\n        } else {\n            sumIndex.set(sum, i);\n        }\n    }\n    \n    return maxLen;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not converting 0 to -1 (counts won't balance out)",
    "Storing latest index instead of first (need first for maximum length)",
    "Forgetting to initialize map with {0: -1}",
    "Updating map even when sum exists (should only store first occurrence)",
    "Calculating wrong length (should be i - map[sum], not i - map[sum] + 1)"
  ],
  "hints": [
    "Equal 0s and 1s means (count_0s - count_1s) = 0",
    "Convert 0→-1: now equal counts means sum = 0",
    "This becomes 'longest subarray with sum 0' problem",
    "Use hashmap to track first occurrence of each cumulative sum",
    "When sum repeats, subarray between has equal 0s and 1s"
  ],
  "followUp": [
    "Find all subarrays with equal 0s and 1s (not just longest)?",
    "What if we want equal number of three distinct values?",
    "Can you solve with equal 0s, 1s, and 2s?",
    "Find shortest subarray with equal 0s and 1s?",
    "What if input is very large (streaming solution)?"
  ],
  "companies": ["Facebook", "Google", "Amazon", "Microsoft", "Bloomberg"],
  "tags": ["array", "hash-table", "prefix-sum"],
  "relatedProblems": [
    "Maximum Size Subarray Sum Equals k",
    "Largest Subarray with 0 Sum",
    "Subarray Sum Equals K",
    "K-diff Pairs in an Array",
    "Longest Well-Performing Interval"
  ]
}
