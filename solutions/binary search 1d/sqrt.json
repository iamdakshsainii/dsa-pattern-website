{
  "questionId": "69",
  "questionSlug": "sqrtx",
  "title": "Sqrt(x) using Binary Search",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/sqrtx/",
    "videos": [
      {
        "title": "Sqrt(x) - Leetcode 69",
        "url": "https://www.youtube.com/watch?v=zdMhGxRWutQ",
        "channel": "NeetCode",
        "duration": "7:15",
        "language": "English"
      },
      {
        "title": "Square Root using Binary Search",
        "url": "https://www.youtube.com/watch?v=WjpswYrS2nY",
        "channel": "take U forward",
        "duration": "10:45",
        "language": "English"
      },
      {
        "title": "Sqrt(x) Binary Search Solution",
        "url": "https://www.youtube.com/watch?v=5C4JJeKq4H8",
        "channel": "Kevin Naughton Jr.",
        "duration": "8:30",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Square Root using Binary Search",
        "url": "https://takeuforward.org/binary-search/finding-sqrt-of-a-number-using-binary-search/",
        "source": "takeuforward"
      },
      {
        "title": "Square Root of Integer - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/square-root-of-an-integer/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Sqrt(x) - LeetCode Solution",
        "url": "https://leetcode.com/problems/sqrtx/solution/",
        "source": "LeetCode Official"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/sqrtx/",
        "platform": "LeetCode"
      },
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://practice.geeksforgeeks.org/problems/square-root/",
        "platform": "GeeksforGeeks"
      }
    ]
  },
  "patternTriggers": "Find square root + integer result = Binary search on answer from 1 to x. Check if mid*mid <= x.",
  "approaches": [
    {
      "name": "Linear Search",
      "order": 1,
      "intuition": "Try all numbers from 1 to x and find largest i where i*i <= x.",
      "approach": "Iterate and check each number's square until it exceeds x.",
      "steps": [
        "If x == 0 or x == 1: return x",
        "Initialize ans = 1",
        "For i from 1 to x:",
        "  If i * i <= x:",
        "    ans = i",
        "  Else:",
        "    break",
        "Return ans"
      ],
      "complexity": {
        "time": "O(âˆšx)",
        "space": "O(1)",
        "timeExplanation": "Iterate until square root of x",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0 || x == 1) return x;\n        \n        int ans = 1;\n        for (long long i = 1; i <= x; i++) {\n            if (i * i <= x) {\n                ans = i;\n            } else {\n                break;\n            }\n        }\n        \n        return ans;\n    }\n};",
        "java": "class Solution {\n    public int mySqrt(int x) {\n        if (x == 0 || x == 1) return x;\n        \n        int ans = 1;\n        for (long i = 1; i <= x; i++) {\n            if (i * i <= x) {\n                ans = (int)i;\n            } else {\n                break;\n            }\n        }\n        \n        return ans;\n    }\n}",
        "python": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        \n        ans = 1\n        for i in range(1, x + 1):\n            if i * i <= x:\n                ans = i\n            else:\n                break\n        \n        return ans",
        "javascript": "var mySqrt = function(x) {\n    if (x === 0 || x === 1) return x;\n    \n    let ans = 1;\n    for (let i = 1; i <= x; i++) {\n        if (i * i <= x) {\n            ans = i;\n        } else {\n            break;\n        }\n    }\n    \n    return ans;\n};"
      }
    },
    {
      "name": "Binary Search with Multiplication",
      "order": 2,
      "intuition": "Search space is 1 to x. Use binary search to find largest number whose square <= x.",
      "approach": "Binary search keeping track of answer. If mid*mid <= x, it's potential answer.",
      "steps": [
        "If x == 0 or x == 1: return x",
        "Initialize low = 1, high = x, ans = 1",
        "While low <= high:",
        "  mid = (low + high) / 2",
        "  If mid * mid <= x:",
        "    ans = mid",
        "    low = mid + 1 (try larger)",
        "  Else:",
        "    high = mid - 1 (try smaller)",
        "Return ans"
      ],
      "complexity": {
        "time": "O(log x)",
        "space": "O(1)",
        "timeExplanation": "Binary search on range [1, x]",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0 || x == 1) return x;\n        \n        long long low = 1, high = x;\n        int ans = 1;\n        \n        while (low <= high) {\n            long long mid = low + (high - low) / 2;\n            long long square = mid * mid;\n            \n            if (square <= x) {\n                ans = mid;\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return ans;\n    }\n};",
        "java": "class Solution {\n    public int mySqrt(int x) {\n        if (x == 0 || x == 1) return x;\n        \n        long low = 1, high = x;\n        int ans = 1;\n        \n        while (low <= high) {\n            long mid = low + (high - low) / 2;\n            long square = mid * mid;\n            \n            if (square <= x) {\n                ans = (int)mid;\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return ans;\n    }\n}",
        "python": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        \n        low, high = 1, x\n        ans = 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            square = mid * mid\n            \n            if square <= x:\n                ans = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return ans",
        "javascript": "var mySqrt = function(x) {\n    if (x === 0 || x === 1) return x;\n    \n    let low = 1, high = x;\n    let ans = 1;\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const square = mid * mid;\n        \n        if (square <= x) {\n            ans = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    \n    return ans;\n};"
      }
    },
    {
      "name": "Binary Search with Division - Optimal",
      "order": 3,
      "intuition": "Instead of mid*mid which can overflow, use mid <= x/mid to avoid overflow issues.",
      "approach": "Binary search with division check to handle large numbers without overflow.",
      "steps": [
        "If x < 2: return x",
        "Initialize low = 1, high = x/2 (sqrt never exceeds x/2 for x >= 2)",
        "While low <= high:",
        "  mid = (low + high) / 2",
        "  If mid == x/mid: return mid (exact square root)",
        "  If mid < x/mid:",
        "    low = mid + 1",
        "  Else:",
        "    high = mid - 1",
        "Return high (floor of square root)"
      ],
      "complexity": {
        "time": "O(log x)",
        "space": "O(1)",
        "timeExplanation": "Binary search on range [1, x/2]",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x < 2) return x;\n        \n        long long low = 1, high = x / 2;\n        \n        while (low <= high) {\n            long long mid = low + (high - low) / 2;\n            \n            if (mid == x / mid) {\n                return mid;\n            } else if (mid < x / mid) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return high;\n    }\n};",
        "java": "class Solution {\n    public int mySqrt(int x) {\n        if (x < 2) return x;\n        \n        long low = 1, high = x / 2;\n        \n        while (low <= high) {\n            long mid = low + (high - low) / 2;\n            \n            if (mid == x / mid) {\n                return (int)mid;\n            } else if (mid < x / mid) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return (int)high;\n    }\n}",
        "python": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x < 2:\n            return x\n        \n        low, high = 1, x // 2\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if mid == x // mid:\n                return mid\n            elif mid < x // mid:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return high",
        "javascript": "var mySqrt = function(x) {\n    if (x < 2) return x;\n    \n    let low = 1, high = Math.floor(x / 2);\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        if (mid === Math.floor(x / mid)) {\n            return mid;\n        } else if (mid < Math.floor(x / mid)) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    \n    return high;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Integer overflow when calculating mid * mid for large values",
    "Not handling x = 0 and x = 1 edge cases",
    "Wrong search space: should be 1 to x/2 (or 1 to x)",
    "Not using long long for intermediate calculations",
    "Returning wrong value (should return high when loop ends)"
  ],
  "hints": [
    "For x >= 2, square root is always <= x/2",
    "Use long long or check for overflow when computing mid * mid",
    "Alternative: use division mid <= x/mid instead of multiplication",
    "Binary search on answer: find largest i where i*i <= x",
    "The answer is floor of square root"
  ],
  "followUp": [
    "How to find square root with decimal precision?",
    "Can you use Newton's method instead?",
    "What if you need to find cube root?",
    "How to optimize the search space further?",
    "Can you solve without using multiplication or division?"
  ],
  "companies": ["Facebook", "Amazon", "Google", "Microsoft", "Bloomberg", "Apple"],
  "tags": ["binary-search", "math"],
  "relatedProblems": [
    "Nth Root of a Number",
    "Pow(x, n)",
    "Valid Perfect Square",
    "Arranging Coins",
    "Sum of Square Numbers"
  ]
}
