{
  "questionId": "lower-bound",
  "questionSlug": "lower-bound-first-greater-equal",
  "title": "Lower Bound (First >= target)",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://www.geeksforgeeks.org/problems/floor-in-a-sorted-array-1587115620/1",
    "videos": [
      {
        "title": "Lower Bound and Upper Bound",
        "url": "https://www.youtube.com/watch?v=6zhGS79oQ4k",
        "channel": "take U forward",
        "duration": "15:30",
        "language": "English"
      },
      {
        "title": "Binary Search - Lower and Upper Bound",
        "url": "https://www.youtube.com/watch?v=5cx0xerA8XY",
        "channel": "Aditya Verma",
        "duration": "12:45",
        "language": "English"
      },
      {
        "title": "Lower Bound Binary Search",
        "url": "https://www.youtube.com/watch?v=SC7vJJwYKS8",
        "channel": "Pepcoding",
        "duration": "10:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Implement Lower Bound",
        "url": "https://takeuforward.org/arrays/implement-lower-bound-bs-2/",
        "source": "takeuforward"
      },
      {
        "title": "Lower Bound in C++ STL",
        "url": "https://www.geeksforgeeks.org/lower_bound-in-cpp/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Binary Search Variations",
        "url": "https://www.topcoder.com/thrive/articles/Binary%20Search",
        "source": "TopCoder"
      }
    ],
    "practice": [
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://practice.geeksforgeeks.org/problems/floor-in-a-sorted-array-1587115620/1",
        "platform": "GeeksforGeeks"
      }
    ]
  },
  "patternTriggers": "Find first element >= target in sorted array = Binary search variant. Track potential answer and move left when found.",
  "approaches": [
    {
      "name": "Linear Search",
      "order": 1,
      "intuition": "Scan array from left to right to find first element >= target.",
      "approach": "Iterate through array and return index of first element that is >= target.",
      "steps": [
        "Iterate i from 0 to n-1",
        "If nums[i] >= target: return i",
        "If loop completes: return n (insertion point at end)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "May need to scan entire array",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int lowerBound(vector<int>& nums, int target) {\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] >= target) {\n                return i;\n            }\n        }\n        \n        return n;\n    }\n};",
        "java": "class Solution {\n    public int lowerBound(int[] nums, int target) {\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] >= target) {\n                return i;\n            }\n        }\n        \n        return n;\n    }\n}",
        "python": "class Solution:\n    def lowerBound(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] >= target:\n                return i\n        \n        return n",
        "javascript": "var lowerBound = function(nums, target) {\n    const n = nums.length;\n    \n    for (let i = 0; i < n; i++) {\n        if (nums[i] >= target) {\n            return i;\n        }\n    }\n    \n    return n;\n};"
      }
    },
    {
      "name": "Binary Search - Optimal",
      "order": 2,
      "intuition": "Use binary search to efficiently find first element >= target. Whenever we find element >= target, it's a potential answer - store it and search left for smaller index.",
      "approach": "Binary search with modification: when nums[mid] >= target, store answer and search left half. When nums[mid] < target, search right half.",
      "steps": [
        "Initialize low = 0, high = n - 1, ans = n",
        "While low <= high:",
        "  mid = (low + high) / 2",
        "  If nums[mid] >= target:",
        "    Update ans = mid (potential answer)",
        "    Search left for smaller index: high = mid - 1",
        "  Else (nums[mid] < target):",
        "    Search right: low = mid + 1",
        "Return ans"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Binary search halves search space",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int lowerBound(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        int ans = nums.size();\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] >= target) {\n                ans = mid;\n                high = mid - 1; // Look for smaller index\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return ans;\n    }\n};",
        "java": "class Solution {\n    public int lowerBound(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        int ans = nums.length;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] >= target) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return ans;\n    }\n}",
        "python": "class Solution:\n    def lowerBound(self, nums: List[int], target: int) -> int:\n        low, high = 0, len(nums) - 1\n        ans = len(nums)\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] >= target:\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        return ans",
        "javascript": "var lowerBound = function(nums, target) {\n    let low = 0, high = nums.length - 1;\n    let ans = nums.length;\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        if (nums[mid] >= target) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return ans;\n};"
      }
    },
    {
      "name": "Binary Search (Alternative - Using low)",
      "order": 3,
      "intuition": "Another approach: after binary search completes, low pointer will be at the lower bound position.",
      "approach": "Standard binary search modification where low naturally points to insertion position (first element >= target).",
      "steps": [
        "Initialize low = 0, high = n - 1",
        "While low <= high:",
        "  mid = (low + high) / 2",
        "  If nums[mid] >= target:",
        "    high = mid - 1",
        "  Else:",
        "    low = mid + 1",
        "Return low (it will be at lower bound position)"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Binary search halves search space",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int lowerBound(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return low; // low will be at lower bound position\n    }\n};",
        "java": "class Solution {\n    public int lowerBound(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return low;\n    }\n}",
        "python": "class Solution:\n    def lowerBound(self, nums: List[int], target: int) -> int:\n        low, high = 0, len(nums) - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] >= target:\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        return low",
        "javascript": "var lowerBound = function(nums, target) {\n    let low = 0, high = nums.length - 1;\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        if (nums[mid] >= target) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return low;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Confusing lower bound (>=) with upper bound (>)",
    "Returning -1 instead of n when no element found",
    "Using wrong comparison: > instead of >=",
    "Not updating high = mid - 1 after finding potential answer",
    "Forgetting to initialize ans = n for case when all elements < target"
  ],
  "hints": [
    "Lower bound finds first element >= target",
    "If no such element exists, return n (array length)",
    "When nums[mid] >= target, search left for potentially smaller index",
    "The 'low' pointer naturally ends up at lower bound position",
    "This is same as insertion position for target in sorted array"
  ],
  "followUp": [
    "What is upper bound? (First element > target)",
    "How to find floor (largest element <= target)?",
    "How to find ceiling (smallest element >= target)?",
    "Can you use this to implement binary search?",
    "How does C++ STL lower_bound work?"
  ],
  "companies": ["Google", "Amazon", "Microsoft", "Facebook", "Apple"],
  "tags": ["binary-search", "array"],
  "relatedProblems": [
    "Search Insert Position",
    "Upper Bound",
    "Find First and Last Position of Element",
    "Floor in Sorted Array",
    "Ceiling in Sorted Array"
  ]
}
