{
  "questionId": "33",
  "questionSlug": "search-in-rotated-sorted-array",
  "title": "Search in Rotated Sorted Array",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
    "videos": [
      {
        "title": "Search in Rotated Sorted Array - Leetcode 33",
        "url": "https://www.youtube.com/watch?v=U8XENwh8Oy8",
        "channel": "NeetCode",
        "duration": "11:32",
        "language": "English"
      },
      {
        "title": "Search in Rotated Sorted Array",
        "url": "https://www.youtube.com/watch?v=5qGrJbHhqFs",
        "channel": "take U forward",
        "duration": "13:45",
        "language": "English"
      },
      {
        "title": "Search Element in Rotated Sorted Array",
        "url": "https://www.youtube.com/watch?v=r3pZd9ghqxk",
        "channel": "Aditya Verma",
        "duration": "10:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Search in Rotated Sorted Array",
        "url": "https://takeuforward.org/data-structure/search-element-in-a-rotated-sorted-array/",
        "source": "takeuforward"
      },
      {
        "title": "Search in Rotated Sorted Array - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Search in Rotated Sorted Array - LeetCode Solution",
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/solution/",
        "source": "LeetCode Official"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
        "platform": "LeetCode"
      },
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://practice.geeksforgeeks.org/problems/search-in-a-rotated-array/",
        "platform": "GeeksforGeeks"
      }
    ]
  },
  "patternTriggers": "Sorted array + rotation + search = Modified binary search. Identify which half is sorted, then decide search direction.",
  "approaches": [
    {
      "name": "Linear Search",
      "order": 1,
      "intuition": "Scan entire array to find target. Ignores sorted property and rotation.",
      "approach": "Iterate through array and check each element against target.",
      "steps": [
        "Iterate i from 0 to n-1",
        "If nums[i] == target: return i",
        "If loop completes: return -1"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "May scan entire array in worst case",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] == target:\n                return i\n        \n        return -1",
        "javascript": "var search = function(nums, target) {\n    const n = nums.length;\n    \n    for (let i = 0; i < n; i++) {\n        if (nums[i] === target) {\n            return i;\n        }\n    }\n    \n    return -1;\n};"
      }
    },
    {
      "name": "Find Pivot + Binary Search",
      "order": 2,
      "intuition": "Find rotation point (minimum element), then perform binary search on appropriate half.",
      "approach": "First find pivot index where rotation occurred, then do binary search on either left or right sorted subarray.",
      "steps": [
        "Find pivot (minimum element) using binary search",
        "If target >= nums[0] and target <= nums[pivot-1]: search left half",
        "Else: search right half",
        "Perform standard binary search on chosen half"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Two binary searches: O(log n) + O(log n) = O(log n)",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int low = 0, high = nums.size() - 1;\n        \n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] > nums[high]) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        \n        return low;\n    }\n    \n    int binarySearch(vector<int>& nums, int low, int high, int target) {\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n    \n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int pivot = findMin(nums);\n        \n        // Search in left sorted half\n        if (pivot > 0 && target >= nums[0] && target <= nums[pivot - 1]) {\n            return binarySearch(nums, 0, pivot - 1, target);\n        }\n        \n        // Search in right sorted half\n        return binarySearch(nums, pivot, n - 1, target);\n    }\n};",
        "java": "class Solution {\n    public int findMin(int[] nums) {\n        int low = 0, high = nums.length - 1;\n        \n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] > nums[high]) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        \n        return low;\n    }\n    \n    public int binarySearch(int[] nums, int low, int high, int target) {\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n    \n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int pivot = findMin(nums);\n        \n        if (pivot > 0 && target >= nums[0] && target <= nums[pivot - 1]) {\n            return binarySearch(nums, 0, pivot - 1, target);\n        }\n        \n        return binarySearch(nums, pivot, n - 1, target);\n    }\n}",
        "python": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n        \n        while low < high:\n            mid = (low + high) // 2\n            \n            if nums[mid] > nums[high]:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low\n    \n    def binarySearch(self, nums: List[int], low: int, high: int, target: int) -> int:\n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return -1\n    \n    def search(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        pivot = self.findMin(nums)\n        \n        if pivot > 0 and nums[0] <= target <= nums[pivot - 1]:\n            return self.binarySearch(nums, 0, pivot - 1, target)\n        \n        return self.binarySearch(nums, pivot, n - 1, target)",
        "javascript": "var search = function(nums, target) {\n    const findMin = (nums) => {\n        let low = 0, high = nums.length - 1;\n        \n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            \n            if (nums[mid] > nums[high]) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        \n        return low;\n    };\n    \n    const binarySearch = (nums, low, high, target) => {\n        while (low <= high) {\n            const mid = Math.floor((low + high) / 2);\n            \n            if (nums[mid] === target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    };\n    \n    const n = nums.length;\n    const pivot = findMin(nums);\n    \n    if (pivot > 0 && target >= nums[0] && target <= nums[pivot - 1]) {\n        return binarySearch(nums, 0, pivot - 1, target);\n    }\n    \n    return binarySearch(nums, pivot, n - 1, target);\n};"
      }
    },
    {
      "name": "Single Pass Binary Search - Optimal",
      "order": 3,
      "intuition": "In each binary search step, one half is always sorted. Check if target lies in sorted half, else search other half.",
      "approach": "Modified binary search that identifies sorted half and decides direction based on target position.",
      "steps": [
        "Initialize low = 0, high = n - 1",
        "While low <= high:",
        "  mid = (low + high) / 2",
        "  If nums[mid] == target: return mid",
        "  Check which half is sorted (compare nums[low] with nums[mid])",
        "  If left half sorted (nums[low] <= nums[mid]):",
        "    If target in range [nums[low], nums[mid]]: search left (high = mid - 1)",
        "    Else: search right (low = mid + 1)",
        "  Else (right half sorted):",
        "    If target in range [nums[mid], nums[high]]: search right (low = mid + 1)",
        "    Else: search left (high = mid - 1)",
        "Return -1"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Single binary search pass through array",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            }\n            \n            // Check if left half is sorted\n            if (nums[low] <= nums[mid]) {\n                // Target in left sorted half\n                if (target >= nums[low] && target < nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            // Right half is sorted\n            else {\n                // Target in right sorted half\n                if (target > nums[mid] && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            }\n            \n            // Check if left half is sorted\n            if (nums[low] <= nums[mid]) {\n                // Target in left sorted half\n                if (target >= nums[low] && target < nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            // Right half is sorted\n            else {\n                // Target in right sorted half\n                if (target > nums[mid] && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        low, high = 0, len(nums) - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            # Check if left half is sorted\n            if nums[low] <= nums[mid]:\n                # Target in left sorted half\n                if nums[low] <= target < nums[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            # Right half is sorted\n            else:\n                # Target in right sorted half\n                if nums[mid] < target <= nums[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        \n        return -1",
        "javascript": "var search = function(nums, target) {\n    let low = 0, high = nums.length - 1;\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        }\n        \n        // Check if left half is sorted\n        if (nums[low] <= nums[mid]) {\n            // Target in left sorted half\n            if (target >= nums[low] && target < nums[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        // Right half is sorted\n        else {\n            // Target in right sorted half\n            if (target > nums[mid] && target <= nums[high]) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling edge case when array is not rotated",
    "Wrong comparison for identifying sorted half",
    "Using < instead of <= when comparing with nums[low]",
    "Not handling duplicate elements properly (this problem guarantees unique elements)",
    "Incorrect range checks for target position"
  ],
  "hints": [
    "At least one half of the array is always sorted after rotation",
    "Compare nums[low] with nums[mid] to identify which half is sorted",
    "If target lies in sorted half range, eliminate other half",
    "Key insight: one of the halves will always be monotonically increasing",
    "Edge case: array not rotated (nums[0] < nums[n-1])"
  ],
  "followUp": [
    "What if array contains duplicates? (See Search in Rotated Sorted Array II)",
    "How to find the rotation count?",
    "How to find minimum element in rotated array?",
    "Can you solve without finding pivot first?",
    "What's the worst case for this algorithm?"
  ],
  "companies": ["Facebook", "Amazon", "Microsoft", "Google", "LinkedIn", "Apple", "Bloomberg", "Uber"],
  "tags": ["binary-search", "array"],
  "relatedProblems": [
    "Search in Rotated Sorted Array II",
    "Find Minimum in Rotated Sorted Array",
    "Find Minimum in Rotated Sorted Array II",
    "Binary Search",
    "Find Peak Element"
  ]
}
