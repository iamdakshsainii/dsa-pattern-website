{
  "questionId": "540",
  "questionSlug": "single-element-in-a-sorted-array",
  "title": "Single Element in Sorted Array",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/single-element-in-a-sorted-array/",
    "videos": [
      {
        "title": "Single Element in a Sorted Array - Leetcode 540",
        "url": "https://www.youtube.com/watch?v=nMGL2q6zlHM",
        "channel": "NeetCode",
        "duration": "12:45",
        "language": "English"
      },
      {
        "title": "Single Element in a Sorted Array",
        "url": "https://www.youtube.com/watch?v=PzszoiY5XMQ",
        "channel": "take U forward",
        "duration": "15:30",
        "language": "English"
      },
      {
        "title": "Find Single Element in Sorted Array",
        "url": "https://www.youtube.com/watch?v=HGFjdRBKFZg",
        "channel": "Aditya Verma",
        "duration": "10:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Single Element in a Sorted Array",
        "url": "https://takeuforward.org/arrays/single-element-in-a-sorted-array/",
        "source": "takeuforward"
      },
      {
        "title": "Single Element in a Sorted Array - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/find-the-element-that-appears-once-in-a-sorted-array/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Single Element in a Sorted Array - LeetCode Solution",
        "url": "https://leetcode.com/problems/single-element-in-a-sorted-array/solution/",
        "source": "LeetCode Official"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/single-element-in-a-sorted-array/",
        "platform": "LeetCode"
      },
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://practice.geeksforgeeks.org/problems/element-appearing-once/",
        "platform": "GeeksforGeeks"
      }
    ]
  },
  "patternTriggers": "Sorted array + find unique element + O(log n) = Binary search with parity check. Before unique element, pairs start at even index; after it, at odd index.",
  "approaches": [
    {
      "name": "XOR Approach",
      "order": 1,
      "intuition": "XOR all elements. Duplicates cancel out, leaving only single element.",
      "approach": "Use property that a XOR a = 0 and a XOR 0 = a. XOR all elements to get answer.",
      "steps": [
        "Initialize result = 0",
        "Iterate through all elements",
        "result = result XOR nums[i]",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Must scan entire array",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int result = 0;\n        \n        for (int num : nums) {\n            result ^= num;\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int result = 0;\n        \n        for (int num : nums) {\n            result ^= num;\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        result = 0\n        \n        for num in nums:\n            result ^= num\n        \n        return result",
        "javascript": "var singleNonDuplicate = function(nums) {\n    let result = 0;\n    \n    for (const num of nums) {\n        result ^= num;\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Check Neighbors",
      "order": 2,
      "intuition": "Single element won't have duplicate neighbor. Check each element's neighbors.",
      "approach": "Iterate and check if current element equals left or right neighbor. If not, it's the answer.",
      "steps": [
        "Handle edge case: if n == 1, return nums[0]",
        "Check first element: if nums[0] != nums[1], return nums[0]",
        "Check last element: if nums[n-1] != nums[n-2], return nums[n-1]",
        "For i from 1 to n-2:",
        "  If nums[i] != nums[i-1] and nums[i] != nums[i+1]:",
        "    Return nums[i]"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "May scan entire array in worst case",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int n = nums.size();\n        \n        if (n == 1) return nums[0];\n        if (nums[0] != nums[1]) return nums[0];\n        if (nums[n-1] != nums[n-2]) return nums[n-1];\n        \n        for (int i = 1; i < n - 1; i++) {\n            if (nums[i] != nums[i-1] && nums[i] != nums[i+1]) {\n                return nums[i];\n            }\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int n = nums.length;\n        \n        if (n == 1) return nums[0];\n        if (nums[0] != nums[1]) return nums[0];\n        if (nums[n-1] != nums[n-2]) return nums[n-1];\n        \n        for (int i = 1; i < n - 1; i++) {\n            if (nums[i] != nums[i-1] && nums[i] != nums[i+1]) {\n                return nums[i];\n            }\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        if n == 1:\n            return nums[0]\n        if nums[0] != nums[1]:\n            return nums[0]\n        if nums[n-1] != nums[n-2]:\n            return nums[n-1]\n        \n        for i in range(1, n - 1):\n            if nums[i] != nums[i-1] and nums[i] != nums[i+1]:\n                return nums[i]\n        \n        return -1",
        "javascript": "var singleNonDuplicate = function(nums) {\n    const n = nums.length;\n    \n    if (n === 1) return nums[0];\n    if (nums[0] !== nums[1]) return nums[0];\n    if (nums[n-1] !== nums[n-2]) return nums[n-1];\n    \n    for (let i = 1; i < n - 1; i++) {\n        if (nums[i] !== nums[i-1] && nums[i] !== nums[i+1]) {\n            return nums[i];\n        }\n    }\n    \n    return -1;\n};"
      }
    },
    {
      "name": "Binary Search with Parity - Optimal",
      "order": 3,
      "intuition": "Key insight: Before single element, 1st instance of pair is at EVEN index. After single element, 1st instance is at ODD index. Use binary search to find transition point.",
      "approach": "Binary search on reduced search space (1 to n-2). Check if mid is 1st or 2nd element of pair using parity.",
      "steps": [
        "Handle edge cases: array size 1, or single element at start/end",
        "Set low = 1, high = n - 2 (eliminate first and last elements)",
        "While low <= high:",
        "  mid = (low + high) / 2",
        "  If nums[mid] != nums[mid-1] and nums[mid] != nums[mid+1]:",
        "    Return nums[mid] (found answer)",
        "  Check position in pair:",
        "    If (mid is even and nums[mid] == nums[mid+1]) OR",
        "       (mid is odd and nums[mid] == nums[mid-1]):",
        "      We're in left half before single element",
        "      Search right: low = mid + 1",
        "    Else:",
        "      We're in right half after single element",
        "      Search left: high = mid - 1"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Binary search halves search space each iteration",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int n = nums.size();\n        \n        // Edge cases\n        if (n == 1) return nums[0];\n        if (nums[0] != nums[1]) return nums[0];\n        if (nums[n-1] != nums[n-2]) return nums[n-1];\n        \n        int low = 1, high = n - 2;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            // Check if mid is the single element\n            if (nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]) {\n                return nums[mid];\n            }\n            \n            // Check if we're in left half (before single element)\n            // In left half: pairs start at even indices\n            if ((mid % 2 == 0 && nums[mid] == nums[mid+1]) ||\n                (mid % 2 == 1 && nums[mid] == nums[mid-1])) {\n                // Single element is to the right\n                low = mid + 1;\n            } else {\n                // Single element is to the left\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int n = nums.length;\n        \n        // Edge cases\n        if (n == 1) return nums[0];\n        if (nums[0] != nums[1]) return nums[0];\n        if (nums[n-1] != nums[n-2]) return nums[n-1];\n        \n        int low = 1, high = n - 2;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            // Check if mid is the single element\n            if (nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]) {\n                return nums[mid];\n            }\n            \n            // Check if we're in left half (before single element)\n            // In left half: pairs start at even indices\n            if ((mid % 2 == 0 && nums[mid] == nums[mid+1]) ||\n                (mid % 2 == 1 && nums[mid] == nums[mid-1])) {\n                // Single element is to the right\n                low = mid + 1;\n            } else {\n                // Single element is to the left\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        # Edge cases\n        if n == 1:\n            return nums[0]\n        if nums[0] != nums[1]:\n            return nums[0]\n        if nums[n-1] != nums[n-2]:\n            return nums[n-1]\n        \n        low, high = 1, n - 2\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            # Check if mid is the single element\n            if nums[mid] != nums[mid-1] and nums[mid] != nums[mid+1]:\n                return nums[mid]\n            \n            # Check if we're in left half (before single element)\n            # In left half: pairs start at even indices\n            if (mid % 2 == 0 and nums[mid] == nums[mid+1]) or \\\n               (mid % 2 == 1 and nums[mid] == nums[mid-1]):\n                # Single element is to the right\n                low = mid + 1\n            else:\n                # Single element is to the left\n                high = mid - 1\n        \n        return -1",
        "javascript": "var singleNonDuplicate = function(nums) {\n    const n = nums.length;\n    \n    // Edge cases\n    if (n === 1) return nums[0];\n    if (nums[0] !== nums[1]) return nums[0];\n    if (nums[n-1] !== nums[n-2]) return nums[n-1];\n    \n    let low = 1, high = n - 2;\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        // Check if mid is the single element\n        if (nums[mid] !== nums[mid-1] && nums[mid] !== nums[mid+1]) {\n            return nums[mid];\n        }\n        \n        // Check if we're in left half (before single element)\n        // In left half: pairs start at even indices\n        if ((mid % 2 === 0 && nums[mid] === nums[mid+1]) ||\n            (mid % 2 === 1 && nums[mid] === nums[mid-1])) {\n            // Single element is to the right\n            low = mid + 1;\n        } else {\n            // Single element is to the left\n            high = mid - 1;\n        }\n    }\n    \n    return -1;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling edge cases (single element at start/end)",
    "Wrong parity check logic",
    "Not reducing search space to [1, n-2]",
    "Comparing mid with wrong neighbor",
    "Not understanding the pattern: before single element, pairs start at even index"
  ],
  "hints": [
    "Observe pattern: before single element, 1st element of pair is at even index",
    "After single element, 1st element of pair is at odd index",
    "Use binary search with parity check",
    "Eliminate first and last elements in edge case checks",
    "Single element breaks the even-odd pattern of pairs"
  ],
  "followUp": [
    "What if array was not sorted?",
    "Can you solve without checking neighbors explicitly?",
    "What if there were multiple single elements?",
    "How does XOR approach differ from binary search?",
    "Can you generalize to triplets instead of pairs?"
  ],
  "companies": ["Google", "Amazon", "Microsoft", "Facebook", "Adobe"],
  "tags": ["binary-search", "array", "bit-manipulation"],
  "relatedProblems": [
    "Single Number",
    "Single Number II",
    "Single Number III",
    "Find the Duplicate Number",
    "Missing Number"
  ]
}
