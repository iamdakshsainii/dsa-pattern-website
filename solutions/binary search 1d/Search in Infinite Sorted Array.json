{
  "questionId": "GFG-ISA",
  "questionSlug": "search-in-an-infinite-sorted-array",
  "title": "Search in Infinite Sorted Array",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/discuss/interview-question/341818/",
    "videos": [
      {
        "title": "Search in Infinite Sorted Array",
        "url": "https://www.youtube.com/watch?v=FzvK5uuaki8",
        "channel": "Aditya Verma",
        "duration": "14:30",
        "language": "English"
      },
      {
        "title": "Find Position in Infinite Array",
        "url": "https://www.youtube.com/watch?v=W9QJ8HaRvJQ",
        "channel": "take U forward",
        "duration": "11:45",
        "language": "English"
      },
      {
        "title": "Binary Search on Infinite Array",
        "url": "https://www.youtube.com/watch?v=5cx0xerA8XY",
        "channel": "Pepcoding",
        "duration": "13:20",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Search in Infinite Sorted Array",
        "url": "https://www.geeksforgeeks.org/find-position-element-sorted-array-infinite-numbers/",
        "source": "GeeksforGeeks"
      },
      {
        "title": "Find Element in Infinite Array",
        "url": "https://takeuforward.org/arrays/search-in-infinite-sorted-array/",
        "source": "takeuforward"
      },
      {
        "title": "Search Infinite Array - Interview Problem",
        "url": "https://www.codingninjas.com/studio/problems/search-in-infinite-sorted-array_1170287",
        "source": "Coding Ninjas"
      }
    ],
    "practice": [
      {
        "title": "Practice on GeeksforGeeks",
        "url": "https://practice.geeksforgeeks.org/problems/find-position-in-infinite-array/",
        "platform": "GeeksforGeeks"
      },
      {
        "title": "Practice on Coding Ninjas",
        "url": "https://www.codingninjas.com/studio/problems/search-in-infinite-sorted-array_1170287",
        "platform": "Coding Ninjas"
      }
    ]
  },
  "patternTriggers": "Infinite array + can't use length = Find range first by doubling index, then binary search. Start with range [0,1], double until arr[high] >= target.",
  "approaches": [
    {
      "name": "Linear Search",
      "order": 1,
      "intuition": "Start from index 0 and check each element until target found. Not practical for infinite array.",
      "approach": "Iterate from start checking each element, but this defeats purpose of infinite array problem.",
      "steps": [
        "Start from index i = 0",
        "While true:",
        "  If arr[i] == target: return i",
        "  If arr[i] > target: return -1 (target doesn't exist)",
        "  i++"
      ],
      "complexity": {
        "time": "O(n) where n is position of target",
        "space": "O(1)",
        "timeExplanation": "May need to scan up to target position",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& arr, int target) {\n        int i = 0;\n        \n        while (true) {\n            if (arr[i] == target) {\n                return i;\n            }\n            if (arr[i] > target) {\n                return -1;\n            }\n            i++;\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int search(int[] arr, int target) {\n        int i = 0;\n        \n        while (true) {\n            if (arr[i] == target) {\n                return i;\n            }\n            if (arr[i] > target) {\n                return -1;\n            }\n            i++;\n        }\n    }\n}",
        "python": "class Solution:\n    def search(self, arr: List[int], target: int) -> int:\n        i = 0\n        \n        while True:\n            if arr[i] == target:\n                return i\n            if arr[i] > target:\n                return -1\n            i += 1\n        \n        return -1",
        "javascript": "var search = function(arr, target) {\n    let i = 0;\n    \n    while (true) {\n        if (arr[i] === target) {\n            return i;\n        }\n        if (arr[i] > target) {\n            return -1;\n        }\n        i++;\n    }\n};"
      }
    },
    {
      "name": "Find Range then Binary Search",
      "order": 2,
      "intuition": "Can't use array length, so find bounds first. Start with small range and keep doubling until we find range containing target.",
      "approach": "Exponentially increase range size by doubling high pointer until arr[high] >= target, then do binary search.",
      "steps": [
        "Start with low = 0, high = 1",
        "While arr[high] < target:",
        "  low = high",
        "  high = high * 2 (double the range)",
        "Now we have a range [low, high] containing target",
        "Perform standard binary search in [low, high]",
        "Return result"
      ],
      "complexity": {
        "time": "O(log n) where n is position of target",
        "space": "O(1)",
        "timeExplanation": "Finding range: O(log n), Binary search: O(log n), Total: O(log n)",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int binarySearch(vector<int>& arr, int low, int high, int target) {\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n    \n    int search(vector<int>& arr, int target) {\n        int low = 0, high = 1;\n        \n        // Find range where target might exist\n        while (arr[high] < target) {\n            low = high;\n            high = high * 2;\n        }\n        \n        // Binary search in found range\n        return binarySearch(arr, low, high, target);\n    }\n};",
        "java": "class Solution {\n    public int binarySearch(int[] arr, int low, int high, int target) {\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n    \n    public int search(int[] arr, int target) {\n        int low = 0, high = 1;\n        \n        // Find range where target might exist\n        while (arr[high] < target) {\n            low = high;\n            high = high * 2;\n        }\n        \n        // Binary search in found range\n        return binarySearch(arr, low, high, target);\n    }\n}",
        "python": "class Solution:\n    def binarySearch(self, arr: List[int], low: int, high: int, target: int) -> int:\n        while low <= high:\n            mid = (low + high) // 2\n            \n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return -1\n    \n    def search(self, arr: List[int], target: int) -> int:\n        low, high = 0, 1\n        \n        # Find range where target might exist\n        while arr[high] < target:\n            low = high\n            high = high * 2\n        \n        # Binary search in found range\n        return self.binarySearch(arr, low, high, target)",
        "javascript": "var search = function(arr, target) {\n    const binarySearch = (arr, low, high, target) => {\n        while (low <= high) {\n            const mid = Math.floor((low + high) / 2);\n            \n            if (arr[mid] === target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    };\n    \n    let low = 0, high = 1;\n    \n    // Find range where target might exist\n    while (arr[high] < target) {\n        low = high;\n        high = high * 2;\n    }\n    \n    // Binary search in found range\n    return binarySearch(arr, low, high, target);\n};"
      }
    },
    {
      "name": "Exponential Search - Optimal",
      "order": 3,
      "intuition": "Combine range finding and binary search efficiently. This is called Exponential Search - ideal for unbounded/infinite arrays.",
      "approach": "Same as approach 2 but optimized with early exit and better range handling.",
      "steps": [
        "If arr[0] == target: return 0 (early exit)",
        "Find range by doubling: low = 0, high = 1",
        "While arr[high] < target:",
        "  low = high",
        "  high = high * 2",
        "  Optional: add bound checks for safety",
        "Binary search in [low, min(high, actualSize-1)]",
        "Return result"
      ],
      "complexity": {
        "time": "O(log n) where n is position of target",
        "space": "O(1)",
        "timeExplanation": "Finding range takes log(position) steps, binary search takes log(range) = O(log n)",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& arr, int target) {\n        // Check first element\n        if (arr[0] == target) {\n            return 0;\n        }\n        \n        // Find range\n        int low = 0, high = 1;\n        \n        while (arr[high] < target) {\n            low = high;\n            high = high * 2;\n        }\n        \n        // Binary search in [low, high]\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int search(int[] arr, int target) {\n        // Check first element\n        if (arr[0] == target) {\n            return 0;\n        }\n        \n        // Find range\n        int low = 0, high = 1;\n        \n        while (arr[high] < target) {\n            low = high;\n            high = high * 2;\n        }\n        \n        // Binary search in [low, high]\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def search(self, arr: List[int], target: int) -> int:\n        # Check first element\n        if arr[0] == target:\n            return 0\n        \n        # Find range\n        low, high = 0, 1\n        \n        while arr[high] < target:\n            low = high\n            high = high * 2\n        \n        # Binary search in [low, high]\n        while low <= high:\n            mid = (low + high) // 2\n            \n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return -1",
        "javascript": "var search = function(arr, target) {\n    // Check first element\n    if (arr[0] === target) {\n        return 0;\n    }\n    \n    // Find range\n    let low = 0, high = 1;\n    \n    while (arr[high] < target) {\n        low = high;\n        high = high * 2;\n    }\n    \n    // Binary search in [low, high]\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        if (arr[mid] === target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    \n    return -1;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Trying to find array length (defeats purpose of infinite array)",
    "Not doubling the range exponentially",
    "Starting with high = 0 instead of high = 1",
    "Not handling edge case when target is at index 0",
    "Forgetting that array access might throw error if index too large"
  ],
  "hints": [
    "Can't use array.length - need to find bounds dynamically",
    "Exponentially increase search range by doubling",
    "Start with range [0, 1], keep doubling high until arr[high] >= target",
    "This technique is called Exponential Search",
    "Time complexity is O(log n) where n is position of target"
  ],
  "followUp": [
    "What if array had duplicates?",
    "How to find first occurrence in infinite array?",
    "Can you optimize if you know approximate position of target?",
    "What if array was rotated?",
    "How does this compare to regular binary search?"
  ],
  "companies": ["Google", "Amazon", "Microsoft", "Facebook"],
  "tags": ["binary-search", "array"],
  "relatedProblems": [
    "Binary Search",
    "Search Insert Position",
    "Find First and Last Position",
    "Search in Rotated Sorted Array",
    "Find Peak Element"
  ]
}
