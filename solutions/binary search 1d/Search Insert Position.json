{
  "questionId": "35",
  "questionSlug": "search-insert-position",
  "title": "Search Insert Position",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/search-insert-position/",
    "videos": [
      {
        "title": "Search Insert Position - Leetcode 35",
        "url": "https://www.youtube.com/watch?v=K-RYzDZkzCI",
        "channel": "NeetCode",
        "duration": "5:40",
        "language": "English"
      },
      {
        "title": "Search Insert Position",
        "url": "https://www.youtube.com/watch?v=6zhGS79oQ4k",
        "channel": "take U forward",
        "duration": "8:15",
        "language": "English"
      },
      {
        "title": "Search Insert Position Explained",
        "url": "https://www.youtube.com/watch?v=K3xu94wKSZA",
        "channel": "Kevin Naughton Jr.",
        "duration": "6:30",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Search Insert Position - LeetCode Solution",
        "url": "https://leetcode.com/problems/search-insert-position/solution/",
        "source": "LeetCode Official"
      },
      {
        "title": "Search Insert Position",
        "url": "https://takeuforward.org/arrays/search-insert-position/",
        "source": "takeuforward"
      },
      {
        "title": "Search Insert Position - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/search-insert-position-of-k-in-a-sorted-array/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/search-insert-position/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Find target or insertion position in sorted array = Binary search. This is essentially finding lower bound.",
  "approaches": [
    {
      "name": "Linear Search",
      "order": 1,
      "intuition": "Scan array to find target or first position where target can be inserted.",
      "approach": "Iterate through array, return index when element >= target found, else return n.",
      "steps": [
        "Iterate i from 0 to n-1",
        "If nums[i] >= target: return i",
        "If loop completes: return n (insert at end)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "May scan entire array",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] >= target) {\n                return i;\n            }\n        }\n        \n        return n;\n    }\n};",
        "java": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] >= target) {\n                return i;\n            }\n        }\n        \n        return n;\n    }\n}",
        "python": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] >= target:\n                return i\n        \n        return n",
        "javascript": "var searchInsert = function(nums, target) {\n    const n = nums.length;\n    \n    for (let i = 0; i < n; i++) {\n        if (nums[i] >= target) {\n            return i;\n        }\n    }\n    \n    return n;\n};"
      }
    },
    {
      "name": "Binary Search (Track Answer) - Optimal",
      "order": 2,
      "intuition": "Use binary search to find target or insertion position. This is same as finding lower bound (first element >= target).",
      "approach": "Binary search with answer tracking. When nums[mid] >= target, update answer and search left for smaller index.",
      "steps": [
        "Initialize low = 0, high = n - 1, ans = n",
        "While low <= high:",
        "  mid = (low + high) / 2",
        "  If nums[mid] >= target:",
        "    ans = mid",
        "    high = mid - 1 (search left)",
        "  Else:",
        "    low = mid + 1",
        "Return ans"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Binary search halves search space",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        int ans = nums.size();\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] >= target) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return ans;\n    }\n};",
        "java": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        int ans = nums.length;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] >= target) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return ans;\n    }\n}",
        "python": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        low, high = 0, len(nums) - 1\n        ans = len(nums)\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] >= target:\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        return ans",
        "javascript": "var searchInsert = function(nums, target) {\n    let low = 0, high = nums.length - 1;\n    let ans = nums.length;\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        if (nums[mid] >= target) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return ans;\n};"
      }
    },
    {
      "name": "Binary Search (Using low pointer)",
      "order": 3,
      "intuition": "After binary search, low pointer naturally points to insertion position. Cleaner implementation without ans variable.",
      "approach": "Standard binary search where low pointer ends up at correct insertion position.",
      "steps": [
        "Initialize low = 0, high = n - 1",
        "While low <= high:",
        "  mid = (low + high) / 2",
        "  If nums[mid] >= target:",
        "    high = mid - 1",
        "  Else:",
        "    low = mid + 1",
        "Return low"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Binary search halves search space",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return low;\n    }\n};",
        "java": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return low;\n    }\n}",
        "python": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        low, high = 0, len(nums) - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] >= target:\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        return low",
        "javascript": "var searchInsert = function(nums, target) {\n    let low = 0, high = nums.length - 1;\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        if (nums[mid] >= target) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return low;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Not handling case when target should be inserted at end",
    "Wrong comparison: using > instead of >=",
    "Not understanding this is same as lower bound problem",
    "Incorrect boundary updates in binary search",
    "Returning wrong value when target not found"
  ],
  "hints": [
    "This is essentially the lower bound problem",
    "Find first position where element >= target",
    "If target exists, return its index",
    "If target doesn't exist, return insertion position",
    "The low pointer naturally points to insertion position after binary search"
  ],
  "followUp": [
    "What if array has duplicates?",
    "How to find last position of target?",
    "Can you solve in O(log n) without extra space?",
    "What if you need to insert and maintain sorted order?",
    "How is this related to lower bound?"
  ],
  "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple", "Bloomberg"],
  "tags": ["binary-search", "array"],
  "relatedProblems": [
    "Binary Search",
    "Lower Bound",
    "Find First and Last Position of Element",
    "First Bad Version",
    "Guess Number Higher or Lower"
  ]
}
