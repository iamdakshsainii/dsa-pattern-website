{
  "questionId": "704",
  "questionSlug": "binary-search",
  "title": "Binary Search",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/binary-search/",
    "videos": [
      {
        "title": "Binary Search Algorithm",
        "url": "https://www.youtube.com/watch?v=MHf6awe89xw",
        "channel": "take U forward",
        "duration": "12:40",
        "language": "English"
      },
      {
        "title": "Binary Search - Leetcode 704",
        "url": "https://www.youtube.com/watch?v=s4DPM8ct1pI",
        "channel": "NeetCode",
        "duration": "7:15",
        "language": "English"
      },
      {
        "title": "Binary Search Explained",
        "url": "https://www.youtube.com/watch?v=P3YID7liBug",
        "channel": "Kevin Naughton Jr.",
        "duration": "6:30",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Binary Search - LeetCode Solution",
        "url": "https://leetcode.com/problems/binary-search/solution/",
        "source": "LeetCode Official"
      },
      {
        "title": "Binary Search Algorithm",
        "url": "https://takeuforward.org/data-structure/binary-search-explained/",
        "source": "takeuforward"
      },
      {
        "title": "Binary Search - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/binary-search/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/binary-search/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Sorted array + Find target = Classic binary search. Divide search space in half each iteration.",
  "approaches": [
    {
      "name": "Linear Search",
      "order": 1,
      "intuition": "Check each element sequentially until target is found or array ends.",
      "approach": "Iterate through array and compare each element with target.",
      "steps": [
        "Iterate i from 0 to n-1",
        "If nums[i] == target: return i",
        "If loop completes without finding: return -1"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "May need to check all elements",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int search(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
        "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        for i in range(len(nums)):\n            if nums[i] == target:\n                return i\n        return -1",
        "javascript": "var search = function(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === target) {\n            return i;\n        }\n    }\n    return -1;\n};"
      }
    },
    {
      "name": "Binary Search (Iterative) - Optimal",
      "order": 2,
      "intuition": "Since array is sorted, divide search space in half each time. Compare target with mid element to decide which half to search.",
      "approach": "Maintain low and high pointers. Calculate mid, compare with target, and adjust search boundaries accordingly.",
      "steps": [
        "Initialize low = 0, high = n - 1",
        "While low <= high:",
        "  Calculate mid = low + (high - low) / 2",
        "  If nums[mid] == target: return mid",
        "  If nums[mid] < target: search right half (low = mid + 1)",
        "  Else: search left half (high = mid - 1)",
        "Return -1 if not found"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(1)",
        "timeExplanation": "Search space halves each iteration",
        "spaceExplanation": "Only constant extra space"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n};",
        "java": "class Solution {\n    public int search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n}",
        "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        low, high = 0, len(nums) - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return -1",
        "javascript": "var search = function(nums, target) {\n    let low = 0, high = nums.length - 1;\n    \n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    \n    return -1;\n};"
      }
    },
    {
      "name": "Binary Search (Recursive)",
      "order": 3,
      "intuition": "Same binary search logic but implemented recursively. Divide and conquer approach.",
      "approach": "Recursive function that searches in appropriate half based on mid comparison.",
      "steps": [
        "Base case: if low > high, return -1",
        "Calculate mid = low + (high - low) / 2",
        "If nums[mid] == target: return mid",
        "If nums[mid] < target: recursively search right half",
        "Else: recursively search left half"
      ],
      "complexity": {
        "time": "O(log n)",
        "space": "O(log n)",
        "timeExplanation": "Search space halves each call",
        "spaceExplanation": "Recursion stack depth is O(log n)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int binarySearch(vector<int>& nums, int low, int high, int target) {\n        if (low > high) {\n            return -1;\n        }\n        \n        int mid = low + (high - low) / 2;\n        \n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            return binarySearch(nums, mid + 1, high, target);\n        } else {\n            return binarySearch(nums, low, mid - 1, target);\n        }\n    }\n    \n    int search(vector<int>& nums, int target) {\n        return binarySearch(nums, 0, nums.size() - 1, target);\n    }\n};",
        "java": "class Solution {\n    public int binarySearch(int[] nums, int low, int high, int target) {\n        if (low > high) {\n            return -1;\n        }\n        \n        int mid = low + (high - low) / 2;\n        \n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            return binarySearch(nums, mid + 1, high, target);\n        } else {\n            return binarySearch(nums, low, mid - 1, target);\n        }\n    }\n    \n    public int search(int[] nums, int target) {\n        return binarySearch(nums, 0, nums.length - 1, target);\n    }\n}",
        "python": "class Solution:\n    def binarySearch(self, nums: List[int], low: int, high: int, target: int) -> int:\n        if low > high:\n            return -1\n        \n        mid = (low + high) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return self.binarySearch(nums, mid + 1, high, target)\n        else:\n            return self.binarySearch(nums, low, mid - 1, target)\n    \n    def search(self, nums: List[int], target: int) -> int:\n        return self.binarySearch(nums, 0, len(nums) - 1, target)",
        "javascript": "var search = function(nums, target) {\n    const binarySearch = (low, high) => {\n        if (low > high) {\n            return -1;\n        }\n        \n        const mid = Math.floor((low + high) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            return binarySearch(mid + 1, high);\n        } else {\n            return binarySearch(low, mid - 1);\n        }\n    };\n    \n    return binarySearch(0, nums.length - 1);\n};"
      }
    }
  ],
  "commonMistakes": [
    "Using (low + high) / 2 instead of low + (high - low) / 2 (can cause overflow)",
    "Using low < high instead of low <= high (misses single element case)",
    "Updating boundaries incorrectly (using mid instead of midÂ±1)",
    "Infinite loop due to wrong boundary updates",
    "Not handling empty array case"
  ],
  "hints": [
    "Array is sorted - key insight for binary search",
    "Each comparison eliminates half the search space",
    "Use low + (high - low) / 2 to avoid integer overflow",
    "Loop condition should be low <= high, not low < high",
    "When not found, low will be insertion point"
  ],
  "followUp": [
    "What if array has duplicates?",
    "How to find first/last occurrence of target?",
    "What if array is rotated?",
    "Can you implement using different boundary conditions?",
    "How to search in 2D matrix using binary search?"
  ],
  "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple", "Bloomberg"],
  "tags": ["binary-search", "array"],
  "relatedProblems": [
    "Search Insert Position",
    "Find First and Last Position of Element",
    "Search in Rotated Sorted Array",
    "Find Minimum in Rotated Sorted Array",
    "Peak Index in Mountain Array"
  ]
}
