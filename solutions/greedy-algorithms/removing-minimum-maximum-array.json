{
  "questionId": "694d4a3a98494915f3bc8f0d",
  "questionSlug": "removing-minimum-maximum-array",
  "title": "Removing Minimum Maximum Array",
  "difficulty": "Easy",
  "resources": {
    "leetcode": "https://leetcode.com/problems/removing-minimum-and-maximum-from-array/",
    "videos": [
      {
        "title": "Removing Minimum and Maximum From Array - Leetcode 2091",
        "url": "https://www.youtube.com/watch?v=9KHF6OVZZ5I",
        "channel": "NeetCode",
        "duration": "8:45",
        "language": "English"
      },
      {
        "title": "Remove Min and Max Elements | Greedy Strategy Explained",
        "url": "https://www.youtube.com/watch?v=X7Y3qKmZ8Zw",
        "channel": "TECH DOSE",
        "duration": "12:20",
        "language": "English"
      },
      {
        "title": "Minimum Deletions to Remove Min Max - Easy Solution",
        "url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
        "channel": "Kevin Naughton Jr.",
        "duration": "7:15",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Removing Minimum and Maximum From Array Solution",
        "url": "https://leetcode.com/problems/removing-minimum-and-maximum-from-array/solution/",
        "source": "LeetCode Editorial"
      },
      {
        "title": "Remove Min Max Array Explained with Diagrams",
        "url": "https://algo.monster/liteproblems/2091",
        "source": "AlgoMonster"
      },
      {
        "title": "Greedy Approach to Remove Min Max Elements",
        "url": "https://www.geeksforgeeks.org/minimum-deletions-to-remove-min-max-from-array/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Minimum Operations to Make Array Equal",
        "url": "https://leetcode.com/problems/minimum-operations-to-make-array-equal/",
        "platform": "LeetCode"
      },
      {
        "title": "Minimum Deletions to Make Array Beautiful",
        "url": "https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/",
        "platform": "LeetCode"
      },
      {
        "title": "Remove Element",
        "url": "https://leetcode.com/problems/remove-element/",
        "platform": "LeetCode"
      },
      {
        "title": "Maximum Sum Circular Subarray",
        "url": "https://leetcode.com/problems/maximum-sum-circular-subarray/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Greedy pattern when you need to find minimum operations to remove specific elements from array ends. Key indicators: can only remove from ends (left/right), need to remove specific target elements, multiple removal strategies possible, optimization problem (minimize deletions), need to compare different approaches.",
  "approaches": [
    {
      "name": "Simulation - Try All Strategies",
      "order": 1,
      "intuition": "Since we can only remove from ends, there are limited strategies. Find positions of min and max, then calculate cost for each removal strategy: both from left, both from right, or split between ends.",
      "approach": "Find indices of minimum and maximum elements. Calculate the number of deletions needed for three strategies: (1) remove both from left side, (2) remove both from right side, (3) remove one from left and one from right. Return the minimum.",
      "steps": [
        "Handle edge case: if array has ≤ 2 elements, return array length",
        "Find the index of minimum element in array",
        "Find the index of maximum element in array",
        "Strategy 1 - Remove both from left: max(minIdx, maxIdx) + 1",
        "Strategy 2 - Remove both from right: n - min(minIdx, maxIdx)",
        "Strategy 3 - Remove from both ends: (min(minIdx, maxIdx) + 1) + (n - max(minIdx, maxIdx))",
        "Return the minimum of all three strategies"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through array to find min and max elements, O(1) to calculate three strategies",
        "spaceExplanation": "Only storing indices and intermediate calculations"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int minimumDeletions(vector<int>& nums) {\n        int n = nums.size();\n        \n        // Edge case: small arrays\n        if (n <= 2) return n;\n        \n        // Find indices of min and max elements\n        int minIdx = 0, maxIdx = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] < nums[minIdx]) minIdx = i;\n            if (nums[i] > nums[maxIdx]) maxIdx = i;\n        }\n        \n        // Strategy 1: Delete from left (remove up to farther element)\n        int deleteFromLeft = max(minIdx, maxIdx) + 1;\n        \n        // Strategy 2: Delete from right (remove from closer element to end)\n        int deleteFromRight = n - min(minIdx, maxIdx);\n        \n        // Strategy 3: Delete from both ends\n        int deleteFromBoth = min(minIdx, maxIdx) + 1 + (n - max(minIdx, maxIdx));\n        \n        return min({deleteFromLeft, deleteFromRight, deleteFromBoth});\n    }\n};",
        "java": "class Solution {\n    public int minimumDeletions(int[] nums) {\n        int n = nums.length;\n        \n        // Edge case: small arrays\n        if (n <= 2) return n;\n        \n        // Find indices of min and max elements\n        int minIdx = 0, maxIdx = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] < nums[minIdx]) minIdx = i;\n            if (nums[i] > nums[maxIdx]) maxIdx = i;\n        }\n        \n        // Strategy 1: Delete from left\n        int deleteFromLeft = Math.max(minIdx, maxIdx) + 1;\n        \n        // Strategy 2: Delete from right\n        int deleteFromRight = n - Math.min(minIdx, maxIdx);\n        \n        // Strategy 3: Delete from both ends\n        int deleteFromBoth = Math.min(minIdx, maxIdx) + 1 + (n - Math.max(minIdx, maxIdx));\n        \n        return Math.min(deleteFromLeft, Math.min(deleteFromRight, deleteFromBoth));\n    }\n}",
        "python": "def minimumDeletions(nums):\n    n = len(nums)\n    \n    # Edge case: small arrays\n    if n <= 2:\n        return n\n    \n    # Find indices of min and max elements\n    min_idx = nums.index(min(nums))\n    max_idx = nums.index(max(nums))\n    \n    # Strategy 1: Delete from left\n    delete_from_left = max(min_idx, max_idx) + 1\n    \n    # Strategy 2: Delete from right\n    delete_from_right = n - min(min_idx, max_idx)\n    \n    # Strategy 3: Delete from both ends\n    delete_from_both = min(min_idx, max_idx) + 1 + (n - max(min_idx, max_idx))\n    \n    return min(delete_from_left, delete_from_right, delete_from_both)",
        "javascript": "function minimumDeletions(nums) {\n    const n = nums.length;\n    \n    // Edge case: small arrays\n    if (n <= 2) return n;\n    \n    // Find indices of min and max elements\n    let minIdx = 0, maxIdx = 0;\n    for (let i = 0; i < n; i++) {\n        if (nums[i] < nums[minIdx]) minIdx = i;\n        if (nums[i] > nums[maxIdx]) maxIdx = i;\n    }\n    \n    // Strategy 1: Delete from left\n    const deleteFromLeft = Math.max(minIdx, maxIdx) + 1;\n    \n    // Strategy 2: Delete from right\n    const deleteFromRight = n - Math.min(minIdx, maxIdx);\n    \n    // Strategy 3: Delete from both ends\n    const deleteFromBoth = Math.min(minIdx, maxIdx) + 1 + (n - Math.max(minIdx, maxIdx));\n    \n    return Math.min(deleteFromLeft, deleteFromRight, deleteFromBoth);\n}"
      }
    },
    {
      "name": "Greedy with Distance Calculation (Optimal)",
      "order": 2,
      "intuition": "Calculate the distance from each end for both min and max elements. The optimal strategy minimizes total deletions by choosing the best combination: remove both from one end, or remove each from its nearest end.",
      "approach": "For both min and max elements, calculate their distance from left (index + 1) and from right (n - index). Then compare three strategies: both from left (take farther), both from right (take farther), one from each end (sum of nearest distances).",
      "steps": [
        "Handle edge case: if array length ≤ 2, return length",
        "Find indices of minimum and maximum elements",
        "Calculate distance from left for min: minFromLeft = minIdx + 1",
        "Calculate distance from right for min: minFromRight = n - minIdx",
        "Calculate distance from left for max: maxFromLeft = maxIdx + 1",
        "Calculate distance from right for max: maxFromRight = n - maxIdx",
        "Strategy 1: Both from left = max(minFromLeft, maxFromLeft)",
        "Strategy 2: Both from right = max(minFromRight, maxFromRight)",
        "Strategy 3: Each from nearest = min(minFromLeft, minFromRight) + min(maxFromLeft, maxFromRight)",
        "Return minimum of all three strategies"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass to find min and max elements and their indices, O(1) for calculations",
        "spaceExplanation": "Only constant extra space for indices, distances, and strategy calculations"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int minimumDeletions(vector<int>& nums) {\n        int n = nums.size();\n        \n        // Edge case\n        if (n <= 2) return n;\n        \n        // Find indices of min and max\n        int minIdx = 0, maxIdx = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] < nums[minIdx]) minIdx = i;\n            if (nums[i] > nums[maxIdx]) maxIdx = i;\n        }\n        \n        // Calculate distances from both ends for each element\n        int minFromLeft = minIdx + 1;\n        int minFromRight = n - minIdx;\n        int maxFromLeft = maxIdx + 1;\n        int maxFromRight = n - maxIdx;\n        \n        // Three strategies:\n        // 1. Remove both from left (must remove up to farther element)\n        int strategy1 = max(minFromLeft, maxFromLeft);\n        \n        // 2. Remove both from right (must remove from closer element)\n        int strategy2 = max(minFromRight, maxFromRight);\n        \n        // 3. Remove each from its nearest end\n        int strategy3 = min(minFromLeft, minFromRight) + min(maxFromLeft, maxFromRight);\n        \n        return min({strategy1, strategy2, strategy3});\n    }\n};",
        "java": "class Solution {\n    public int minimumDeletions(int[] nums) {\n        int n = nums.length;\n        \n        // Edge case\n        if (n <= 2) return n;\n        \n        // Find indices of min and max\n        int minIdx = 0, maxIdx = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] < nums[minIdx]) minIdx = i;\n            if (nums[i] > nums[maxIdx]) maxIdx = i;\n        }\n        \n        // Calculate distances from both ends\n        int minFromLeft = minIdx + 1;\n        int minFromRight = n - minIdx;\n        int maxFromLeft = maxIdx + 1;\n        int maxFromRight = n - maxIdx;\n        \n        // Three strategies\n        int strategy1 = Math.max(minFromLeft, maxFromLeft);\n        int strategy2 = Math.max(minFromRight, maxFromRight);\n        int strategy3 = Math.min(minFromLeft, minFromRight) + Math.min(maxFromLeft, maxFromRight);\n        \n        return Math.min(strategy1, Math.min(strategy2, strategy3));\n    }\n}",
        "python": "def minimumDeletions(nums):\n    n = len(nums)\n    \n    # Edge case\n    if n <= 2:\n        return n\n    \n    # Find indices of min and max\n    min_idx = nums.index(min(nums))\n    max_idx = nums.index(max(nums))\n    \n    # Calculate distances from both ends\n    min_from_left = min_idx + 1\n    min_from_right = n - min_idx\n    max_from_left = max_idx + 1\n    max_from_right = n - max_idx\n    \n    # Three strategies\n    strategy1 = max(min_from_left, max_from_left)\n    strategy2 = max(min_from_right, max_from_right)\n    strategy3 = min(min_from_left, min_from_right) + min(max_from_left, max_from_right)\n    \n    return min(strategy1, strategy2, strategy3)",
        "javascript": "function minimumDeletions(nums) {\n    const n = nums.length;\n    \n    // Edge case\n    if (n <= 2) return n;\n    \n    // Find indices of min and max\n    let minIdx = 0, maxIdx = 0;\n    for (let i = 0; i < n; i++) {\n        if (nums[i] < nums[minIdx]) minIdx = i;\n        if (nums[i] > nums[maxIdx]) maxIdx = i;\n    }\n    \n    // Calculate distances from both ends\n    const minFromLeft = minIdx + 1;\n    const minFromRight = n - minIdx;\n    const maxFromLeft = maxIdx + 1;\n    const maxFromRight = n - maxIdx;\n    \n    // Three strategies\n    const strategy1 = Math.max(minFromLeft, maxFromLeft);\n    const strategy2 = Math.max(minFromRight, maxFromRight);\n    const strategy3 = Math.min(minFromLeft, minFromRight) + Math.min(maxFromLeft, maxFromRight);\n    \n    return Math.min(strategy1, strategy2, strategy3);\n}"
      }
    }
  ],
  "commonMistakes": [
    "Forgetting to handle edge case when array has only 1 or 2 elements (should return array length)",
    "Not considering all three removal strategies - some candidates only check two",
    "Off-by-one error when calculating deletions from left (should be index + 1, not index)",
    "Incorrectly calculating distance from right end (should be n - index, not n - index - 1)",
    "Confusing the index with the actual number of deletions needed",
    "Not finding the minimum and maximum values correctly when there are duplicates",
    "Trying to actually remove elements instead of just calculating the count",
    "Assuming min and max are at specific positions without finding them first"
  ],
  "hints": [
    "You can only remove elements from the ends of the array (left or right)",
    "There are exactly three possible strategies to remove both min and max",
    "Think about which end each element (min and max) is closer to",
    "The answer depends only on the positions of min and max, not other elements",
    "Consider: (1) both from left, (2) both from right, (3) one from each end"
  ],
  "followUp": [
    "What if you need to remove the k smallest and k largest elements optimally?",
    "How would you solve this if you could remove elements from any position in O(1)?",
    "What if the array is circular and you can start removing from any position?",
    "Can you extend this to remove all elements less than X and greater than Y?",
    "How would you handle this if elements have weights and you want to minimize total weight removed?",
    "What if you need to keep track of which specific elements were removed?",
    "How would this change if you could remove at most k total elements?"
  ],
  "companies": [
    "Amazon",
    "Google",
    "Microsoft",
    "Apple",
    "Meta",
    "Bloomberg",
    "Oracle"
  ],
  "tags": [
    "Array",
    "Greedy",
    "Math",
    "Two Pointers"
  ],
  "relatedProblems": [
    "Minimum Operations to Make Array Equal",
    "Minimum Deletions to Make Array Beautiful",
    "Remove Element",
    "Find Minimum in Rotated Sorted Array",
    "Maximum Subarray",
    "Remove Duplicates from Sorted Array",
    "Shortest Subarray to be Removed to Make Array Sorted",
    "Maximum Sum Circular Subarray"
  ]
}
