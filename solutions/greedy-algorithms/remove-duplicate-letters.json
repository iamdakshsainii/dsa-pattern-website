{
  "questionId": "694d4a3a98494915f3bc8f0b",
  "questionSlug": "remove-duplicate-letters",
  "title": "Remove Duplicate Letters",
  "difficulty": "Hard",
  "resources": {
    "leetcode": "https://leetcode.com/problems/remove-duplicate-letters/",
    "videos": [
      {
        "title": "Remove Duplicate Letters - Greedy + Stack - Leetcode 316",
        "url": "https://www.youtube.com/watch?v=Yn_Z02_kudU",
        "channel": "NeetCode",
        "duration": "10:15",
        "language": "English"
      },
      {
        "title": "Remove Duplicate Letters | Monotonic Stack Approach",
        "url": "https://www.youtube.com/watch?v=zq-hOTFdVVg",
        "channel": "TECH DOSE",
        "duration": "14:30",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Remove Duplicate Letters Solution",
        "url": "https://leetcode.com/problems/remove-duplicate-letters/solution/",
        "source": "LeetCode Editorial"
      },
      {
        "title": "Remove Duplicate Letters Explained",
        "url": "https://algo.monster/liteproblems/316",
        "source": "AlgoMonster"
      }
    ],
    "practice": [
      {
        "title": "Smallest Subsequence of Distinct Characters",
        "url": "https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/",
        "platform": "LeetCode"
      },
      {
        "title": "Create Maximum Number",
        "url": "https://leetcode.com/problems/create-maximum-number/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Monotonic Stack pattern when you need to maintain increasing/decreasing order while processing elements sequentially. Key indicators: need smallest/largest result, can remove elements, have frequency/last occurrence information, greedy character selection.",
  "approaches": [
    {
      "name": "Greedy with Recursion",
      "order": 1,
      "intuition": "For each position, find the smallest character that still allows us to include all remaining unique characters. Recursively solve for the remaining substring.",
      "approach": "At each step, find the smallest character that appears before or at the last occurrence of every character we still need. Remove all characters up to and including this character, then recursively solve for the remaining string.",
      "steps": [
        "Count frequency of each character in the string",
        "Find the set of unique characters remaining",
        "Find the position of the last occurrence of any character",
        "Within range [0, lastPos], find the smallest character",
        "Add this character to result and remove it from consideration",
        "Recursively solve for substring after this character",
        "Base case: when no characters remain, return empty string"
      ],
      "complexity": {
        "time": "O(n * 26)",
        "space": "O(n)",
        "timeExplanation": "For each of at most 26 recursive calls, we scan the string once O(n)",
        "spaceExplanation": "Recursion stack depth up to 26, plus space for frequency counting"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    string removeDuplicateLetters(string s) {\n        // Count frequency of each character\n        unordered_map<char, int> freq;\n        for (char c : s) {\n            freq[c]++;\n        }\n        return solve(s, freq);\n    }\n    \n    string solve(string s, unordered_map<char, int>& freq) {\n        if (s.empty()) return \"\";\n        \n        // Find position of last occurrence of any remaining char\n        int lastPos = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (freq[s[i]] == 1) {\n                lastPos = max(lastPos, i);\n            }\n        }\n        \n        // Find smallest character within valid range\n        char minChar = 'z' + 1;\n        int minPos = 0;\n        for (int i = 0; i <= lastPos; i++) {\n            if (s[i] < minChar) {\n                minChar = s[i];\n                minPos = i;\n            }\n        }\n        \n        // Remove this character from frequency map\n        freq.erase(minChar);\n        \n        // Build new string without minChar and solve recursively\n        string remaining = \"\";\n        for (int i = minPos + 1; i < s.length(); i++) {\n            if (s[i] != minChar) {\n                remaining += s[i];\n            }\n        }\n        \n        return minChar + solve(remaining, freq);\n    }\n};",
        "java": "class Solution {\n    public String removeDuplicateLetters(String s) {\n        Map<Character, Integer> freq = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freq.put(c, freq.getOrDefault(c, 0) + 1);\n        }\n        return solve(s, freq);\n    }\n    \n    private String solve(String s, Map<Character, Integer> freq) {\n        if (s.isEmpty()) return \"\";\n        \n        // Find position of last occurrence of any remaining char\n        int lastPos = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (freq.getOrDefault(s.charAt(i), 0) == 1) {\n                lastPos = Math.max(lastPos, i);\n            }\n        }\n        \n        // Find smallest character within valid range\n        char minChar = (char)('z' + 1);\n        int minPos = 0;\n        for (int i = 0; i <= lastPos; i++) {\n            if (s.charAt(i) < minChar) {\n                minChar = s.charAt(i);\n                minPos = i;\n            }\n        }\n        \n        // Remove this character from frequency map\n        freq.remove(minChar);\n        \n        // Build new string without minChar\n        StringBuilder remaining = new StringBuilder();\n        for (int i = minPos + 1; i < s.length(); i++) {\n            if (s.charAt(i) != minChar) {\n                remaining.append(s.charAt(i));\n            }\n        }\n        \n        return minChar + solve(remaining.toString(), freq);\n    }\n}",
        "python": "def removeDuplicateLetters(s):\n    from collections import Counter\n    \n    freq = Counter(s)\n    \n    def solve(s, freq):\n        if not s:\n            return \"\"\n        \n        # Find position of last occurrence of any remaining char\n        last_pos = 0\n        for i, c in enumerate(s):\n            if freq[c] == 1:\n                last_pos = max(last_pos, i)\n        \n        # Find smallest character within valid range\n        min_char = min(s[:last_pos + 1])\n        min_pos = s.index(min_char)\n        \n        # Remove this character from frequency\n        del freq[min_char]\n        \n        # Build remaining string without min_char\n        remaining = s[min_pos + 1:].replace(min_char, '')\n        \n        return min_char + solve(remaining, freq)\n    \n    return solve(s, freq)",
        "javascript": "function removeDuplicateLetters(s) {\n    const freq = {};\n    for (const c of s) {\n        freq[c] = (freq[c] || 0) + 1;\n    }\n    \n    function solve(s, freq) {\n        if (!s) return \"\";\n        \n        // Find position of last occurrence of any remaining char\n        let lastPos = 0;\n        for (let i = 0; i < s.length; i++) {\n            if (freq[s[i]] === 1) {\n                lastPos = Math.max(lastPos, i);\n            }\n        }\n        \n        // Find smallest character within valid range\n        let minChar = 'z' + '1';\n        let minPos = 0;\n        for (let i = 0; i <= lastPos; i++) {\n            if (s[i] < minChar) {\n                minChar = s[i];\n                minPos = i;\n            }\n        }\n        \n        // Remove this character from frequency\n        delete freq[minChar];\n        \n        // Build remaining string without minChar\n        let remaining = \"\";\n        for (let i = minPos + 1; i < s.length; i++) {\n            if (s[i] !== minChar) {\n                remaining += s[i];\n            }\n        }\n        \n        return minChar + solve(remaining, freq);\n    }\n    \n    return solve(s, freq);\n}"
      }
    },
    {
      "name": "Monotonic Stack (Optimal)",
      "order": 2,
      "intuition": "Build result using a stack, removing characters from the stack if: (1) current character is smaller, (2) the removed character appears later in the string, and (3) current character isn't already in result. This ensures lexicographically smallest result.",
      "approach": "Use a stack to build the result. Track character frequencies and which characters are in the stack. For each character, if it's already in the stack, skip it. Otherwise, pop larger characters from the stack if they appear later. Add current character to stack.",
      "steps": [
        "Count frequency/last occurrence of each character",
        "Initialize empty stack and 'inStack' set",
        "For each character in string:",
        "  - Decrease its remaining count",
        "  - If already in stack, continue to next character",
        "  - While stack top > current char AND stack top appears later:",
        "    * Pop from stack and remove from inStack set",
        "  - Push current character to stack",
        "  - Add current character to inStack set",
        "Convert stack to string and return"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through string, each character pushed/popped at most once",
        "spaceExplanation": "Stack holds at most 26 characters, frequency array is O(26) = O(1)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    string removeDuplicateLetters(string s) {\n        // Count frequency of each character\n        vector<int> count(26, 0);\n        vector<bool> inStack(26, false);\n        \n        for (char c : s) {\n            count[c - 'a']++;\n        }\n        \n        string result = \"\";\n        \n        for (char c : s) {\n            // Decrease count for current character\n            count[c - 'a']--;\n            \n            // If already in result, skip\n            if (inStack[c - 'a']) {\n                continue;\n            }\n            \n            // Remove larger characters if they appear later\n            while (!result.empty() && result.back() > c && count[result.back() - 'a'] > 0) {\n                inStack[result.back() - 'a'] = false;\n                result.pop_back();\n            }\n            \n            // Add current character\n            result += c;\n            inStack[c - 'a'] = true;\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public String removeDuplicateLetters(String s) {\n        // Count frequency of each character\n        int[] count = new int[26];\n        boolean[] inStack = new boolean[26];\n        \n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            // Decrease count for current character\n            count[c - 'a']--;\n            \n            // If already in result, skip\n            if (inStack[c - 'a']) {\n                continue;\n            }\n            \n            // Remove larger characters if they appear later\n            while (result.length() > 0 && result.charAt(result.length() - 1) > c \n                   && count[result.charAt(result.length() - 1) - 'a'] > 0) {\n                inStack[result.charAt(result.length() - 1) - 'a'] = false;\n                result.deleteCharAt(result.length() - 1);\n            }\n            \n            // Add current character\n            result.append(c);\n            inStack[c - 'a'] = true;\n        }\n        \n        return result.toString();\n    }\n}",
        "python": "def removeDuplicateLetters(s):\n    # Count frequency of each character\n    count = {c: s.count(c) for c in set(s)}\n    in_stack = set()\n    result = []\n    \n    for c in s:\n        # Decrease count for current character\n        count[c] -= 1\n        \n        # If already in result, skip\n        if c in in_stack:\n            continue\n        \n        # Remove larger characters if they appear later\n        while result and result[-1] > c and count[result[-1]] > 0:\n            removed = result.pop()\n            in_stack.remove(removed)\n        \n        # Add current character\n        result.append(c)\n        in_stack.add(c)\n    \n    return ''.join(result)",
        "javascript": "function removeDuplicateLetters(s) {\n    // Count frequency of each character\n    const count = {};\n    const inStack = new Set();\n    \n    for (const c of s) {\n        count[c] = (count[c] || 0) + 1;\n    }\n    \n    const result = [];\n    \n    for (const c of s) {\n        // Decrease count for current character\n        count[c]--;\n        \n        // If already in result, skip\n        if (inStack.has(c)) {\n            continue;\n        }\n        \n        // Remove larger characters if they appear later\n        while (result.length > 0 && result[result.length - 1] > c \n               && count[result[result.length - 1]] > 0) {\n            const removed = result.pop();\n            inStack.delete(removed);\n        }\n        \n        // Add current character\n        result.push(c);\n        inStack.add(c);\n    }\n    \n    return result.join('');\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not tracking if a character is already in the result, leading to duplicates",
    "Removing a character from stack even when it doesn't appear later in string",
    "Not properly maintaining the frequency/count of remaining characters",
    "Forgetting to decrease the count for each character as we process it",
    "Not using a set to track 'inStack' status, leading to O(n) lookups",
    "Popping characters without checking if they appear again later"
  ],
  "hints": [
    "The result must contain each character exactly once",
    "To get the smallest lexicographical order, try to place smaller characters first",
    "You can remove a character from consideration if a smaller one comes and the removed character appears later",
    "Think about using a stack to build the result incrementally",
    "Track which characters are already in your result to avoid duplicates"
  ],
  "followUp": [
    "What if you need to find the largest lexicographical order instead?",
    "How would you modify this to keep exactly k distinct characters?",
    "Can you solve this if you're allowed to rearrange the string first?",
    "What if each character has a priority/weight and you need to minimize total weight?",
    "How would you handle Unicode characters or case sensitivity?"
  ],
  "companies": [
    "Google",
    "Facebook",
    "Amazon",
    "Microsoft",
    "Bloomberg",
    "Oracle"
  ],
  "tags": [
    "String",
    "Stack",
    "Greedy",
    "Monotonic Stack"
  ],
  "relatedProblems": [
    "Smallest Subsequence of Distinct Characters",
    "Create Maximum Number",
    "Shortest Unsorted Continuous Subarray",
    "Remove K Digits",
    "Increasing Triplet Subsequence"
  ]
}
