{
  "questionId": "694d4a3a98494915f3bc8f08",
  "questionSlug": "valid-palindrome-ii",
  "resources": {
    "leetcode": "https://leetcode.com/problems/valid-palindrome-ii/",
    "videos": [
      {
        "title": "Valid Palindrome II - Leetcode 680",
        "url": "https://www.youtube.com/watch?v=JrxRYBwG6EI",
        "channel": "NeetCode",
        "duration": "9:30",
        "language": "English"
      },
      {
        "title": "Valid Palindrome II | Two Pointer Approach",
        "url": "https://www.youtube.com/watch?v=4-3FKdJPu1Y",
        "channel": "TECH DOSE",
        "duration": "13:45",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Valid Palindrome II Solution",
        "url": "https://leetcode.com/problems/valid-palindrome-ii/solution/",
        "source": "LeetCode Editorial"
      },
      {
        "title": "Valid Palindrome II Explained",
        "url": "https://algo.monster/liteproblems/680",
        "source": "AlgoMonster"
      }
    ],
    "practice": [
      {
        "title": "Valid Palindrome",
        "url": "https://leetcode.com/problems/valid-palindrome/",
        "platform": "LeetCode"
      },
      {
        "title": "Palindrome Linked List",
        "url": "https://leetcode.com/problems/palindrome-linked-list/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Two Pointers pattern when validating palindromes with modifications allowed. Key indicators: check if string can form palindrome, allowed to skip/delete characters, need to check from both ends, optimization involves comparing from outside-in.",
  "approaches": [
    {
      "name": "Brute Force - Try Deleting Each Character",
      "order": 1,
      "intuition": "Try removing each character one at a time and check if the resulting string is a palindrome. If any deletion results in a palindrome, return true.",
      "approach": "For each position in the string, create a new string without that character and check if it's a palindrome. Use a helper function to validate palindromes.",
      "steps": [
        "Create helper function to check if a string is palindrome",
        "Iterate through each index in the string",
        "For each index, create string without character at that index",
        "Check if resulting string is a palindrome",
        "If palindrome found, return true",
        "If no deletion creates palindrome, return false",
        "Edge case: if original string is already palindrome, return true"
      ],
      "complexity": {
        "time": "O(nÂ²)",
        "space": "O(n)",
        "timeExplanation": "For each of n positions, we check palindrome in O(n) time",
        "spaceExplanation": "Creating new strings for each deletion attempt"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool validPalindrome(string s) {\n        // Check if already palindrome\n        if (isPalindrome(s, 0, s.length() - 1)) {\n            return true;\n        }\n        \n        // Try deleting each character\n        for (int i = 0; i < s.length(); i++) {\n            string modified = s.substr(0, i) + s.substr(i + 1);\n            if (isPalindrome(modified, 0, modified.length() - 1)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    bool isPalindrome(const string& s, int left, int right) {\n        while (left < right) {\n            if (s[left] != s[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n};",
        "java": "class Solution {\n    public boolean validPalindrome(String s) {\n        // Check if already palindrome\n        if (isPalindrome(s, 0, s.length() - 1)) {\n            return true;\n        }\n        \n        // Try deleting each character\n        for (int i = 0; i < s.length(); i++) {\n            String modified = s.substring(0, i) + s.substring(i + 1);\n            if (isPalindrome(modified, 0, modified.length() - 1)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean isPalindrome(String s, int left, int right) {\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}",
        "python": "def validPalindrome(s):\n    def is_palindrome(string, left, right):\n        while left < right:\n            if string[left] != string[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    # Check if already palindrome\n    if is_palindrome(s, 0, len(s) - 1):\n        return True\n    \n    # Try deleting each character\n    for i in range(len(s)):\n        modified = s[:i] + s[i+1:]\n        if is_palindrome(modified, 0, len(modified) - 1):\n            return True\n    \n    return False",
        "javascript": "function validPalindrome(s) {\n    function isPalindrome(str, left, right) {\n        while (left < right) {\n            if (str[left] !== str[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n    \n    // Check if already palindrome\n    if (isPalindrome(s, 0, s.length - 1)) {\n        return true;\n    }\n    \n    // Try deleting each character\n    for (let i = 0; i < s.length; i++) {\n        const modified = s.slice(0, i) + s.slice(i + 1);\n        if (isPalindrome(modified, 0, modified.length - 1)) {\n            return true;\n        }\n    }\n    \n    return false;\n}"
      }
    },
    {
      "name": "Two Pointers (Optimal)",
      "order": 2,
      "intuition": "Use two pointers from both ends. When characters don't match, try skipping either the left or right character and check if remaining substring is palindrome. This leverages the fact that we only need to delete at most one character.",
      "approach": "Start with two pointers at both ends. Move them inward while characters match. When mismatch occurs, try two options: skip left character or skip right character. Check if either option forms a palindrome for the remaining substring.",
      "steps": [
        "Initialize two pointers: left at start, right at end",
        "While left < right:",
        "  - If s[left] == s[right], move both pointers inward",
        "  - If s[left] != s[right], we found a mismatch:",
        "    * Try skipping left character: check if s[left+1...right] is palindrome",
        "    * Try skipping right character: check if s[left...right-1] is palindrome",
        "    * Return true if either option is palindrome",
        "If loop completes without mismatch, return true (already palindrome)",
        "Use helper function to check palindrome for substring"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass with two pointers, at most one additional palindrome check of O(n)",
        "spaceExplanation": "Only using pointer variables, no extra data structures"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    bool validPalindrome(string s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            if (s[left] != s[right]) {\n                // Try skipping left or right character\n                return isPalindrome(s, left + 1, right) || \n                       isPalindrome(s, left, right - 1);\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n    \n    bool isPalindrome(const string& s, int left, int right) {\n        while (left < right) {\n            if (s[left] != s[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n};",
        "java": "class Solution {\n    public boolean validPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                // Try skipping left or right character\n                return isPalindrome(s, left + 1, right) || \n                       isPalindrome(s, left, right - 1);\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n    \n    private boolean isPalindrome(String s, int left, int right) {\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}",
        "python": "def validPalindrome(s):\n    def is_palindrome(left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            # Try skipping left or right character\n            return is_palindrome(left + 1, right) or is_palindrome(left, right - 1)\n        left += 1\n        right -= 1\n    \n    return True",
        "javascript": "function validPalindrome(s) {\n    function isPalindrome(left, right) {\n        while (left < right) {\n            if (s[left] !== s[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n    \n    let left = 0, right = s.length - 1;\n    \n    while (left < right) {\n        if (s[left] !== s[right]) {\n            // Try skipping left or right character\n            return isPalindrome(left + 1, right) || isPalindrome(left, right - 1);\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Trying to handle multiple deletions instead of just one",
    "Not checking both possibilities (skip left vs skip right) when mismatch found",
    "Modifying the string instead of just checking substrings with pointers",
    "Forgetting that the string might already be a palindrome without deletion",
    "Not properly handling edge cases like single character or two-character strings",
    "Implementing recursive solution without proper base cases"
  ],
  "hints": [
    "If the string is already a palindrome, you don't need to delete anything",
    "Use two pointers starting from both ends",
    "When you find a mismatch, you have two choices: remove left or remove right",
    "You only need to check one level of deletion, not multiple levels",
    "After finding a mismatch, check if remaining substring is palindrome"
  ],
  "followUp": [
    "What if you're allowed to delete at most k characters instead of just one?",
    "How would you find the actual character to delete (not just return true/false)?",
    "Can you solve this if the string has millions of characters efficiently?",
    "What if you need to return the lexicographically smallest palindrome after deletion?",
    "How would you handle this problem with case-insensitive comparison?"
  ],
  "companies": [
    "Facebook",
    "Amazon",
    "Microsoft",
    "Google",
    "Apple",
    "Bloomberg",
    "Adobe"
  ],
  "tags": [
    "String",
    "Two Pointers",
    "Greedy"
  ],
  "relatedProblems": [
    "Valid Palindrome",
    "Palindrome Linked List",
    "Longest Palindromic Substring",
    "Palindrome Permutation",
    "Remove Palindromic Subsequences"
  ]
}
