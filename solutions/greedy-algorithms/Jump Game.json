{
  "questionId": "LC-55",
  "questionSlug": "jump-game",
  "title": "Jump Game",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/jump-game/",
    "videos": [
      {
        "title": "Jump Game - Greedy Solution",
        "url": "https://www.youtube.com/watch?v=Yan0cv2cLy8",
        "channel": "NeetCode",
        "duration": "9:45",
        "language": "English"
      },
      {
        "title": "Jump Game - Multiple Approaches",
        "url": "https://www.youtube.com/watch?v=muDPTDrpS28",
        "channel": "takeUforward",
        "duration": "12:30",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Jump Game - Official Solution",
        "url": "https://leetcode.com/problems/jump-game/solution/",
        "source": "LeetCode"
      },
      {
        "title": "Jump Game - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/jump-game/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Can reach end with jumps? Track maximum reachable position greedily!",
  "approaches": [
    {
      "name": "Greedy - Track Max Reachable (Optimal)",
      "order": 1,
      "intuition": "Track the farthest position we can reach. If current position is beyond max reachable, we're stuck. Otherwise update max reachable.",
      "approach": "Iterate through array, maintaining maximum reachable position. If we can reach current index, update max. Check if last index is reachable.",
      "steps": [
        "Initialize maxReach = 0",
        "For i from 0 to n-1:",
        "  If i > maxReach:",
        "    return false (can't reach current position)",
        "  Update maxReach = max(maxReach, i + nums[i])",
        "  If maxReach >= n-1:",
        "    return true (can reach last index)",
        "Return maxReach >= n-1"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through array",
        "spaceExplanation": "Only using one variable"
      },
      "code": {
        "cpp": "bool canJump(vector<int>& nums) {\n    int n = nums.size();\n    int maxReach = 0;\n    \n    for (int i = 0; i < n; i++) {\n        // If current position is beyond max reachable, stuck\n        if (i > maxReach) {\n            return false;\n        }\n        \n        // Update max reachable from current position\n        maxReach = max(maxReach, i + nums[i]);\n        \n        // Early exit if we can reach the end\n        if (maxReach >= n - 1) {\n            return true;\n        }\n    }\n    \n    return maxReach >= n - 1;\n}\n\n// Example: nums = [2,3,1,1,4]\n// i=0: maxReach = max(0, 0+2) = 2\n// i=1: maxReach = max(2, 1+3) = 4 >= 4 → return true\n\n// Example: nums = [3,2,1,0,4]\n// i=0: maxReach = max(0, 0+3) = 3\n// i=1: maxReach = max(3, 1+2) = 3\n// i=2: maxReach = max(3, 2+1) = 3\n// i=3: maxReach = max(3, 3+0) = 3\n// i=4: 4 > 3, return false (can't reach position 4)",
        "java": "public boolean canJump(int[] nums) {\n    int n = nums.length;\n    int maxReach = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (i > maxReach) {\n            return false;\n        }\n        \n        maxReach = Math.max(maxReach, i + nums[i]);\n        \n        if (maxReach >= n - 1) {\n            return true;\n        }\n    }\n    \n    return maxReach >= n - 1;\n}",
        "python": "def canJump(nums: List[int]) -> bool:\n    n = len(nums)\n    max_reach = 0\n    \n    for i in range(n):\n        if i > max_reach:\n            return False\n        \n        max_reach = max(max_reach, i + nums[i])\n        \n        if max_reach >= n - 1:\n            return True\n    \n    return max_reach >= n - 1",
        "javascript": "var canJump = function(nums) {\n    const n = nums.length;\n    let maxReach = 0;\n    \n    for (let i = 0; i < n; i++) {\n        if (i > maxReach) {\n            return false;\n        }\n        \n        maxReach = Math.max(maxReach, i + nums[i]);\n        \n        if (maxReach >= n - 1) {\n            return true;\n        }\n    }\n    \n    return maxReach >= n - 1;\n};"
      }
    },
    {
      "name": "Greedy - Work Backwards",
      "order": 2,
      "intuition": "Start from end, find if each position can be reached from a previous reachable position. Work backwards to start.",
      "approach": "Start with last position as goal. Move goal backwards whenever we find a position that can reach current goal.",
      "steps": [
        "Initialize goal = n - 1 (last index)",
        "For i from n-2 down to 0:",
        "  If i + nums[i] >= goal:",
        "    Update goal = i (can reach from here)",
        "Return goal == 0 (can reach from start)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single backward pass",
        "spaceExplanation": "One variable"
      },
      "code": {
        "cpp": "bool canJump(vector<int>& nums) {\n    int n = nums.size();\n    int goal = n - 1;\n    \n    for (int i = n - 2; i >= 0; i--) {\n        if (i + nums[i] >= goal) {\n            goal = i;\n        }\n    }\n    \n    return goal == 0;\n}\n\n// Example: nums = [2,3,1,1,4]\n// goal = 4\n// i=3: 3+1=4 >= 4 → goal=3\n// i=2: 2+1=3 >= 3 → goal=2\n// i=1: 1+3=4 >= 2 → goal=1\n// i=0: 0+2=2 >= 1 → goal=0\n// goal == 0 → return true",
        "java": "public boolean canJump(int[] nums) {\n    int n = nums.length;\n    int goal = n - 1;\n    \n    for (int i = n - 2; i >= 0; i--) {\n        if (i + nums[i] >= goal) {\n            goal = i;\n        }\n    }\n    \n    return goal == 0;\n}",
        "python": "def canJump(nums: List[int]) -> bool:\n    n = len(nums)\n    goal = n - 1\n    \n    for i in range(n - 2, -1, -1):\n        if i + nums[i] >= goal:\n            goal = i\n    \n    return goal == 0",
        "javascript": "var canJump = function(nums) {\n    const n = nums.length;\n    let goal = n - 1;\n    \n    for (let i = n - 2; i >= 0; i--) {\n        if (i + nums[i] >= goal) {\n            goal = i;\n        }\n    }\n    \n    return goal === 0;\n};"
      }
    },
    {
      "name": "Dynamic Programming (Not Optimal)",
      "order": 3,
      "intuition": "For each position, mark if it's reachable. Use DP to propagate reachability from start to end.",
      "approach": "DP array where dp[i] = true if position i is reachable. Build from left to right.",
      "steps": [
        "Create dp[n], dp[0] = true",
        "For i from 0 to n-1:",
        "  If dp[i] is false: continue",
        "  For j from i+1 to min(i+nums[i], n-1):",
        "    dp[j] = true",
        "Return dp[n-1]"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(n)",
        "timeExplanation": "For each position, potentially mark all reachable positions",
        "spaceExplanation": "DP array of size n"
      },
      "code": {
        "cpp": "bool canJump(vector<int>& nums) {\n    int n = nums.size();\n    vector<bool> dp(n, false);\n    dp[0] = true;\n    \n    for (int i = 0; i < n; i++) {\n        if (!dp[i]) continue;\n        \n        for (int j = i + 1; j <= min(i + nums[i], n - 1); j++) {\n            dp[j] = true;\n        }\n        \n        if (dp[n - 1]) return true;\n    }\n    \n    return dp[n - 1];\n}\n\n// This works but O(n²) - greedy is better O(n)",
        "java": "public boolean canJump(int[] nums) {\n    int n = nums.length;\n    boolean[] dp = new boolean[n];\n    dp[0] = true;\n    \n    for (int i = 0; i < n; i++) {\n        if (!dp[i]) continue;\n        \n        for (int j = i + 1; j <= Math.min(i + nums[i], n - 1); j++) {\n            dp[j] = true;\n        }\n        \n        if (dp[n - 1]) return true;\n    }\n    \n    return dp[n - 1];\n}",
        "python": "def canJump(nums: List[int]) -> bool:\n    n = len(nums)\n    dp = [False] * n\n    dp[0] = True\n    \n    for i in range(n):\n        if not dp[i]:\n            continue\n        \n        for j in range(i + 1, min(i + nums[i] + 1, n)):\n            dp[j] = True\n        \n        if dp[n - 1]:\n            return True\n    \n    return dp[n - 1]",
        "javascript": "var canJump = function(nums) {\n    const n = nums.length;\n    const dp = new Array(n).fill(false);\n    dp[0] = true;\n    \n    for (let i = 0; i < n; i++) {\n        if (!dp[i]) continue;\n        \n        for (let j = i + 1; j <= Math.min(i + nums[i], n - 1); j++) {\n            dp[j] = true;\n        }\n        \n        if (dp[n - 1]) return true;\n    }\n    \n    return dp[n - 1];\n};"
      }
    }
  ],
  "commonMistakes": [
    "Trying to find actual path instead of just checking if end is reachable",
    "Using BFS/DFS when simple greedy works (over-complicating)",
    "Not checking if current position is reachable before updating max",
    "Confusing with Jump Game II (this asks CAN reach, not minimum jumps)",
    "Off-by-one: checking i + nums[i] > n instead of >= n-1",
    "Not handling edge case: array with single element (already at end)"
  ],
  "hints": [
    "Don't need to track path, just check if end is reachable",
    "Greedy insight: if we can reach position i, we can reach all positions before i",
    "Track farthest reachable position as we go",
    "If current position > max reachable, we're stuck (can't reach current position)",
    "Early exit optimization: if maxReach >= n-1, done",
    "Backward approach: treat last position as goal, move goal backward"
  ],
  "followUp": [
    "Find minimum number of jumps? (Jump Game II - different problem, needs different approach)",
    "Count all possible paths? (Different problem - backtracking or DP)",
    "What if we can jump backwards? (Different constraints, similar greedy)",
    "What if array is very large? (Same O(n) algorithm works)",
    "Return the actual jump sequence? (Need to track path, not just boolean)",
    "What if negative numbers allowed in array? (Need to reconsider logic)"
  ],
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Bloomberg", "Apple"],
  "tags": ["greedy", "array", "dynamic-programming"],
  "relatedProblems": [
    "Jump Game II",
    "Jump Game III",
    "Jump Game IV",
    "Minimum Number of Jumps to Reach End"
  ]
}
