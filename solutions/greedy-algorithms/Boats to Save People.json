{
  "questionId": "LC-881",
  "questionSlug": "boats-to-save-people",
  "title": "Boats to Save People",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/boats-to-save-people/",
    "videos": [
      {
        "title": "Boats to Save People - Two Pointer Greedy",
        "url": "https://www.youtube.com/watch?v=XbaxWuHIWUs",
        "channel": "NeetCode",
        "duration": "7:20",
        "language": "English"
      },
      {
        "title": "Boats to Save People Explained",
        "url": "https://www.youtube.com/watch?v=I7WOLVQEtyM",
        "channel": "takeUforward",
        "duration": "10:45",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Boats to Save People - Official Solution",
        "url": "https://leetcode.com/problems/boats-to-save-people/solution/",
        "source": "LeetCode"
      },
      {
        "title": "Boats to Save People - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/minimum-boats-to-save-people/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/boats-to-save-people/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Pair items to minimize count with capacity constraint? Sort and use two pointers from ends!",
  "approaches": [
    {
      "name": "Two Pointer Greedy (Optimal)",
      "order": 1,
      "intuition": "Sort people. Try to pair heaviest with lightest. If they fit together, great! Otherwise, heaviest goes alone.",
      "approach": "Sort array. Use two pointers: left (lightest) and right (heaviest). Greedily pair them if possible.",
      "steps": [
        "Sort people array ascending",
        "Initialize left = 0, right = n-1, boats = 0",
        "While left <= right:",
        "  If people[left] + people[right] <= limit:",
        "    Both can share boat: left++, right--",
        "  Else:",
        "    Heaviest person goes alone: right--",
        "  boats++",
        "Return boats"
      ],
      "complexity": {
        "time": "O(n log n)",
        "space": "O(1)",
        "timeExplanation": "Sorting dominates, two pointer scan is O(n)",
        "spaceExplanation": "Constant space (sorting in-place or O(1) pointers)"
      },
      "code": {
        "cpp": "int numRescueBoats(vector<int>& people, int limit) {\n    sort(people.begin(), people.end());\n    \n    int left = 0, right = people.size() - 1;\n    int boats = 0;\n    \n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;  // Lightest person paired\n        }\n        right--;  // Heaviest person always goes\n        boats++;\n    }\n    \n    return boats;\n}\n\n// Example: people = [1,2], limit = 3\n// After sort: [1,2]\n// left=0, right=1: 1+2=3 <= 3 → pair them, boats=1\n// Return 1\n\n// Example: people = [3,2,2,1], limit = 3\n// After sort: [1,2,2,3]\n// left=0, right=3: 1+3=4 > 3 → 3 alone, boats=1, right=2\n// left=0, right=2: 1+2=3 <= 3 → pair, boats=2, left=1, right=1\n// left=1, right=1: 2 alone, boats=3\n// Return 3",
        "java": "public int numRescueBoats(int[] people, int limit) {\n    Arrays.sort(people);\n    \n    int left = 0, right = people.length - 1;\n    int boats = 0;\n    \n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;\n        }\n        right--;\n        boats++;\n    }\n    \n    return boats;\n}",
        "python": "def numRescueBoats(people: List[int], limit: int) -> int:\n    people.sort()\n    \n    left, right = 0, len(people) - 1\n    boats = 0\n    \n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    \n    return boats",
        "javascript": "var numRescueBoats = function(people, limit) {\n    people.sort((a, b) => a - b);\n    \n    let left = 0, right = people.length - 1;\n    let boats = 0;\n    \n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;\n        }\n        right--;\n        boats++;\n    }\n    \n    return boats;\n};"
      }
    },
    {
      "name": "Two Pointer with Explicit Pairing",
      "order": 2,
      "intuition": "Same as approach 1 but with more explicit logic to show when pairing happens vs single.",
      "approach": "Sort and use two pointers with clear conditional logic for pairing.",
      "steps": [
        "Sort people array",
        "left = 0, right = n-1, boats = 0",
        "While left <= right:",
        "  If left == right: one person left, boats++, break",
        "  If people[left] + people[right] <= limit:",
        "    Pair them: left++, right--, boats++",
        "  Else:",
        "    Heaviest alone: right--, boats++",
        "Return boats"
      ],
      "complexity": {
        "time": "O(n log n)",
        "space": "O(1)",
        "timeExplanation": "Sorting + linear scan",
        "spaceExplanation": "Constant space"
      },
      "code": {
        "cpp": "int numRescueBoats(vector<int>& people, int limit) {\n    sort(people.begin(), people.end());\n    \n    int left = 0, right = people.size() - 1;\n    int boats = 0;\n    \n    while (left <= right) {\n        if (left == right) {\n            // One person remaining\n            boats++;\n            break;\n        }\n        \n        if (people[left] + people[right] <= limit) {\n            // Can pair lightest with heaviest\n            left++;\n            right--;\n            boats++;\n        } else {\n            // Heaviest goes alone\n            right--;\n            boats++;\n        }\n    }\n    \n    return boats;\n}",
        "java": "public int numRescueBoats(int[] people, int limit) {\n    Arrays.sort(people);\n    \n    int left = 0, right = people.length - 1;\n    int boats = 0;\n    \n    while (left <= right) {\n        if (left == right) {\n            boats++;\n            break;\n        }\n        \n        if (people[left] + people[right] <= limit) {\n            left++;\n            right--;\n            boats++;\n        } else {\n            right--;\n            boats++;\n        }\n    }\n    \n    return boats;\n}",
        "python": "def numRescueBoats(people: List[int], limit: int) -> int:\n    people.sort()\n    \n    left, right = 0, len(people) - 1\n    boats = 0\n    \n    while left <= right:\n        if left == right:\n            boats += 1\n            break\n        \n        if people[left] + people[right] <= limit:\n            left += 1\n            right -= 1\n            boats += 1\n        else:\n            right -= 1\n            boats += 1\n    \n    return boats",
        "javascript": "var numRescueBoats = function(people, limit) {\n    people.sort((a, b) => a - b);\n    \n    let left = 0, right = people.length - 1;\n    let boats = 0;\n    \n    while (left <= right) {\n        if (left === right) {\n            boats++;\n            break;\n        }\n        \n        if (people[left] + people[right] <= limit) {\n            left++;\n            right--;\n            boats++;\n        } else {\n            right--;\n            boats++;\n        }\n    }\n    \n    return boats;\n};"
      }
    },
    {
      "name": "Counting Sort Optimization",
      "order": 3,
      "intuition": "If weight range is small, use counting sort for O(n + k) time where k is weight range.",
      "approach": "Count frequency of each weight, then pair from both ends using frequency array.",
      "steps": [
        "If limit is small (say <= 10000), use counting sort",
        "Create freq[limit+1] array",
        "Count frequency of each weight",
        "Use two pointers on frequency array",
        "Return boats"
      ],
      "complexity": {
        "time": "O(n + k)",
        "space": "O(k)",
        "timeExplanation": "Counting sort O(n+k) where k is weight range (limit)",
        "spaceExplanation": "Frequency array of size k"
      },
      "code": {
        "cpp": "int numRescueBoats(vector<int>& people, int limit) {\n    vector<int> freq(limit + 1, 0);\n    \n    // Counting sort\n    for (int weight : people) {\n        freq[weight]++;\n    }\n    \n    int boats = 0;\n    int left = 1, right = limit;\n    \n    while (left <= right) {\n        // Skip weights with 0 frequency\n        while (left <= right && freq[left] == 0) left++;\n        while (left <= right && freq[right] == 0) right--;\n        \n        if (left > right) break;\n        \n        if (left + right <= limit && left != right) {\n            // Can pair\n            freq[left]--;\n            freq[right]--;\n            boats++;\n        } else if (left == right) {\n            // Same weight, pair if have at least 2\n            boats += (freq[left] + 1) / 2;\n            break;\n        } else {\n            // Heaviest goes alone\n            freq[right]--;\n            boats++;\n        }\n    }\n    \n    return boats;\n}",
        "java": "public int numRescueBoats(int[] people, int limit) {\n    int[] freq = new int[limit + 1];\n    \n    for (int weight : people) {\n        freq[weight]++;\n    }\n    \n    int boats = 0;\n    int left = 1, right = limit;\n    \n    while (left <= right) {\n        while (left <= right && freq[left] == 0) left++;\n        while (left <= right && freq[right] == 0) right--;\n        \n        if (left > right) break;\n        \n        if (left + right <= limit && left != right) {\n            freq[left]--;\n            freq[right]--;\n            boats++;\n        } else if (left == right) {\n            boats += (freq[left] + 1) / 2;\n            break;\n        } else {\n            freq[right]--;\n            boats++;\n        }\n    }\n    \n    return boats;\n}",
        "python": "def numRescueBoats(people: List[int], limit: int) -> int:\n    freq = [0] * (limit + 1)\n    \n    for weight in people:\n        freq[weight] += 1\n    \n    boats = 0\n    left, right = 1, limit\n    \n    while left <= right:\n        while left <= right and freq[left] == 0:\n            left += 1\n        while left <= right and freq[right] == 0:\n            right -= 1\n        \n        if left > right:\n            break\n        \n        if left + right <= limit and left != right:\n            freq[left] -= 1\n            freq[right] -= 1\n            boats += 1\n        elif left == right:\n            boats += (freq[left] + 1) // 2\n            break\n        else:\n            freq[right] -= 1\n            boats += 1\n    \n    return boats",
        "javascript": "var numRescueBoats = function(people, limit) {\n    const freq = new Array(limit + 1).fill(0);\n    \n    for (const weight of people) {\n        freq[weight]++;\n    }\n    \n    let boats = 0;\n    let left = 1, right = limit;\n    \n    while (left <= right) {\n        while (left <= right && freq[left] === 0) left++;\n        while (left <= right && freq[right] === 0) right--;\n        \n        if (left > right) break;\n        \n        if (left + right <= limit && left !== right) {\n            freq[left]--;\n            freq[right]--;\n            boats++;\n        } else if (left === right) {\n            boats += Math.ceil(freq[left] / 2);\n            break;\n        } else {\n            freq[right]--;\n            boats++;\n        }\n    }\n    \n    return boats;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Trying to pair lightest with lightest first (wrong greedy choice)",
    "Not sorting the array (two pointer needs sorted input)",
    "Forgetting that boat capacity is at most 2 people",
    "Incrementing boats twice when pairing (should only increment once)",
    "Not handling the case when left == right (one person left)",
    "Using wrong comparison: people[left] + people[right] < limit (should be <=)"
  ],
  "hints": [
    "Boat can carry at most 2 people - simplifies the problem!",
    "Greedy insight: always try to pair heaviest with lightest",
    "If heaviest + lightest > limit, heaviest must go alone",
    "Sort first, then use two pointers from both ends",
    "Each iteration uses exactly one boat (either paired or single)",
    "When left == right, one person remains who needs a boat"
  ],
  "followUp": [
    "What if boat can carry k people instead of 2? (More complex DP or greedy)",
    "What if people have different priorities? (Add priority dimension)",
    "Minimize total weight instead of boat count? (Different objective)",
    "Online algorithm (people arrive dynamically)? (Heap-based approach)",
    "What if boats have different capacities? (Assignment problem)",
    "Return actual groupings, not just count? (Track pairings)"
  ],
  "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Bloomberg"],
  "tags": ["greedy", "two-pointers", "array", "sorting"],
  "relatedProblems": [
    "Two Sum",
    "3Sum",
    "Container With Most Water",
    "Partition Labels",
    "Maximum Length of Pair Chain"
  ]
}
