{
  "questionId": "LC-45",
  "questionSlug": "jump-game-ii",
  "title": "Jump Game II",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/jump-game-ii/",
    "videos": [
      {
        "title": "Jump Game II - Greedy O(n) Solution",
        "url": "https://www.youtube.com/watch?v=dJ7sWiOoK7g",
        "channel": "NeetCode",
        "duration": "11:20",
        "language": "English"
      },
      {
        "title": "Jump Game II - Multiple Approaches",
        "url": "https://www.youtube.com/watch?v=BEFJgNYw4PE",
        "channel": "takeUforward",
        "duration": "15:45",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Jump Game II - Official Solution",
        "url": "https://leetcode.com/problems/jump-game-ii/solution/",
        "source": "LeetCode"
      },
      {
        "title": "Jump Game II - GeeksforGeeks",
        "url": "https://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Practice on LeetCode",
        "url": "https://leetcode.com/problems/jump-game-ii/",
        "platform": "LeetCode"
      }
    ]
  },
  "patternTriggers": "Minimum jumps to reach end? Use greedy with current and next reach boundaries!",
  "approaches": [
    {
      "name": "Greedy - BFS-like Window (Optimal)",
      "order": 1,
      "intuition": "Think of it as BFS levels. Each jump defines a window/level. Track farthest reachable in current window, jump when window ends.",
      "approach": "Use two pointers: current reach (end of current jump) and farthest reach (max from current window). Count jumps when current reach is crossed.",
      "steps": [
        "Initialize jumps = 0, currentEnd = 0, farthest = 0",
        "For i from 0 to n-2:",
        "  Update farthest = max(farthest, i + nums[i])",
        "  If i == currentEnd:",
        "    jumps++ (need another jump)",
        "    currentEnd = farthest (jump to farthest reachable)",
        "    If currentEnd >= n-1: break (reached end)",
        "Return jumps"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through array",
        "spaceExplanation": "Only using three variables"
      },
      "code": {
        "cpp": "int jump(vector<int>& nums) {\n    int n = nums.size();\n    if (n <= 1) return 0;\n    \n    int jumps = 0;\n    int currentEnd = 0;   // End of current jump window\n    int farthest = 0;     // Farthest reachable in current window\n    \n    for (int i = 0; i < n - 1; i++) {\n        // Update farthest reachable from current window\n        farthest = max(farthest, i + nums[i]);\n        \n        // When we reach end of current jump window\n        if (i == currentEnd) {\n            jumps++;\n            currentEnd = farthest;  // Make next jump\n            \n            // Early exit if we can reach the end\n            if (currentEnd >= n - 1) {\n                break;\n            }\n        }\n    }\n    \n    return jumps;\n}\n\n// Example: nums = [2,3,1,1,4]\n// i=0: farthest=max(0,0+2)=2, i==0 → jumps=1, currentEnd=2\n// i=1: farthest=max(2,1+3)=4\n// i=2: farthest=max(4,2+1)=4, i==2 → jumps=2, currentEnd=4 >= 4, break\n// Return 2\n\n// Example: nums = [2,3,0,1,4]\n// i=0: farthest=2, i==0 → jumps=1, currentEnd=2\n// i=1: farthest=max(2,1+3)=4\n// i=2: farthest=max(4,2+0)=4, i==2 → jumps=2, currentEnd=4 >= 4, break\n// Return 2",
        "java": "public int jump(int[] nums) {\n    int n = nums.length;\n    if (n <= 1) return 0;\n    \n    int jumps = 0;\n    int currentEnd = 0;\n    int farthest = 0;\n    \n    for (int i = 0; i < n - 1; i++) {\n        farthest = Math.max(farthest, i + nums[i]);\n        \n        if (i == currentEnd) {\n            jumps++;\n            currentEnd = farthest;\n            \n            if (currentEnd >= n - 1) {\n                break;\n            }\n        }\n    }\n    \n    return jumps;\n}",
        "python": "def jump(nums: List[int]) -> int:\n    n = len(nums)\n    if n <= 1:\n        return 0\n    \n    jumps = 0\n    current_end = 0\n    farthest = 0\n    \n    for i in range(n - 1):\n        farthest = max(farthest, i + nums[i])\n        \n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n            \n            if current_end >= n - 1:\n                break\n    \n    return jumps",
        "javascript": "var jump = function(nums) {\n    const n = nums.length;\n    if (n <= 1) return 0;\n    \n    let jumps = 0;\n    let currentEnd = 0;\n    let farthest = 0;\n    \n    for (let i = 0; i < n - 1; i++) {\n        farthest = Math.max(farthest, i + nums[i]);\n        \n        if (i === currentEnd) {\n            jumps++;\n            currentEnd = farthest;\n            \n            if (currentEnd >= n - 1) {\n                break;\n            }\n        }\n    }\n    \n    return jumps;\n};"
      }
    },
    {
      "name": "Greedy - Explicit Window Processing",
      "order": 2,
      "intuition": "Process each jump level explicitly. For each level, find max reachable, that becomes next level boundary.",
      "approach": "Use while loop to process jump levels. Each iteration explores one jump level and finds next level boundary.",
      "steps": [
        "Initialize jumps = 0, left = 0, right = 0",
        "While right < n-1:",
        "  Find farthest reachable from [left, right]:",
        "    For i in [left, right]:",
        "      farthest = max(farthest, i + nums[i])",
        "  Update: left = right + 1, right = farthest",
        "  jumps++",
        "Return jumps"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Each position visited once",
        "spaceExplanation": "Constant space"
      },
      "code": {
        "cpp": "int jump(vector<int>& nums) {\n    int n = nums.size();\n    if (n <= 1) return 0;\n    \n    int jumps = 0;\n    int left = 0, right = 0;\n    \n    while (right < n - 1) {\n        int farthest = 0;\n        \n        // Explore current jump level [left, right]\n        for (int i = left; i <= right; i++) {\n            farthest = max(farthest, i + nums[i]);\n        }\n        \n        // Move to next level\n        left = right + 1;\n        right = farthest;\n        jumps++;\n    }\n    \n    return jumps;\n}\n\n// Example: nums = [2,3,1,1,4]\n// Level 0: [0,0], farthest=2, next level [1,2], jumps=1\n// Level 1: [1,2], farthest=4, next level [3,4], jumps=2\n// right=4 >= n-1, done\n// Return 2",
        "java": "public int jump(int[] nums) {\n    int n = nums.length;\n    if (n <= 1) return 0;\n    \n    int jumps = 0;\n    int left = 0, right = 0;\n    \n    while (right < n - 1) {\n        int farthest = 0;\n        \n        for (int i = left; i <= right; i++) {\n            farthest = Math.max(farthest, i + nums[i]);\n        }\n        \n        left = right + 1;\n        right = farthest;\n        jumps++;\n    }\n    \n    return jumps;\n}",
        "python": "def jump(nums: List[int]) -> int:\n    n = len(nums)\n    if n <= 1:\n        return 0\n    \n    jumps = 0\n    left, right = 0, 0\n    \n    while right < n - 1:\n        farthest = 0\n        \n        for i in range(left, right + 1):\n            farthest = max(farthest, i + nums[i])\n        \n        left = right + 1\n        right = farthest\n        jumps += 1\n    \n    return jumps",
        "javascript": "var jump = function(nums) {\n    const n = nums.length;\n    if (n <= 1) return 0;\n    \n    let jumps = 0;\n    let left = 0, right = 0;\n    \n    while (right < n - 1) {\n        let farthest = 0;\n        \n        for (let i = left; i <= right; i++) {\n            farthest = Math.max(farthest, i + nums[i]);\n        }\n        \n        left = right + 1;\n        right = farthest;\n        jumps++;\n    }\n    \n    return jumps;\n};"
      }
    },
    {
      "name": "Dynamic Programming (Not Optimal)",
      "order": 3,
      "intuition": "For each position, calculate minimum jumps needed to reach it. Build from start to end.",
      "approach": "DP where dp[i] = minimum jumps to reach position i. For each position, update all reachable positions.",
      "steps": [
        "Create dp[n], initialize all to INT_MAX",
        "dp[0] = 0 (start position)",
        "For i from 0 to n-1:",
        "  For j from i+1 to min(i+nums[i], n-1):",
        "    dp[j] = min(dp[j], dp[i] + 1)",
        "Return dp[n-1]"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(n)",
        "timeExplanation": "For each position, update all reachable positions",
        "spaceExplanation": "DP array of size n"
      },
      "code": {
        "cpp": "int jump(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> dp(n, INT_MAX);\n    dp[0] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (dp[i] == INT_MAX) continue;\n        \n        for (int j = i + 1; j <= min(i + nums[i], n - 1); j++) {\n            dp[j] = min(dp[j], dp[i] + 1);\n        }\n    }\n    \n    return dp[n - 1];\n}\n\n// This works but O(n²) - greedy is better O(n)",
        "java": "public int jump(int[] nums) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (dp[i] == Integer.MAX_VALUE) continue;\n        \n        for (int j = i + 1; j <= Math.min(i + nums[i], n - 1); j++) {\n            dp[j] = Math.min(dp[j], dp[i] + 1);\n        }\n    }\n    \n    return dp[n - 1];\n}",
        "python": "def jump(nums: List[int]) -> int:\n    n = len(nums)\n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(n):\n        if dp[i] == float('inf'):\n            continue\n        \n        for j in range(i + 1, min(i + nums[i] + 1, n)):\n            dp[j] = min(dp[j], dp[i] + 1)\n    \n    return dp[n - 1]",
        "javascript": "var jump = function(nums) {\n    const n = nums.length;\n    const dp = new Array(n).fill(Infinity);\n    dp[0] = 0;\n    \n    for (let i = 0; i < n; i++) {\n        if (dp[i] === Infinity) continue;\n        \n        for (let j = i + 1; j <= Math.min(i + nums[i], n - 1); j++) {\n            dp[j] = Math.min(dp[j], dp[i] + 1);\n        }\n    }\n    \n    return dp[n - 1];\n};"
      }
    }
  ],
  "commonMistakes": [
    "Confusing with Jump Game I (this asks minimum jumps, not just if reachable)",
    "Using BFS with queue (works but O(n²) time, greedy is O(n))",
    "Not understanding the BFS-like window concept in greedy approach",
    "Loop going until i < n instead of i < n-1 (causes extra jump)",
    "Forgetting edge case: array with single element (0 jumps needed)",
    "Not updating currentEnd when i reaches it (miss jump timing)"
  ],
  "hints": [
    "Think of it as BFS levels without explicit queue",
    "Each jump defines a window/level of reachable positions",
    "currentEnd = end of current jump window",
    "farthest = max reach within current window (next jump destination)",
    "When i reaches currentEnd, must make next jump",
    "Loop to n-2 not n-1 (already at last position when currentEnd >= n-1)",
    "Greedy optimal: always jump to position that extends reach farthest"
  ],
  "followUp": [
    "Return actual jump sequence? (Track path during greedy)",
    "What if array has obstacles (unreachable positions)? (Check if farthest doesn't increase)",
    "What if we can jump backwards? (Different problem, might need BFS)",
    "Maximum jumps allowed? (Add constraint check in loop)",
    "Multiple optimal paths? (This greedy finds one, but many might exist)",
    "What if nums[i] can be 0? (Need to handle stuck positions)"
  ],
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Apple", "Bloomberg"],
  "tags": ["greedy", "array", "dynamic-programming"],
  "relatedProblems": [
    "Jump Game",
    "Jump Game III",
    "Jump Game IV",
    "Jump Game V",
    "Minimum Number of Jumps"
  ]
}
