{
  "questionId": "442",
  "questionSlug": "find-all-duplicates-in-an-array",
  "title": "Find All Duplicates in an Array",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/find-all-duplicates-in-an-array/",
    "videos": [
      {
        "title": "Find All Duplicates - In-Place Solution",
        "url": "https://www.youtube.com/watch?v=aMsSF1Il3IY",
        "channel": "NeetCode",
        "duration": "6:45",
        "language": "English"
      }
    ]
  },
  "patternTriggers": "Array [1,n], each appears once or twice, find duplicates = Marking or Cyclic Sort",
  "approaches": [
    {
      "name": "Hash Set",
      "order": 1,
      "intuition": "Track seen numbers, add duplicates to result",
      "approach": "Use set to detect duplicates",
      "steps": [
        "Create empty set",
        "For each num:",
        "  If num in set: add to result",
        "  Else: add to set",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass with O(1) set operations",
        "spaceExplanation": "Set stores up to n/2 elements"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        unordered_set<int> seen;\n        vector<int> result;\n        \n        for (int num : nums) {\n            if (seen.count(num)) {\n                result.push_back(num);\n            } else {\n                seen.insert(num);\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        Set<Integer> seen = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        \n        for (int num : nums) {\n            if (seen.contains(num)) {\n                result.add(num);\n            } else {\n                seen.add(num);\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        seen = set()\n        result = []\n        \n        for num in nums:\n            if num in seen:\n                result.append(num)\n            else:\n                seen.add(num)\n        \n        return result",
        "javascript": "var findDuplicates = function(nums) {\n    const seen = new Set();\n    const result = [];\n    \n    for (const num of nums) {\n        if (seen.has(num)) {\n            result.push(num);\n        } else {\n            seen.add(num);\n        }\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Mark as Negative - Optimal",
      "order": 2,
      "intuition": "Use indices as hash. When visiting num, mark nums[num-1] negative. If already negative, it's duplicate",
      "approach": "Negate to mark first occurrence, detect duplicate on second",
      "steps": [
        "For each num in nums:",
        "  index = abs(num) - 1",
        "  If nums[index] < 0:",
        "    num is duplicate, add to result",
        "  Else:",
        "    Mark nums[index] negative",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass",
        "spaceExplanation": "No extra space (output doesn't count)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        vector<int> result;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int index = abs(nums[i]) - 1;\n            \n            // If already negative, this is a duplicate\n            if (nums[index] < 0) {\n                result.push_back(abs(nums[i]));\n            } else {\n                // Mark as seen by negating\n                nums[index] = -nums[index];\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            int index = Math.abs(nums[i]) - 1;\n            \n            // If already negative, this is a duplicate\n            if (nums[index] < 0) {\n                result.add(Math.abs(nums[i]));\n            } else {\n                // Mark as seen\n                nums[index] = -nums[index];\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        result = []\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            \n            # If already negative, this is a duplicate\n            if nums[index] < 0:\n                result.append(abs(nums[i]))\n            else:\n                # Mark as seen\n                nums[index] = -nums[index]\n        \n        return result",
        "javascript": "var findDuplicates = function(nums) {\n    const result = [];\n    \n    for (let i = 0; i < nums.length; i++) {\n        const index = Math.abs(nums[i]) - 1;\n        \n        // If already negative, this is a duplicate\n        if (nums[index] < 0) {\n            result.push(Math.abs(nums[i]));\n        } else {\n            // Mark as seen\n            nums[index] = -nums[index];\n        }\n    }\n    \n    return result;\n};"
      }
    },
    {
      "name": "Cyclic Sort",
      "order": 3,
      "intuition": "Place each number at correct position. If position already has correct number, it's duplicate",
      "approach": "Cyclic sort with duplicate detection",
      "steps": [
        "While i < n:",
        "  correctPos = nums[i] - 1",
        "  If nums[i] != nums[correctPos]:",
        "    Swap to correct position",
        "  Else if nums[i] != i + 1:",
        "    Found duplicate, add to result and skip",
        "  Else:",
        "    i++",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Each element processed at most twice",
        "spaceExplanation": "In-place (output doesn't count)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        vector<int> result;\n        int n = nums.size();\n        int i = 0;\n        \n        // Cyclic sort with duplicate detection\n        while (i < n) {\n            int correctPos = nums[i] - 1;\n            \n            if (nums[i] != nums[correctPos]) {\n                swap(nums[i], nums[correctPos]);\n            } else if (nums[i] != i + 1) {\n                // Duplicate found\n                result.push_back(nums[i]);\n                i++;\n            } else {\n                i++;\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        int n = nums.length;\n        int i = 0;\n        \n        // Cyclic sort with duplicate detection\n        while (i < n) {\n            int correctPos = nums[i] - 1;\n            \n            if (nums[i] != nums[correctPos]) {\n                int temp = nums[i];\n                nums[i] = nums[correctPos];\n                nums[correctPos] = temp;\n            } else if (nums[i] != i + 1) {\n                // Duplicate found\n                result.add(nums[i]);\n                i++;\n            } else {\n                i++;\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        result = []\n        n = len(nums)\n        i = 0\n        \n        # Cyclic sort with duplicate detection\n        while i < n:\n            correct_pos = nums[i] - 1\n            \n            if nums[i] != nums[correct_pos]:\n                nums[i], nums[correct_pos] = nums[correct_pos], nums[i]\n            elif nums[i] != i + 1:\n                # Duplicate found\n                result.append(nums[i])\n                i += 1\n            else:\n                i += 1\n        \n        return result",
        "javascript": "var findDuplicates = function(nums) {\n    const result = [];\n    const n = nums.length;\n    let i = 0;\n    \n    // Cyclic sort with duplicate detection\n    while (i < n) {\n        const correctPos = nums[i] - 1;\n        \n        if (nums[i] !== nums[correctPos]) {\n            [nums[i], nums[correctPos]] = [nums[correctPos], nums[i]];\n        } else if (nums[i] !== i + 1) {\n            // Duplicate found\n            result.push(nums[i]);\n            i++;\n        } else {\n            i++;\n        }\n    }\n    \n    return result;\n};"
      }
    }
  ],
  "commonMistakes": [
    "Using nums[i] instead of abs(nums[i]) after marking negatives",
    "Not handling case where duplicate is already at correct position",
    "In cyclic sort, infinite loop if not incrementing on duplicate detection"
  ],
  "hints": [
    "Can you use array indices as a hash map?",
    "Marking approach: use sign to indicate presence",
    "When you see a number k, mark index k-1",
    "If index k-1 is already marked, k is duplicate"
  ],
  "followUp": [
    "What if array can't be modified?",
    "What if numbers appear 1, 2, or 3 times?",
    "Can you return duplicates in ascending order without extra sorting?"
  ],
  "companies": ["Amazon", "Microsoft", "Facebook", "Bloomberg"],
  "tags": ["array", "hash-table", "cyclic-sort"],
  "relatedProblems": [
    "Find All Numbers Disappeared in an Array",
    "Find the Duplicate Number",
    "Set Mismatch"
  ]
}
