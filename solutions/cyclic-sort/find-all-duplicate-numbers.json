{
  "questionId": "694d4a3a98494915f3bc8eac",
  "questionSlug": "find-all-duplicate-numbers",
  "resources": {
    "leetcode": "https://leetcode.com/problems/find-all-duplicates-in-an-array/",
    "videos": [
      {
        "title": "Find All Duplicates in an Array - Leetcode 442",
        "url": "https://www.youtube.com/watch?v=Y8x0iAVEIY0",
        "channel": "NeetCode",
        "duration": "7:28",
        "language": "English"
      },
      {
        "title": "Find Duplicates Using Cyclic Sort",
        "url": "https://www.youtube.com/watch?v=aMsSF1Il3IY",
        "channel": "takeUforward",
        "duration": "11:15",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Find All Duplicates in an Array",
        "url": "https://leetcode.com/problems/find-all-duplicates-in-an-array/solution/",
        "source": "LeetCode Editorial"
      },
      {
        "title": "Finding Duplicates in O(n) time",
        "url": "https://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Find the Duplicate Number",
        "url": "https://leetcode.com/problems/find-the-duplicate-number/",
        "platform": "LeetCode"
      },
      {
        "title": "Contains Duplicate",
        "url": "https://leetcode.com/problems/contains-duplicate/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Cyclic Sort pattern when array has numbers in range [1,n], need to find duplicates in O(n) time and O(1) space. Key indicators: each number appears once or twice, in-place solution required, array size n with numbers from 1 to n.",
  "approaches": [
    {
      "name": "Brute Force (Nested Loop)",
      "order": 1,
      "intuition": "Compare each element with every other element to find duplicates. If an element appears more than once, add it to result (making sure not to add same duplicate multiple times).",
      "approach": "Use two nested loops to compare all pairs. Track which duplicates we've already found to avoid adding them multiple times.",
      "steps": [
        "Create empty result list",
        "Create set to track found duplicates",
        "For each element at index i:",
        "  For each element at index j where j > i:",
        "    If nums[i] == nums[j]:",
        "      If nums[i] not in found duplicates:",
        "        Add nums[i] to result",
        "        Add nums[i] to found set",
        "Return result list"
      ],
      "complexity": {
        "time": "O(n²)",
        "space": "O(n)",
        "timeExplanation": "Nested loops compare each element with all others: n*(n-1)/2 comparisons = O(n²)",
        "spaceExplanation": "Set to track found duplicates can have up to n/2 elements in worst case"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        vector<int> result;\n        unordered_set<int> found;\n        int n = nums.size();\n        \n        // Compare each pair\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] == nums[j]) {\n                    // Found duplicate, add if not already in result\n                    if (found.find(nums[i]) == found.end()) {\n                        result.push_back(nums[i]);\n                        found.insert(nums[i]);\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        Set<Integer> found = new HashSet<>();\n        int n = nums.length;\n        \n        // Compare each pair\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] == nums[j]) {\n                    // Found duplicate, add if not already in result\n                    if (!found.contains(nums[i])) {\n                        result.add(nums[i]);\n                        found.add(nums[i]);\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "def find_duplicates(nums):\n    result = []\n    found = set()\n    n = len(nums)\n    \n    # Compare each pair\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] == nums[j]:\n                # Found duplicate, add if not already in result\n                if nums[i] not in found:\n                    result.append(nums[i])\n                    found.add(nums[i])\n    \n    return result",
        "javascript": "function findDuplicates(nums) {\n    const result = [];\n    const found = new Set();\n    const n = nums.length;\n    \n    // Compare each pair\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (nums[i] === nums[j]) {\n                // Found duplicate, add if not already in result\n                if (!found.has(nums[i])) {\n                    result.push(nums[i]);\n                    found.add(nums[i]);\n                }\n            }\n        }\n    }\n    \n    return result;\n}"
      }
    },
    {
      "name": "Better (Hash Set/Frequency Map)",
      "order": 2,
      "intuition": "Use a hash set or frequency map to track which numbers we've seen. As we iterate through array, if we see a number that's already in our set, it's a duplicate. Add it to result.",
      "approach": "Single pass through array using hash set to detect duplicates when we encounter them the second time.",
      "steps": [
        "Create empty hash set to track seen numbers",
        "Create empty result list",
        "For each number in array:",
        "  If number already in set:",
        "    Add to result (it's a duplicate)",
        "  Else:",
        "    Add number to set",
        "Return result list"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(n)",
        "timeExplanation": "Single pass through array with O(1) hash set operations",
        "spaceExplanation": "Hash set stores up to n unique numbers in worst case (no duplicates)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        unordered_set<int> seen;\n        vector<int> result;\n        \n        // Track seen numbers\n        for (int num : nums) {\n            if (seen.find(num) != seen.end()) {\n                // Found duplicate\n                result.push_back(num);\n            } else {\n                // First occurrence\n                seen.insert(num);\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        Set<Integer> seen = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        \n        // Track seen numbers\n        for (int num : nums) {\n            if (seen.contains(num)) {\n                // Found duplicate\n                result.add(num);\n            } else {\n                // First occurrence\n                seen.add(num);\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "def find_duplicates(nums):\n    seen = set()\n    result = []\n    \n    # Track seen numbers\n    for num in nums:\n        if num in seen:\n            # Found duplicate\n            result.append(num)\n        else:\n            # First occurrence\n            seen.add(num)\n    \n    return result",
        "javascript": "function findDuplicates(nums) {\n    const seen = new Set();\n    const result = [];\n    \n    // Track seen numbers\n    for (const num of nums) {\n        if (seen.has(num)) {\n            // Found duplicate\n            result.push(num);\n        } else {\n            // First occurrence\n            seen.add(num);\n        }\n    }\n    \n    return result;\n}"
      }
    },
    {
      "name": "Optimal (Cyclic Sort Pattern)",
      "order": 3,
      "intuition": "Use cyclic sort to place each number at its correct index (number k at index k-1). After sorting, numbers that are not at their correct positions are duplicates. We can identify duplicates during the sorting process itself when we try to swap but find the number is already at target position.",
      "approach": "Apply cyclic sort. When trying to place a number at its correct index, if that position already has the same number, it's a duplicate. After sorting, scan for positions where nums[i] != i+1.",
      "steps": [
        "Initialize i = 0",
        "While i < n:",
        "  Calculate correct index: correct_idx = nums[i] - 1",
        "  If nums[i] at wrong position and target position has different number:",
        "    Swap nums[i] with nums[correct_idx]",
        "  Else:",
        "    Move to next position: i++",
        "Create result list",
        "Scan array again:",
        "  If nums[i] != i + 1:",
        "    nums[i] is a duplicate, add to result",
        "Return result"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Cyclic sort takes O(n) as each number is swapped at most once, plus O(n) final scan = O(n)",
        "spaceExplanation": "In-place sorting, only result array for output (not counted as extra space)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        int i = 0;\n        int n = nums.size();\n        \n        // Cyclic sort\n        while (i < n) {\n            int correctIndex = nums[i] - 1;\n            \n            if (nums[i] != nums[correctIndex]) {\n                swap(nums[i], nums[correctIndex]);\n            } else {\n                i++;\n            }\n        }\n        \n        // Find duplicates\n        vector<int> result;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i + 1) {\n                result.push_back(nums[i]);\n            }\n        }\n        \n        return result;\n    }\n};",
        "java": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        int i = 0;\n        int n = nums.length;\n        \n        // Cyclic sort\n        while (i < n) {\n            int correctIndex = nums[i] - 1;\n            \n            if (nums[i] != nums[correctIndex]) {\n                // Swap\n                int temp = nums[i];\n                nums[i] = nums[correctIndex];\n                nums[correctIndex] = temp;\n            } else {\n                i++;\n            }\n        }\n        \n        // Find duplicates\n        List<Integer> result = new ArrayList<>();\n        for (int j = 0; j < n; j++) {\n            if (nums[j] != j + 1) {\n                result.add(nums[j]);\n            }\n        }\n        \n        return result;\n    }\n}",
        "python": "def find_duplicates(nums):\n    i = 0\n    n = len(nums)\n    \n    # Cyclic sort\n    while i < n:\n        correct_index = nums[i] - 1\n        \n        if nums[i] != nums[correct_index]:\n            nums[i], nums[correct_index] = nums[correct_index], nums[i]\n        else:\n            i += 1\n    \n    # Find duplicates\n    result = []\n    for i in range(n):\n        if nums[i] != i + 1:\n            result.append(nums[i])\n    \n    return result",
        "javascript": "function findDuplicates(nums) {\n    let i = 0;\n    const n = nums.length;\n    \n    // Cyclic sort\n    while (i < n) {\n        const correctIndex = nums[i] - 1;\n        \n        if (nums[i] !== nums[correctIndex]) {\n            [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n        } else {\n            i++;\n        }\n    }\n    \n    // Find duplicates\n    const result = [];\n    for (let i = 0; i < n; i++) {\n        if (nums[i] !== i + 1) {\n            result.push(nums[i]);\n        }\n    }\n    \n    return result;\n}"
      }
    }
  ],
  "commonMistakes": [
    "Not handling the case where number is already at correct position in cyclic sort",
    "Forgetting that numbers are 1-indexed (range [1,n]) not 0-indexed",
    "Adding same duplicate multiple times to result in brute force",
    "Modifying array when problem requires returning original state",
    "Off-by-one error in final scan: checking nums[i] != i instead of nums[i] != i+1",
    "Infinite loop when nums[i] == nums[correct_idx] but not incrementing i"
  ],
  "hints": [
    "If every number appears at most twice, how many duplicates can there be?",
    "Can you use the fact that numbers are in range [1,n] to place them at specific indices?",
    "After sorting with cyclic sort, where should number k be located?",
    "If a number is not at its expected position after sorting, what does it mean?",
    "Can you solve this without extra space by modifying the array?",
    "Think about marking visited numbers by making them negative"
  ],
  "followUp": [
    "What if numbers can appear more than twice?",
    "How would you find count of each duplicate, not just which numbers are duplicated?",
    "Can you solve without modifying the input array?",
    "What if array has numbers in range [0,n-1] instead of [1,n]?",
    "How would you handle negative numbers in the array?",
    "Can you identify the first duplicate encountered in a single pass?"
  ],
  "companies": [
    "Amazon",
    "Microsoft",
    "Google",
    "Facebook",
    "Apple",
    "Adobe",
    "Bloomberg"
  ],
  "tags": [
    "Array",
    "Cyclic Sort",
    "Hash Table",
    "In-Place"
  ],
  "relatedProblems": [
    "Find the Duplicate Number",
    "Find All Numbers Disappeared in an Array",
    "Contains Duplicate",
    "Set Mismatch",
    "Missing Number",
    "First Missing Positive"
  ]
}
