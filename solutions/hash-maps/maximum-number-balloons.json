{
  "questionId": "694d4a3a98494915f3bc8ebf",
  "questionSlug": "maximum-number-balloons",
  "title": "Maximum Number Balloons",
  "difficulty": "Medium",
  "resources": {
    "leetcode": "https://leetcode.com/problems/maximum-number-of-balloons/",
    "videos": [
      {
        "title": "Maximum Number of Balloons - Leetcode 1189",
        "url": "https://www.youtube.com/watch?v=G9xeB2KrY28",
        "channel": "NeetCode",
        "duration": "5:45",
        "language": "English"
      },
      {
        "title": "Count Balloon Instances | String Frequency Problem",
        "url": "https://www.youtube.com/watch?v=XPjak8RXhVI",
        "channel": "TECH DOSE",
        "duration": "8:30",
        "language": "English"
      },
      {
        "title": "Maximum Balloons Easy Solution",
        "url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
        "channel": "Kevin Naughton Jr.",
        "duration": "6:15",
        "language": "English"
      }
    ],
    "articles": [
      {
        "title": "Maximum Number of Balloons Solution",
        "url": "https://leetcode.com/problems/maximum-number-of-balloons/solution/",
        "source": "LeetCode Editorial"
      },
      {
        "title": "Max Balloons Problem Explained",
        "url": "https://algo.monster/liteproblems/1189",
        "source": "AlgoMonster"
      },
      {
        "title": "String Frequency Counting Pattern",
        "url": "https://www.geeksforgeeks.org/maximum-number-of-balloons/",
        "source": "GeeksforGeeks"
      }
    ],
    "practice": [
      {
        "title": "Ransom Note",
        "url": "https://leetcode.com/problems/ransom-note/",
        "platform": "LeetCode"
      },
      {
        "title": "Find Words That Can Be Formed by Characters",
        "url": "https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/",
        "platform": "LeetCode"
      },
      {
        "title": "Rearrange Characters to Make Target String",
        "url": "https://leetcode.com/problems/rearrange-characters-to-make-target-string/",
        "platform": "LeetCode"
      },
      {
        "title": "Maximum Repeating Substring",
        "url": "https://leetcode.com/problems/maximum-repeating-substring/",
        "platform": "LeetCode"
      }
    ],
    "discussions": []
  },
  "patternTriggers": "Use Frequency Count pattern when you need to determine how many times a word/pattern can be formed from available characters. Key indicators: count character occurrences, determine maximum instances of pattern, need to match specific character requirements, division-based calculation.",
  "approaches": [
    {
      "name": "Character Frequency Count",
      "order": 1,
      "intuition": "To form the word 'balloon', we need 1 'b', 1 'a', 2 'l', 2 'o', and 1 'n'. Count how many of each character we have, then determine the limiting factor. The answer is the minimum of (count[char] / required[char]) for all characters.",
      "approach": "Count frequency of each character in the input string. For word 'balloon', calculate how many complete words we can form by dividing available count by required count for each character. The minimum quotient is our answer.",
      "steps": [
        "Count frequency of all characters in input string",
        "Word 'balloon' requires: b=1, a=1, l=2, o=2, n=1",
        "Calculate maximum balloons from each character:",
        "  - From 'b': count['b'] / 1",
        "  - From 'a': count['a'] / 1",
        "  - From 'l': count['l'] / 2 (need 2 l's per balloon)",
        "  - From 'o': count['o'] / 2 (need 2 o's per balloon)",
        "  - From 'n': count['n'] / 1",
        "Return minimum of all these values (limiting factor)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through string to count frequencies, O(1) to check 5 characters",
        "spaceExplanation": "Hash map or array stores at most 26 characters, which is O(1)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int maxNumberOfBalloons(string text) {\n        // Count frequency of each character\n        unordered_map<char, int> freq;\n        for (char c : text) {\n            freq[c]++;\n        }\n        \n        // Calculate how many 'balloon' we can form\n        // balloon requires: b=1, a=1, l=2, o=2, n=1\n        int result = INT_MAX;\n        \n        result = min(result, freq['b']);\n        result = min(result, freq['a']);\n        result = min(result, freq['l'] / 2);  // need 2 l's\n        result = min(result, freq['o'] / 2);  // need 2 o's\n        result = min(result, freq['n']);\n        \n        return result == INT_MAX ? 0 : result;\n    }\n};",
        "java": "class Solution {\n    public int maxNumberOfBalloons(String text) {\n        // Count frequency of each character\n        Map<Character, Integer> freq = new HashMap<>();\n        for (char c : text.toCharArray()) {\n            freq.put(c, freq.getOrDefault(c, 0) + 1);\n        }\n        \n        // Calculate how many 'balloon' we can form\n        // balloon requires: b=1, a=1, l=2, o=2, n=1\n        int result = Integer.MAX_VALUE;\n        \n        result = Math.min(result, freq.getOrDefault('b', 0));\n        result = Math.min(result, freq.getOrDefault('a', 0));\n        result = Math.min(result, freq.getOrDefault('l', 0) / 2);  // need 2 l's\n        result = Math.min(result, freq.getOrDefault('o', 0) / 2);  // need 2 o's\n        result = Math.min(result, freq.getOrDefault('n', 0));\n        \n        return result == Integer.MAX_VALUE ? 0 : result;\n    }\n}",
        "python": "def maxNumberOfBalloons(text):\n    from collections import Counter\n    \n    # Count frequency of each character\n    freq = Counter(text)\n    \n    # Calculate how many 'balloon' we can form\n    # balloon requires: b=1, a=1, l=2, o=2, n=1\n    result = float('inf')\n    \n    result = min(result, freq.get('b', 0))\n    result = min(result, freq.get('a', 0))\n    result = min(result, freq.get('l', 0) // 2)  # need 2 l's\n    result = min(result, freq.get('o', 0) // 2)  # need 2 o's\n    result = min(result, freq.get('n', 0))\n    \n    return result if result != float('inf') else 0",
        "javascript": "function maxNumberOfBalloons(text) {\n    // Count frequency of each character\n    const freq = {};\n    for (const c of text) {\n        freq[c] = (freq[c] || 0) + 1;\n    }\n    \n    // Calculate how many 'balloon' we can form\n    // balloon requires: b=1, a=1, l=2, o=2, n=1\n    let result = Infinity;\n    \n    result = Math.min(result, freq['b'] || 0);\n    result = Math.min(result, freq['a'] || 0);\n    result = Math.min(result, Math.floor((freq['l'] || 0) / 2));  // need 2 l's\n    result = Math.min(result, Math.floor((freq['o'] || 0) / 2));  // need 2 o's\n    result = Math.min(result, freq['n'] || 0);\n    \n    return result === Infinity ? 0 : result;\n}"
      }
    },
    {
      "name": "Array-based Frequency Count (Optimal)",
      "order": 2,
      "intuition": "Same logic as hash map approach, but use an array for character counting which is more space-efficient and faster for lowercase letters.",
      "approach": "Use a 26-size array to count character frequencies. Check the limiting factor among required characters for 'balloon'. Return the minimum count.",
      "steps": [
        "Create array of size 26 initialized to 0",
        "Count frequency: freq[c - 'a']++ for each character",
        "Calculate balloons possible from each required character:",
        "  - b_count = freq['b' - 'a']",
        "  - a_count = freq['a' - 'a']",
        "  - l_count = freq['l' - 'a'] / 2",
        "  - o_count = freq['o' - 'a'] / 2",
        "  - n_count = freq['n' - 'a']",
        "Return min(b_count, a_count, l_count, o_count, n_count)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through string of length n",
        "spaceExplanation": "Fixed array of size 26, which is O(1)"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int maxNumberOfBalloons(string text) {\n        // Count frequency using array\n        vector<int> freq(26, 0);\n        for (char c : text) {\n            freq[c - 'a']++;\n        }\n        \n        // Calculate maximum balloons from each character\n        int b_count = freq['b' - 'a'];\n        int a_count = freq['a' - 'a'];\n        int l_count = freq['l' - 'a'] / 2;  // need 2 l's\n        int o_count = freq['o' - 'a'] / 2;  // need 2 o's\n        int n_count = freq['n' - 'a'];\n        \n        return min({b_count, a_count, l_count, o_count, n_count});\n    }\n};",
        "java": "class Solution {\n    public int maxNumberOfBalloons(String text) {\n        // Count frequency using array\n        int[] freq = new int[26];\n        for (char c : text.toCharArray()) {\n            freq[c - 'a']++;\n        }\n        \n        // Calculate maximum balloons from each character\n        int bCount = freq['b' - 'a'];\n        int aCount = freq['a' - 'a'];\n        int lCount = freq['l' - 'a'] / 2;  // need 2 l's\n        int oCount = freq['o' - 'a'] / 2;  // need 2 o's\n        int nCount = freq['n' - 'a'];\n        \n        return Math.min(bCount, Math.min(aCount, Math.min(lCount, Math.min(oCount, nCount))));\n    }\n}",
        "python": "def maxNumberOfBalloons(text):\n    # Count frequency using array\n    freq = [0] * 26\n    for c in text:\n        freq[ord(c) - ord('a')] += 1\n    \n    # Calculate maximum balloons from each character\n    b_count = freq[ord('b') - ord('a')]\n    a_count = freq[ord('a') - ord('a')]\n    l_count = freq[ord('l') - ord('a')] // 2  # need 2 l's\n    o_count = freq[ord('o') - ord('a')] // 2  # need 2 o's\n    n_count = freq[ord('n') - ord('a')]\n    \n    return min(b_count, a_count, l_count, o_count, n_count)",
        "javascript": "function maxNumberOfBalloons(text) {\n    // Count frequency using array\n    const freq = new Array(26).fill(0);\n    for (const c of text) {\n        freq[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    \n    // Calculate maximum balloons from each character\n    const bCount = freq['b'.charCodeAt(0) - 'a'.charCodeAt(0)];\n    const aCount = freq['a'.charCodeAt(0) - 'a'.charCodeAt(0)];\n    const lCount = Math.floor(freq['l'.charCodeAt(0) - 'a'.charCodeAt(0)] / 2);  // need 2 l's\n    const oCount = Math.floor(freq['o'.charCodeAt(0) - 'a'.charCodeAt(0)] / 2);  // need 2 o's\n    const nCount = freq['n'.charCodeAt(0) - 'a'.charCodeAt(0)];\n    \n    return Math.min(bCount, aCount, lCount, oCount, nCount);\n}"
      }
    },
    {
      "name": "Direct Count with Manual Tracking",
      "order": 3,
      "intuition": "Directly count only the characters we need ('b', 'a', 'l', 'o', 'n') while iterating through the string. No need to count all 26 characters.",
      "approach": "Initialize counters for each required character. Iterate once and increment respective counters. Calculate result by finding minimum after dividing by required count.",
      "steps": [
        "Initialize: b=0, a=0, l=0, o=0, n=0",
        "Iterate through string:",
        "  - If char is 'b', increment b",
        "  - If char is 'a', increment a",
        "  - If char is 'l', increment l",
        "  - If char is 'o', increment o",
        "  - If char is 'n', increment n",
        "Return min(b, a, l/2, o/2, n)"
      ],
      "complexity": {
        "time": "O(n)",
        "space": "O(1)",
        "timeExplanation": "Single pass through string",
        "spaceExplanation": "Only 5 integer variables"
      },
      "code": {
        "cpp": "class Solution {\npublic:\n    int maxNumberOfBalloons(string text) {\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\n        \n        // Count only required characters\n        for (char c : text) {\n            if (c == 'b') b++;\n            else if (c == 'a') a++;\n            else if (c == 'l') l++;\n            else if (c == 'o') o++;\n            else if (c == 'n') n++;\n        }\n        \n        // Return minimum (limiting factor)\n        return min({b, a, l / 2, o / 2, n});\n    }\n};",
        "java": "class Solution {\n    public int maxNumberOfBalloons(String text) {\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\n        \n        // Count only required characters\n        for (char c : text.toCharArray()) {\n            if (c == 'b') b++;\n            else if (c == 'a') a++;\n            else if (c == 'l') l++;\n            else if (c == 'o') o++;\n            else if (c == 'n') n++;\n        }\n        \n        // Return minimum (limiting factor)\n        return Math.min(b, Math.min(a, Math.min(l / 2, Math.min(o / 2, n))));\n    }\n}",
        "python": "def maxNumberOfBalloons(text):\n    b = a = l = o = n = 0\n    \n    # Count only required characters\n    for c in text:\n        if c == 'b':\n            b += 1\n        elif c == 'a':\n            a += 1\n        elif c == 'l':\n            l += 1\n        elif c == 'o':\n            o += 1\n        elif c == 'n':\n            n += 1\n    \n    # Return minimum (limiting factor)\n    return min(b, a, l // 2, o // 2, n)",
        "javascript": "function maxNumberOfBalloons(text) {\n    let b = 0, a = 0, l = 0, o = 0, n = 0;\n    \n    // Count only required characters\n    for (const c of text) {\n        if (c === 'b') b++;\n        else if (c === 'a') a++;\n        else if (c === 'l') l++;\n        else if (c === 'o') o++;\n        else if (c === 'n') n++;\n    }\n    \n    // Return minimum (limiting factor)\n    return Math.min(b, a, Math.floor(l / 2), Math.floor(o / 2), n);\n}"
      }
    }
  ],
  "commonMistakes": [
    "Forgetting that 'balloon' has TWO 'l's and TWO 'o's - must divide their counts by 2",
    "Not handling the case when some required characters are missing (count is 0)",
    "Using ceiling division instead of floor division for l and o counts",
    "Counting all 26 characters unnecessarily when only 5 are needed",
    "Returning the sum instead of the minimum of all character quotients",
    "Off-by-one errors in character counting or division"
  ],
  "hints": [
    "The word 'balloon' contains specific characters: b, a, l, l, o, o, n",
    "Count how many times each character appears in the input string",
    "Remember that 'l' and 'o' each appear twice in 'balloon'",
    "The answer is limited by whichever character runs out first",
    "Use floor division when calculating instances from characters that appear multiple times"
  ],
  "followUp": [
    "What if the target word changes? How would you generalize the solution?",
    "Can you solve this for multiple target words and return maximum instances for each?",
    "How would you handle case-insensitive matching?",
    "What if you need to find the maximum instances using characters from multiple strings?",
    "Can you optimize for very long strings with limited character sets?",
    "How would you solve this if you could use each character at most once across all balloons?"
  ],
  "companies": [
    "Amazon",
    "Google",
    "Microsoft",
    "Facebook",
    "Apple",
    "Bloomberg"
  ],
  "tags": [
    "Hash Table",
    "String",
    "Counting"
  ],
  "relatedProblems": [
    "Ransom Note",
    "Find Words That Can Be Formed by Characters",
    "Rearrange Characters to Make Target String",
    "Maximum Repeating Substring",
    "Check if Word Equals Summation of Two Words",
    "First Unique Character in a String",
    "Valid Anagram"
  ]
}